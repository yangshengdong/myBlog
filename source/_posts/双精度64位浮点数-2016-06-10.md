title: '双精度64位浮点数'
date: 2016-06-10 09:55:43
tags:
- JavaScript
comments: true
categories:
- JavaScript
---

# 浮点数

## 什么是浮点数？

在计算机系统的发展过程中，曾经提出过多种方法表达实数。典型的比如相对于浮点数的定点数（Fixed Point Number）。在这种表达方式中，小数点固定的位于实数所有数字中间的某个位置。货币的表达就可以使用这种方式，比如 99.00 或者 00.99 可以用于表达具有四位精度（Precision），小数点后有两位的货币值。由于小数点位置固定，所以可以直接用四位数值来表达相应的数值。
定点数表达法的缺点在于其形式过于僵硬，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数。最终，绝大多数现代的计算机系统采纳了所谓的浮点数表达方式。这种表达方式利用科学计数法来表达实数，即用一个尾数（Mantissa，尾数有时也称为有效数字——Significand；尾数实际上是有效数字的非正式说法），一个基数（Base），一个指数（Exponent）以及一个表示正负的符号来表达实数。比如 123.45 用十进制科学计数法可以表达为 1.2345 × 102 ，其中 1.2345 为尾数，10 为基数，2 为指数。浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。

<!--more-->
## IEEE 浮点数
计算机中是用有限的连续字节保存浮点数的。在 IEEE 标准中，浮点数是将特定长度的连续字节的所有二进制位分割为特定宽度的符号域，指数域和尾数域三个域，其中保存的值分别用于表示给定二进制浮点数中的符号，指数和尾数。这样，通过尾数和可以调节的指数（所以称为"浮点"）就可以表达给定的数值了。

两种基本的浮点格式：单精度和双精度。
* IEEE 单精度格式具有 24 位有效数字精度，并总共占用 32 位。

 {% asset_img 32.png %}
* IEEE 双精度格式具有 53 位有效数字精度，并总共占用 64 位

 {% asset_img 64.png %}

### 64位双精度浮点数 
 单精度在这里不做过多介绍直接介绍双精度64为，javascript的number数据类型就是使用的双精度64位。 
* 0到51 位包含 52 位小数 f，其中第 0 位是小数的最低有效位，第 51 位是最高有效位。
 IEEE 标准要求浮点数必须是规范的。这意味着尾数的小数点左侧必须为 1(这个看小数转换为浮点数的过程就能得知)，因此我们在保存尾数的时候，可以省略小数点前面这个 1，从而腾出一个二进制位来保存更多的尾数。这样我们实际上用 52 位长的尾数域表达了 53 位的尾数。
* 52到62 位包含 11 位偏置指数 e，第 52 位是偏置指数的最低有效位，第 62 位是最高有效位。
 11 位的指数为可以表达 0 到 2047 之间的2048个指数值。但是，指数可以为正数，也可以为负数。为了处理负指数的情况，实际的指数值按要求需要加上一个偏差（Bias）值作为保存在指数域中的值，双精度数的偏差值为1023；偏差的引入使得对于双精度数，实际可以表达的指数值的范围就变成 -1023到1024之间（包含两端）。稍后将介绍实际的指数值 -1023（保存为全0）以及 +1024（保存为全 1）保留用作特殊值的处理。
* 最高的第 63 位包含符号位s。s为0表示数值为正数，而s为1则表示负数。

## 将实数转换成浮点数

### 浮点数的规范化
同样的数值可以有多种浮点数表达方式，比如上面例子中的 123.45 可以表达为 12.345 × 101，0.12345 × 103 或者 1.2345 × 102。因为这种多样性，有必要对其加以规范化以达到统一表达的目标。规范的（Normalized）浮点数表达方式具有如下形式：`±d.dd...d × βe , (0 ≤ d i < β)`。
其中 d.dd...d 即尾数，β 为基数，e 为指数。尾数中数字的个数称为精度，在本文中用 p 来表示。每个数字 d 介于 0 和基数之间，包括 0。小数点左侧的数字不为 0。
基于规范表达的浮点数对应的具体值可由下面的表达式计算而得：`±(d 0 + d 1β-1 + ... + d p-1β-(p-1))βe , (0 ≤ d i < β)`
对于十进制的浮点数，即基数 β 等于 10 的浮点数而言，上面的表达式非常容易理解，也很直白。计算机内部的数值表达是基于二进制的。从上面的表达式，我们可以知道，二进制数同样可以有小数点，也同样具有类似于十进制的表达方式。只是此时 β 等于 2，而每个数字 d 只能在 0 和 1 之间取值。比如二进制数 1001.101 相当于 1 × 2<sup>3</sup> + 0 × 2<sup>2</sup> + 0 × 2<sup>1</sup> + 1 × 2<sup>0</sup> + 1 × 2<sup>-1</sup> + 0 × 2<sup>-2</sup> + 1 × 2<sup>-3</sup>，对应于十进制的 9.625。其规范浮点数表达为 1.001101 × 2<sup>3</sup>。

### 根据精度表示浮点数

问：要把小数装入计算机，总共分几步？你猜对了，3 步。

* 第一步：转换成二进制。
* 第二步：用二进制科学计算法表示。
* 第三步：表示成 IEEE 754 形式。

#### 如何把十进制小数转换成二进制小数。
十进制小数转换成二进制小数采用"乘2取整，顺序排列"法。
具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。
* 如：25.7=（11001.10110011001100110011001100110011...）B
  * 整数部分：
        25%2 = 1 ======== 1
        12%2 = 0 ======== 0
        6%2  = 3 ======== 0
        3%2  = 1 ======== 1
        1%2  = 1 ======== 1
 * 小数部分：
        0.7*2=1.4========取出整数部分1 
        0.4*2=0.8========取出整数部分0 
        0.8*2=1.6========取出整数部分1 
        0.6*2=1.2========取出整数部分1 
        0.2*2=0.4========取出整数部分0　 
        0.4*2=0.8========取出整数部分0 
        0.8*2=1.6========取出整数部分1 
        0.6*2=1.2========取出整数部分1 
        0.2*2=0.4========取出整数部分0 
 * 最后结果就是： 
        11001.1 0110 0110 0110 0110 0110 0110 0110 0110 0110...
 
#### 用二进制科学计算法表示
  11001.101100110 == 1.1001101100110 * 2<sup>4</sup>
#### 表示成 IEEE 754 形式
1. 正数 固符号位为 0 
2. 尾数 由于第一位使用是1,固取(首位1干掉了).10011 0110 0110 0110 0110 0110 0110 0110 0110 0110
3. 指数 4 + 1023(偏移量),转换为 二进制就是 10000000011
组合在一起就是 0 10000000011 10011 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 011

> 单精度32位的 偏移量是  Math.pow(2,8)/2 -1 == 127 ，双精度64位的偏移量是 Math.pow(2,11)/2 -1 == 1023 

### 哪些数能精确表示？
那么 0.1 在计算机中可以精确表示吗？答案是出人意料的， 不能。

在此之前，先思考个问题： `在 0.1 到 0.9 的 9 个小数中，有多少可以用二进制精确表示呢？`

我们按照乘以 2 取整数位的方法，把 0.1 表示为二进制（我假设那些不会进制转换的同学已经补习完了）：

(1) 0.1 x 2 = 0.2  取整数位 0 得 0.0
(2) 0.2 x 2 = 0.4  取整数位 0 得 0.00
(3) 0.4 x 2 = 0.8  取整数位 0 得 0.000
(4) 0.8 x 2 = 1.6  取整数位 1 得 0.0001
(5) 0.6 x 2 = 0.2  取整数位 1 得 0.00011
(6) 0.2 x 2 = 0.4  取整数位 0 得 0.000110
(7) 0.4 x 2 = 0.8  取整数位 0 得 0.0001100
(8) 0.8 x 2 = 1.6  取整数位 1 得 0.00011001
(9) 0.6 x 2 = 1.2  取整数位 1 得 0.000110011
(n) ...
我们得到一个无限循环的二进制小数 0.000110011…

我为什么要把这个计算过程这么详细的写出来呢？就是为了让你看，多看几遍，再多看几遍，继续看… 还没看出来，好吧，把眼睛揉一下，我提示你，把第一行去掉，从 (2) 开始看，看到 (6)，对比一下 (2) 和 (6)。 然后把前两行去掉，从 (3) 开始看…
明白了吧，0.2、0.4、0.6、0.8 都不能精确的表示为二进制小数。 难以置信，这可是所有的偶数啊！那奇数呢？ 答案就是：
0.1 到 0.9 的 9 个小数中，只有 0.5 可以用二进制精确的表示。
**如果把 0.0 再算上，那么就有两个数可以精确表示，一个奇数 0.5，一个偶数 0.0。** 

那么到底怎么确定一个数能否精确表示呢？还是回到我们熟悉的十进制分数。

1/2、5/9、34/25 哪些可以写成有限小数？把一个分数化到最简（分子分母无公约数），如果分母的因式分解只有 2 和 5，那么就可以写成有限小数，否则就是无限循环小数。为什么是 2 和 5 呢？因为他们是 10 的因子 10 = 2 x 5。二进制和十六进制呢？他们的因子只有 2，所以十六进制只是二进制的一种简写形式，它的精度和二进制一样。
**如果一个十进制数可以用二进制精确表示，那么它的最后一位肯定是 5。备注：这是个必要条件，而不是充分条件。**

###  为啥 0.2+0.4 不等于0.6
```javascript
0.2 + 0.4 //0.6000000000000001
```
1.6 + 2.8 = 4.4 
四舍五入得到 4。我们用另一种方法
先把 1.6 四舍五入为 2
再把 2.8 四舍五入为 3
最后求和 2 + 3 = 5
通过两种运算，我们得到了两个结果 4 和 5。同理，在我们的浮点数运算中，参与运算的两个数 0.2 和 0.4 精度已经丢失了，所以他们求和的结果已经不是 0.6 了。

## 特殊值

* 指数域不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数的计算值减去127（或1023），得到真实值，再将尾数前加上第一位的1。
* 指数域全为0。这时，浮点数的指数等于1-127（或者1-1023），尾数不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
* 指数域全为1。这时，如果尾数全为0，表示±无穷大（正负取决于符号位s）；如果尾数不全为0，表示这个数不是一个数（NaN）。

### NaN(Not a Number)
NaN 用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。
NaN 指数域全为 1，且尾数域不等于零的浮点数。IEEE 标准没有要求具体的尾数域，所以 NaN 实际上不是一个，而是一族。不同的实现可以自由选择尾数域的值来表达 NaN。
任何有 NaN 作为操作数的操作也将产生 NaN。用特殊的 NaN 来表达上述运算错误的意义在于避免了因这些错误而导致运算的不必要的终止。回顾我们对 NaN 的介绍，当零除以零时得到的结果不是无穷而是 NaN 。原因不难理解，当除数和被除数都逼近于零时，其商可能为任何值，所以 IEEE 标准决定此时用 NaN 作为商比较合适。
### 有符号的零
因为 IEEE 标准的浮点数格式中，小数点左侧的 1 是隐藏的，而零显然需要尾数必须是零。所以，零也就无法直接用这种格式表达而只能特殊处理。
实际上，零保存为尾数域为全为 0，指数域为 emin - 1 = -127，也就是说指数域也全为 0。考虑到符号域的作用，所以存在着两个零，即 +0 和 -0。不同于正负无穷之间是有序的，IEEE 标准规定正负零是相等的。
零有正负之分，的确非常容易让人困惑。这一点是基于数值分析的多种考虑，经利弊权衡后形成的结果。有符号的零可以避免运算中，特别是涉及无穷的运算中，符号信息的丢失。举例而言，如果零无符号，则等式 1/(1/x) = x 当x = ±∞ 时不再成立。原因是如果零无符号，1 和正负无穷的比值为同一个零，然后 1 与 0 的比值为正无穷，符号没有了。解决这个问题，除非无穷也没有符号。但是无穷的符号表达了上溢发生在数轴的哪一侧，这个信息显然是不能不要的。零有符号也造成了其它问题，比如当 x=y 时，等式1/x = 1/y 在 x 和 y 分别为 +0 和 -0 时，两端分别为正无穷和负无穷而不再成立。当然，解决这个问题的另一个思路是和无穷一样，规定零也是有序的。但是，如果零是有序的，则即使 if (x==0) 这样简单的判断也由于 x 可能是 ±0 而变得不确定了。两害取其轻者，零还是无序的好。