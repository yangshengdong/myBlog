{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":0},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":0},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":0},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":0},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":0},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":0},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":0},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":0},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":0},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":0},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":0},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":0},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":0},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":0},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"source/CNAME","path":"CNAME","modified":0}],"Cache":[{"_id":"source/404.html","shasum":"9ae5313c4ee64f8060cd08bad8a6a8270e0bd02c","modified":1452479190000},{"_id":"source/CNAME","shasum":"5bea78925f82297f017d461af01317b7a493d489","modified":1452478547000},{"_id":"source/_posts/1-JavaScrpt简介-2016-01-05.md","shasum":"e41e78fbc6d0c3ac9e93de6f2e23bd2888ab3d8a","modified":1453442264000},{"_id":"source/_posts/2-在HTML中使用JavaScrpt-2016-01-05/deferAsync.png","shasum":"405aba297cb925c030bc11878e291edc350b3645","modified":1452171438000},{"_id":"source/_posts/2-在HTML中使用JavaScrpt-2016-01-05.md","shasum":"d719e03fd1a46903ecf60ddcb21df761b0b6e440","modified":1453253613000},{"_id":"source/_posts/3-第三章基本概念-2016-01-20.md","shasum":"c6eaab2fda114c309c99566312907afa7a5668bb","modified":1454493911000},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/zongjie.png","shasum":"75b021d03703a62dffca85d21065daa074d2edc4","modified":1452226722000},{"_id":"source/_posts/DOMContentLoaded-2016-01-08.md","shasum":"589d363c2019cc1847f9f6a2a57f338982e5643c","modified":1453208396000},{"_id":"source/_posts/ECMAScrip中的对象存取器-getter和setter-2016-01-21.md","shasum":"53477985cd52e20b2a72c148a3cd7dc49fb96423","modified":1453369070000},{"_id":"source/_posts/void-0-2016-01-29.md","shasum":"1e741ccc4b7fd2bb5df3f38c5520707167644e9e","modified":1454053234000},{"_id":"source/_posts/webkit的预加载扫描器-2016-01-19.md","shasum":"c8b9ebe46cdb0553b9cba8e0a1accc4499da7911","modified":1453208403000},{"_id":"source/_posts/严格模式-2016-01-21/stracit.png","shasum":"79f6c9b89a2d7551182e34520bd2b55d84d279dc","modified":1454471627000},{"_id":"source/_posts/严格模式-2016-01-21.md","shasum":"d6cedc964053f6c1632050e45bdf054bd69aa843","modified":1454471953000},{"_id":"source/_posts/好好学学Object-2016-02-03.md","shasum":"e0e4f07ed7cdb36cb0452614556241b4c1042fb8","modified":1454578533000},{"_id":"source/_posts/好好学学String-2016-02-02.md","shasum":"843d01d0c0198acda3e6de551e1436db87462e72","modified":1454487014000},{"_id":"source/_posts/好好学学number-2016-01-29.md","shasum":"eef6831385ba76ad9bc86392adf24775d44212e6","modified":1454396957000},{"_id":"source/_posts/好好学学undefined！-2016-01-29.md","shasum":"c304d31e6e9a40b76029b7aeed201c3f6dab78ee","modified":1454392617000},{"_id":"source/_posts/如何学习javascript-转帖-2016-01-27.md","shasum":"86d88de583c4d5b64794f5feb02d861820a8a022","modified":1453862572000},{"_id":"source/baidu_verify_i0wnrfk2ui.html","shasum":"48d9c82953f45c582fba83160d71d4df0ec7103f","modified":1452572516000},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/onLoadVSDomContentLoaded.png","shasum":"597586264b44d04e58387eb02379818a338627b1","modified":1452220118000},{"_id":"source/_posts/好好学学number-2016-01-29/number.png","shasum":"6d0564a349b5e99daa5b5588314b3a4ce45f7fd1","modified":1453980343000},{"_id":"source/_posts/好好学学number-2016-01-29/number2.png","shasum":"2735883e61ae234615de6234b9280f12a4e4ba47","modified":1454043023000},{"_id":"themes/jacman/LICENSE","shasum":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1450859342000},{"_id":"themes/jacman/README.md","shasum":"79be8a49927c8666f1804d7ccd08af8d3268062a","modified":1450859342000},{"_id":"themes/jacman/README_zh.md","shasum":"0854e4c96f53005f3a47e21af3f8aee361719ce4","modified":1450859342000},{"_id":"themes/jacman/_config.yml","shasum":"ec3e1c2147b1223cf10a14ba768a931a2e13f31d","modified":1452228411000},{"_id":"themes/jacman/languages/default.yml","shasum":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1450859342000},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1450859342000},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"f0772c9de0431384d4e852358ee425a1cdf3ea6d","modified":1453707593000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"32db7e7c8171530d29c3878f387c4438d6057508","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"c4f527fff0070fbe65919053a16224412317f40d","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","shasum":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1450859342000},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1450859342000},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1450859342000},{"_id":"themes/jacman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1450859342000},{"_id":"themes/jacman/layout/layout.ejs","shasum":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1450859342000},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1450859342000},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1450859342000},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1450859342000},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","shasum":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","shasum":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"f016180726019927b9a835ed01e04d153f27a149","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"1136600932b97534b88465bf05ef313630b2de3d","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1450859342000},{"_id":"themes/jacman/source/css/style.styl","shasum":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1450859342000},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1450859342000},{"_id":"themes/jacman/source/img/author.jpg","shasum":"2a292e681b4c6c975eec9c8c356d99647a465542","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1450859342000},{"_id":"themes/jacman/source/img/favicon.ico","shasum":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1450859342000},{"_id":"themes/jacman/source/img/jacman.jpg","shasum":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1450859342000},{"_id":"themes/jacman/source/img/logo.svg","shasum":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1450859342000},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1450859342000},{"_id":"themes/jacman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1450859342000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1450859342000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","shasum":"57c3987166a26415a71292162690e82c21e315ad","modified":1450859342000},{"_id":"themes/jacman/source/js/totop.js","shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1450859342000},{"_id":"themes/jacman/source/img/logo.png","shasum":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1450859342000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1450859342000},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1450859342000},{"_id":"public/js/totop.js","modified":1454493961620,"shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb"},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","modified":1454493961628,"shasum":"57c3987166a26415a71292162690e82c21e315ad"},{"_id":"public/js/jquery.imagesloaded.min.js","modified":1454493961632,"shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f"},{"_id":"public/js/jquery-2.0.3.min.js","modified":1454493961637,"shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d"},{"_id":"public/js/gallery.js","modified":1454493961640,"shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed"},{"_id":"public/img/scrollup.png","modified":1454493961645,"shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3"},{"_id":"public/img/logo.svg","modified":1454493961648,"shasum":"9ae38f7225c38624faeb7b74996efa9de7bf065b"},{"_id":"public/img/logo.png","modified":1454493961652,"shasum":"fd08d12d1fa147cf894e8f8327e38f1758de32ed"},{"_id":"public/img/jacman.jpg","modified":1454493961661,"shasum":"0ba14a4a5e3be012826fc713c33479912126d34e"},{"_id":"public/img/favicon.ico","modified":1454493961664,"shasum":"2d22a3e0c7905a894e832c831dd91c29c209c7a5"},{"_id":"public/img/cc-zero.svg","modified":1454493961666,"shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030"},{"_id":"public/img/cc-by.svg","modified":1454493961670,"shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e"},{"_id":"public/img/cc-by-sa.svg","modified":1454493961673,"shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e"},{"_id":"public/img/cc-by-nd.svg","modified":1454493961676,"shasum":"c563508ce9ced1e66948024ba1153400ac0e0621"},{"_id":"public/img/cc-by-nc.svg","modified":1454493961678,"shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7"},{"_id":"public/img/cc-by-nc-sa.svg","modified":1454493961682,"shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e"},{"_id":"public/img/cc-by-nc-nd.svg","modified":1454493961698,"shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564"},{"_id":"public/img/banner.jpg","modified":1454493961703,"shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74"},{"_id":"public/img/author.jpg","modified":1454493961706,"shasum":"2a292e681b4c6c975eec9c8c356d99647a465542"},{"_id":"public/font/fontdiao.woff","modified":1454493961709,"shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f"},{"_id":"public/font/fontdiao.ttf","modified":1454493961712,"shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab"},{"_id":"public/font/fontdiao.svg","modified":1454493961717,"shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b"},{"_id":"public/font/fontdiao.eot","modified":1454493961720,"shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9"},{"_id":"public/font/fontawesome-webfont.woff","modified":1454493961723,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/font/fontawesome-webfont.ttf","modified":1454493961727,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/font/fontawesome-webfont.svg","modified":1454493961730,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/font/fontawesome-webfont.eot","modified":1454493961733,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/font/coveredbyyourgrace-webfont.woff","modified":1454493961736,"shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e"},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","modified":1454493961740,"shasum":"194ccb4acf77a03dc25bcc174edb266143704fec"},{"_id":"public/font/coveredbyyourgrace-webfont.svg","modified":1454493961744,"shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53"},{"_id":"public/font/coveredbyyourgrace-webfont.eot","modified":1454493961747,"shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de"},{"_id":"public/font/FontAwesome.otf","modified":1454493961749,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1454493961753,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1454493961756,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1454493961758,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1454493961760,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1454493961763,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1454493961767,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1454493961769,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1454493961772,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1454493961774,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1454493961778,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1454493961781,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1454493961783,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1454493961786,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1454493961788,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1454493961791,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1454493962380,"shasum":"b12fa858391638038d79987085c32a9928ecf7b8"},{"_id":"public/CNAME","modified":1454493962831,"shasum":"5bea78925f82297f017d461af01317b7a493d489"},{"_id":"public/2016/01/29/好好学学number/number.png","modified":1454493962835,"shasum":"6d0564a349b5e99daa5b5588314b3a4ce45f7fd1"},{"_id":"public/2016/01/29/好好学学number/number2.png","modified":1454493962839,"shasum":"2735883e61ae234615de6234b9280f12a4e4ba47"},{"_id":"public/2016/01/21/严格模式/stracit.png","modified":1454493962844,"shasum":"79f6c9b89a2d7551182e34520bd2b55d84d279dc"},{"_id":"public/2016/01/08/DOMContentLoaded/onLoadVSDomContentLoaded.png","modified":1454493962847,"shasum":"597586264b44d04e58387eb02379818a338627b1"},{"_id":"public/2016/01/08/DOMContentLoaded/zongjie.png","modified":1454493962852,"shasum":"75b021d03703a62dffca85d21065daa074d2edc4"},{"_id":"public/2016/01/05/2-在HTML中使用JavaScrpt/deferAsync.png","modified":1454493962855,"shasum":"405aba297cb925c030bc11878e291edc350b3645"},{"_id":"public/404.html","modified":1454494112314,"shasum":"f32aa860a2d7710c4762bebd8be7c258b20b168f"},{"_id":"public/baidu_verify_i0wnrfk2ui.html","modified":1454493962940,"shasum":"b3f41baff9e890ecfccc0a8d360fd0919a39b450"},{"_id":"public/2016/02/02/好好学学String/index.html","modified":1454494112422,"shasum":"9b41d67c3cbcb4cca0f7775e03ba3e94f1c750be"},{"_id":"public/2016/01/29/void-0/index.html","modified":1454494112439,"shasum":"7a33f64f35bb34b78862e338881a3569327d1dc1"},{"_id":"public/2016/01/29/好好学学number/index.html","modified":1454494112506,"shasum":"e2fe0467556b4caadff6fb83cb4e73ee468c76e7"},{"_id":"public/2016/01/29/好好学学undefined！/index.html","modified":1454494112524,"shasum":"a6b2e300f93a81b5c40a20bb3e8fc19bcf5e1340"},{"_id":"public/2016/01/27/如何学习javascript-转帖/index.html","modified":1454494112550,"shasum":"40f488048cbc58c3d450c3bb85354f1f90253dd3"},{"_id":"public/2016/01/21/ECMAScrip中的对象存取器-getter和setter/index.html","modified":1454494112565,"shasum":"fc9e02f3189bb21cdedf075be5f8cebf1aaa675c"},{"_id":"public/2016/01/21/严格模式/index.html","modified":1454494112597,"shasum":"6c3719b87dcad6a3b61ff350b7d7ef8b389a7613"},{"_id":"public/2016/01/20/3-第三章基本概念/index.html","modified":1454494112630,"shasum":"37cfff0bffdce1bc698ea436bf91be04f22de672"},{"_id":"public/2016/01/19/webkit的预加载扫描器/index.html","modified":1454494112655,"shasum":"725eac175c0131a1bda33105f8f0c440c0dddfc5"},{"_id":"public/2016/01/08/DOMContentLoaded/index.html","modified":1454494112674,"shasum":"1e6c3884c1c0b479da11ef7438445ec9e289d768"},{"_id":"public/2016/01/05/2-在HTML中使用JavaScrpt/index.html","modified":1454494112699,"shasum":"445b7379f5c8bb961da4443e61fb468454ac999f"},{"_id":"public/2016/01/05/1-JavaScrpt简介/index.html","modified":1454494112720,"shasum":"5bb8fc7c8cd1ab06059b2d96bd89629ca2ff7ea6"},{"_id":"public/archives/index.html","modified":1454494112843,"shasum":"40183a00116ebe00384c6fbcb0c2b9b8bbdcb3c9"},{"_id":"public/archives/page/2/index.html","modified":1454494112850,"shasum":"236a9d668fa652a6516116f3bfe302a9e352b81d"},{"_id":"public/archives/2016/index.html","modified":1454494112860,"shasum":"11bf7022afbf6ce28283074883b3cb5f648e91b5"},{"_id":"public/archives/2016/page/2/index.html","modified":1454494112867,"shasum":"04d31612ecc4c115a2f93fc5d7e6072771a28d30"},{"_id":"public/archives/2016/01/index.html","modified":1454494112878,"shasum":"13caad97dd86ace05bb9db8e0bf4df2c301dce69"},{"_id":"public/archives/2016/01/page/2/index.html","modified":1454494112884,"shasum":"52c8c27c834a6b77c24afb741495e89bb535fc0a"},{"_id":"public/archives/2016/02/index.html","modified":1454494112891,"shasum":"75fca88232eed63006c5f3734aca9a0093b5da0e"},{"_id":"public/categories/JavaScript/index.html","modified":1454493963530,"shasum":"bff29563624f46f2f1a9110bb8aded5e4110e1ca"},{"_id":"public/categories/《JS高程3-笔记》/index.html","modified":1454494112828,"shasum":"ed517db327c398719abf6225c1c3d6832f812461"},{"_id":"public/index.html","modified":1454578558843,"shasum":"6a60f12a9b280f639242e15be3c90cd20065ee50"},{"_id":"public/page/2/index.html","modified":1454494112765,"shasum":"4509d0b3909b3626c802ce9c17096b739a118d52"},{"_id":"public/tags/JavaScript/index.html","modified":1454494112779,"shasum":"3dea7f3696844a925bbec838d560094219e97b33"},{"_id":"public/tags/JavaScript/page/2/index.html","modified":1454494112793,"shasum":"c47f7fd2168f345b051e217d48c2e9dafe701c02"},{"_id":"public/tags/jQuery/index.html","modified":1454493963663,"shasum":"5912a2f39dab4b282c8144ccab206138c81fea9d"},{"_id":"public/2016/02/03/好好学学Object/index.html","modified":1454578558330,"shasum":"a1c3415dc3c85089e8b49c9773fdac7e1ab0d2d4"}],"Category":[{"name":"JavaScript","_id":"cik6o5exl0003703v50uzz643"},{"name":"《JS高程3-笔记》","_id":"cik6o5ezq000z703vta55p519"}],"Data":[],"Page":[{"layout":"default","_content":"<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"www.yangshengdonghome.com\" homePageName=\"前端之路\"></script>","source":"404.html","raw":"---\nlayout: default\n---\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"www.yangshengdonghome.com\" homePageName=\"前端之路\"></script>","date":"2016-01-11T01:58:24.000Z","updated":"2016-01-11T02:26:30.000Z","path":"404.html","title":"","comments":1,"_id":"cik6o5ewr0000703v5lexoo9y"},{"_content":"i0wnrfk2ui","source":"baidu_verify_i0wnrfk2ui.html","raw":"i0wnrfk2ui","date":"2016-01-12T04:22:37.000Z","updated":"2016-01-12T04:21:56.000Z","path":"baidu_verify_i0wnrfk2ui.html","title":"","comments":1,"layout":"page","_id":"cik6o5exb0001703vrzco14bs"}],"Post":[{"title":"如何学习javascript(转帖)","date":"2016-01-27T02:24:34.000Z","comments":1,"_content":"# 首先说明\n首先要说明的是，咱现在不是高手，最多还是一个半桶水，算是入了JS的门。 谈不上经验，都是一些教训。这个时候有人要说，“靠，你丫半桶水，凭啥教我们”。您先别急着骂，先听我说。你叫一个大学生去教小学数学，不见得比一个初中生教得好。因为大学生早已经过了那个阶段，都忘记自己怎么走过来的了。而对于初中生，刚好走过那个阶段，对自己怎么走过来的还记忆犹新，或者还有一些自己的总结。比如，很多高手觉得那本犀牛书入门很好，他们觉得太简单了，但以我的经验来看，它不是入门的最好选择。\n<!--more-->\n# 先说说学js的条件\n论条件，咱是文科生，大学专业工商管理，和计算机毛关系都没；有人说英语，读了四年大学，很遗憾，咱还四级没混过；就咱这条件都学得乐呵呵的，您还等啥。 当然学习JS也是有门槛的，就是你的html和css至少还比较熟练，您不能连<body>这东东是干啥的都不知道就开始上JS了，学乘除前，学好加减法总是有益无害的。\n# 再说几点忠告\n\n1. 不要着急看一些复杂网页效果的代码，这样除了打击你自信心，什么也学不到。没达到一定的武功水平，割了小JJ也学不会葵花宝典的。\n2. 别急着加技术交流QQ群，加牛人QQ。如果你找张三丰交流武功，你上去第一句问“丰哥，where is 丹田？”，你会被他一掌劈死的。\n3. 看网上什么多少天精通JS，啥啥啥从入门到精通，这种教程直接跳过吧，太多的事实证明，以一种浮躁的心态去做任何事都会以失败而告终。\n4. 千万别去弄啥电脑培训，花了钱和时间不说，关键是学不到东西。本来你买两本好书自学3个月能学会的，他们硬是能折腾你两年。\n\n# 推荐几本好书\n“超毛，你丫吹了半天牛B，还是没说怎么学啊” 呵呵，我也没啥特别的办法，只是推荐几本好书。推荐的书，得按先后顺序看。别第一本没看完，就急着上第二本，并不是每次“穿越”都能成功的\n## 第一阶段：《JavaScript DOM编程艺术》\n看这本书之前，请先确认您对Javascript有个基本的了解，应该知道if else之类的语法，如果不懂，先去看看我第二阶段推荐的《Javascript高级程序设计》的前三章，记住看三章就别往下看了，回到《JavaScript DOM编程艺术》这本书上来。 学习Javascript用《JavaScript DOM编程艺术》来入门最好不过了，老老实实看两遍，看完了你就会对JS有一个大概的了解，整本书都围绕着一个网页效果例子展开，你跟着老老实实敲一篇，敲完之后，你会发现这个效果不是常在网页中看到么，发现自己也能做出来网上的效果了，嘿嘿，小有成就感吧。\n## 第二阶段：《JavaScript高级程序设计》\n有的书是用来成为经典的，比如犀牛书；还有些书是用来超越经典的，显然这本书就是这种。书中章章经典，由浅入深，其中第6章，关于JS面向对象的解说，没有教程出其右。 如果有一场满分100分的JS考试，看了《JavaScript DOM编程艺术》能让你拿到20分，那么看完这本书，你就能拿到60分以上了。学完后，你会成就感倍增的，相信我（至少看两遍，推荐三篇，跟着书上的代码一行行的敲）。 这本书强烈推荐购买，写的太TMD牛逼了，给你带来的价值超过百倍千倍。 这本书最新的是第三版，貌似就是前些日子出来的，我看的是第二版，第三版相对第二版变动不大，添加了几章内容，价格目前相差10元左右。 接下来，恭喜你可以下山了，这个时候可以自己做一些事情了。 你可以去Ferris这个教程看看他写的这些效果，看看源代码，怎么样，是不是觉得有一部分很简单了，尝试着跟着他写一写这些效果吧。 学技术闭门造车是行不通的，适当的加一两个QQ群交流（注重质量），常去论坛逛逛，你会经常有些小收获的。 再有就是看看前辈这些牛人前辈们分享的文章，它会让你的学习事半功倍的，这里是热心人收集的国内一些牛人的博客、个人网站，点这里。\n## 第三阶段：《JavaScript语言精粹》和《高性能JavaScript》\n接下来两本书《JavaScript语言精粹》和《高性能JavaScript》算是JS高级教程的补充，里面有一些内容和JS高级教程重复了，两本书可以同时看，都不厚，可以对前面所学的有一个很好的加强和巩固。\n## 第四阶段：《JavaScript DOM高级程序设计》和《JavaScript设计模式》\n在吃透了前面所说的书之后，接下来两本书的顺序已经无关紧要了，《JavaScript DOM高级程序设计》（注意和《JavaScript 高级程序设计》相区别）和《JavaScript设计模式》，这两本都是重量级的书，能让你的JS技术上一个新的台阶；这两本书前者主修炼外功，后者主修炼内功，有点想乾坤大挪移和九阳神功的关系。《JavaScript DOM高级程序设计》 首先教你搭建一个类似JQuery的额工具函数库，然后通过讲解几个实际中经常遇到的几个应用例子，会让初学者受益匪浅。《JavaScript设计模式》主要讲Javascript的设计模式，说实话，翻译的质量很一般，有些生硬，但已经基本不影响你的学习，看代码完全可以理解出自己的意思。\n# 最后想说的\n不安逸，不浮躁。任何学习都不是一蹴而就的，牛B就是一个学习积累的过程，别指望两三个月，你的水平就多么厉害。倚天屠龙记里面的武功最牛B的是张三丰，而不是张无忌。任何工作都需要多种技能，别忽略了html, css等其他知识的学习。\n\n>转自 (博客园)[http://kb.cnblogs.com/page/191787/]","source":"_posts/如何学习javascript-转帖-2016-01-27.md","raw":"title: 如何学习javascript(转帖)\ndate: 2016-01-27 10:24:34\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# 首先说明\n首先要说明的是，咱现在不是高手，最多还是一个半桶水，算是入了JS的门。 谈不上经验，都是一些教训。这个时候有人要说，“靠，你丫半桶水，凭啥教我们”。您先别急着骂，先听我说。你叫一个大学生去教小学数学，不见得比一个初中生教得好。因为大学生早已经过了那个阶段，都忘记自己怎么走过来的了。而对于初中生，刚好走过那个阶段，对自己怎么走过来的还记忆犹新，或者还有一些自己的总结。比如，很多高手觉得那本犀牛书入门很好，他们觉得太简单了，但以我的经验来看，它不是入门的最好选择。\n<!--more-->\n# 先说说学js的条件\n论条件，咱是文科生，大学专业工商管理，和计算机毛关系都没；有人说英语，读了四年大学，很遗憾，咱还四级没混过；就咱这条件都学得乐呵呵的，您还等啥。 当然学习JS也是有门槛的，就是你的html和css至少还比较熟练，您不能连<body>这东东是干啥的都不知道就开始上JS了，学乘除前，学好加减法总是有益无害的。\n# 再说几点忠告\n\n1. 不要着急看一些复杂网页效果的代码，这样除了打击你自信心，什么也学不到。没达到一定的武功水平，割了小JJ也学不会葵花宝典的。\n2. 别急着加技术交流QQ群，加牛人QQ。如果你找张三丰交流武功，你上去第一句问“丰哥，where is 丹田？”，你会被他一掌劈死的。\n3. 看网上什么多少天精通JS，啥啥啥从入门到精通，这种教程直接跳过吧，太多的事实证明，以一种浮躁的心态去做任何事都会以失败而告终。\n4. 千万别去弄啥电脑培训，花了钱和时间不说，关键是学不到东西。本来你买两本好书自学3个月能学会的，他们硬是能折腾你两年。\n\n# 推荐几本好书\n“超毛，你丫吹了半天牛B，还是没说怎么学啊” 呵呵，我也没啥特别的办法，只是推荐几本好书。推荐的书，得按先后顺序看。别第一本没看完，就急着上第二本，并不是每次“穿越”都能成功的\n## 第一阶段：《JavaScript DOM编程艺术》\n看这本书之前，请先确认您对Javascript有个基本的了解，应该知道if else之类的语法，如果不懂，先去看看我第二阶段推荐的《Javascript高级程序设计》的前三章，记住看三章就别往下看了，回到《JavaScript DOM编程艺术》这本书上来。 学习Javascript用《JavaScript DOM编程艺术》来入门最好不过了，老老实实看两遍，看完了你就会对JS有一个大概的了解，整本书都围绕着一个网页效果例子展开，你跟着老老实实敲一篇，敲完之后，你会发现这个效果不是常在网页中看到么，发现自己也能做出来网上的效果了，嘿嘿，小有成就感吧。\n## 第二阶段：《JavaScript高级程序设计》\n有的书是用来成为经典的，比如犀牛书；还有些书是用来超越经典的，显然这本书就是这种。书中章章经典，由浅入深，其中第6章，关于JS面向对象的解说，没有教程出其右。 如果有一场满分100分的JS考试，看了《JavaScript DOM编程艺术》能让你拿到20分，那么看完这本书，你就能拿到60分以上了。学完后，你会成就感倍增的，相信我（至少看两遍，推荐三篇，跟着书上的代码一行行的敲）。 这本书强烈推荐购买，写的太TMD牛逼了，给你带来的价值超过百倍千倍。 这本书最新的是第三版，貌似就是前些日子出来的，我看的是第二版，第三版相对第二版变动不大，添加了几章内容，价格目前相差10元左右。 接下来，恭喜你可以下山了，这个时候可以自己做一些事情了。 你可以去Ferris这个教程看看他写的这些效果，看看源代码，怎么样，是不是觉得有一部分很简单了，尝试着跟着他写一写这些效果吧。 学技术闭门造车是行不通的，适当的加一两个QQ群交流（注重质量），常去论坛逛逛，你会经常有些小收获的。 再有就是看看前辈这些牛人前辈们分享的文章，它会让你的学习事半功倍的，这里是热心人收集的国内一些牛人的博客、个人网站，点这里。\n## 第三阶段：《JavaScript语言精粹》和《高性能JavaScript》\n接下来两本书《JavaScript语言精粹》和《高性能JavaScript》算是JS高级教程的补充，里面有一些内容和JS高级教程重复了，两本书可以同时看，都不厚，可以对前面所学的有一个很好的加强和巩固。\n## 第四阶段：《JavaScript DOM高级程序设计》和《JavaScript设计模式》\n在吃透了前面所说的书之后，接下来两本书的顺序已经无关紧要了，《JavaScript DOM高级程序设计》（注意和《JavaScript 高级程序设计》相区别）和《JavaScript设计模式》，这两本都是重量级的书，能让你的JS技术上一个新的台阶；这两本书前者主修炼外功，后者主修炼内功，有点想乾坤大挪移和九阳神功的关系。《JavaScript DOM高级程序设计》 首先教你搭建一个类似JQuery的额工具函数库，然后通过讲解几个实际中经常遇到的几个应用例子，会让初学者受益匪浅。《JavaScript设计模式》主要讲Javascript的设计模式，说实话，翻译的质量很一般，有些生硬，但已经基本不影响你的学习，看代码完全可以理解出自己的意思。\n# 最后想说的\n不安逸，不浮躁。任何学习都不是一蹴而就的，牛B就是一个学习积累的过程，别指望两三个月，你的水平就多么厉害。倚天屠龙记里面的武功最牛B的是张三丰，而不是张无忌。任何工作都需要多种技能，别忽略了html, css等其他知识的学习。\n\n>转自 (博客园)[http://kb.cnblogs.com/page/191787/]","slug":"如何学习javascript-转帖","published":1,"updated":"2016-01-27T02:42:52.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5exg0002703vwh5xz5cn"},{"title":"好好学学undefined！","date":"2016-01-29T01:48:56.000Z","comments":1,"_content":"# undefined类型\nundefined类型只有一个值，即特殊的undefined，我们称之为`字面值undefined`，undefined意为`未定义`。\n<!--more-->\n`字面值undefined`是全局Global对象（window）的一个特殊属性，其值是未定义的。但 typeof window.undefined 返回\"undefined\" 。\n\n我们可以通过下面的例子来验证undefined是否为全局Global对象（window）的属性:\n\n    alert('undefined' in window);//输出：true   \n    var anObj = {};   \n    alert('undefined' in anObj); //输出：false \n    从中可以看出，undefined是window对象的一个属性，但却不是anObj对象的一个属性。\n## `字面值undefined`的产生\n`字面值undefined`产生的原因有5种：\n\n    * 访问对象不存在的属性或方法\n    * 声明了变量但从未赋值\n    * 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n    * 方法没有返回值，默认返回undefined\n    * 访问越界的数组。\n    * void(expression) 形式的表达式。\n    \n    {% codeblock lang:JavaScript %}\n    var v1,obj = {};      \n      \n    console.log(v1); //`字面值undefined`    \n    console.log(obj.get); //`字面值undefined`\n    \n    typeof v1; // \"undefined\"    \n    typeof v2; // 对未声明的变量使用typeof 也会输出 \"undefined\"。     \n    typeof obj.get; // \"undefined\"\n    \n    var message1 = undefined;  //显示的设置为undefined\n    typeof message1 //\"undefined\"\n    \n    function test(){}; \n    console.log(test()); //`字面值undefined`\n    \n    var arr = []; \n    console.log(arr[8]) //`字面值undefined`\n    {% endcodeblock %}\n        \n<span style=\"color: red;\">当我们在程序中使用`字面值undefined`时，实际上使用的是window对象的undefined属性，同样，当我们定义一个变量但未赋予其初始值，例如：`var aValue;`这时，JavaScript在预编译时会将其初始值设置为对window.undefined属性的引用，于是，当我们将一个变量或值与undefined比较时，实际上是与window对象的undefined属性比较。这个比较过程中，JavaScript会搜索window对象名叫\"undefined\"的属性，然后再比较两个操作数的引用指针是否相同。</span>\n\n---\n您可以通过将变量与`字面值undefined`进行比较确定变量是否存在，您也可以通过将变量的类型与字符串“undefined”进行比较确定其类型是否为 undefined类型。\n以下示例演示了如何确定已声明的变量的 x：\n        \n    var x;\n    \n    // This method works.\n    if (x == undefined) { //这种方式只能对已经声明的变量使用，对未声明的变量使用会报错。\n        document.write(\"comparing x to undefined <br/>\");\n    }\n    \n    // This method doesn't work - you must check for the string \"undefined\".\n    if (typeof(x) == undefined) {//未执行，因为typeof 方法返回的是字符串。\n        document.write(\"comparing the type of x to undefined <br/>\");\n    }\n    // This method does work. \n    if (typeof(x) == \"undefined\") {\n        document.write(\"comparing the type of x to the string 'undefined'\");\n    }\n    \n    // Output: \n    // comparing x to undefined \n    // comparing the type of x to the string 'undefined'\n## 提高访问`字面值undefined`的性能：\n由于window对象的属性值是非常多的，在每一次与`字面值undefined`的比较中，搜索window对象的undefined属性都会花费时间。在需要频繁与undefined进行比较的函数中，这可能会是一个性能问题点。因此，在这种情况下，我们可以自行定义一个局部的undefined变量，来加快对undefined的比较速度。例如：\n\n    function anyFunc() {\n        var undefined; //自定义局部undefined变量\n        if (x == undefined){} //作用域上的引用比较\n        while (y != undefined){} //作用域上的引用比较\n    };\n其中，定义undefined局部变量时，其初始值会是对window.undefined属性值的引用。新定义的局部undefined变量存在与该函数的作用域上。\n在随后的比较操作中，JavaScript代码的书写方式没有任何的改变，但比较速度却很快。因为作用域上的变量数量会远远少于window对象的属性，搜索变量的速度会极大提高。\n这就是许多前端JS框架为什么常常要自己定义一个局部undefined变量的原因!!!\n比如jQuery 源码：\n\n    (function( window, undefined ) {\n        /*\n        * \n        * code\n        * \n        * */\n    })( window );\n    ","source":"_posts/好好学学undefined！-2016-01-29.md","raw":"title: 好好学学undefined！\ndate: 2016-01-29 09:48:56\ntags:\n- jQuery\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# undefined类型\nundefined类型只有一个值，即特殊的undefined，我们称之为`字面值undefined`，undefined意为`未定义`。\n<!--more-->\n`字面值undefined`是全局Global对象（window）的一个特殊属性，其值是未定义的。但 typeof window.undefined 返回\"undefined\" 。\n\n我们可以通过下面的例子来验证undefined是否为全局Global对象（window）的属性:\n\n    alert('undefined' in window);//输出：true   \n    var anObj = {};   \n    alert('undefined' in anObj); //输出：false \n    从中可以看出，undefined是window对象的一个属性，但却不是anObj对象的一个属性。\n## `字面值undefined`的产生\n`字面值undefined`产生的原因有5种：\n\n    * 访问对象不存在的属性或方法\n    * 声明了变量但从未赋值\n    * 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n    * 方法没有返回值，默认返回undefined\n    * 访问越界的数组。\n    * void(expression) 形式的表达式。\n    \n    {% codeblock lang:JavaScript %}\n    var v1,obj = {};      \n      \n    console.log(v1); //`字面值undefined`    \n    console.log(obj.get); //`字面值undefined`\n    \n    typeof v1; // \"undefined\"    \n    typeof v2; // 对未声明的变量使用typeof 也会输出 \"undefined\"。     \n    typeof obj.get; // \"undefined\"\n    \n    var message1 = undefined;  //显示的设置为undefined\n    typeof message1 //\"undefined\"\n    \n    function test(){}; \n    console.log(test()); //`字面值undefined`\n    \n    var arr = []; \n    console.log(arr[8]) //`字面值undefined`\n    {% endcodeblock %}\n        \n<span style=\"color: red;\">当我们在程序中使用`字面值undefined`时，实际上使用的是window对象的undefined属性，同样，当我们定义一个变量但未赋予其初始值，例如：`var aValue;`这时，JavaScript在预编译时会将其初始值设置为对window.undefined属性的引用，于是，当我们将一个变量或值与undefined比较时，实际上是与window对象的undefined属性比较。这个比较过程中，JavaScript会搜索window对象名叫\"undefined\"的属性，然后再比较两个操作数的引用指针是否相同。</span>\n\n---\n您可以通过将变量与`字面值undefined`进行比较确定变量是否存在，您也可以通过将变量的类型与字符串“undefined”进行比较确定其类型是否为 undefined类型。\n以下示例演示了如何确定已声明的变量的 x：\n        \n    var x;\n    \n    // This method works.\n    if (x == undefined) { //这种方式只能对已经声明的变量使用，对未声明的变量使用会报错。\n        document.write(\"comparing x to undefined <br/>\");\n    }\n    \n    // This method doesn't work - you must check for the string \"undefined\".\n    if (typeof(x) == undefined) {//未执行，因为typeof 方法返回的是字符串。\n        document.write(\"comparing the type of x to undefined <br/>\");\n    }\n    // This method does work. \n    if (typeof(x) == \"undefined\") {\n        document.write(\"comparing the type of x to the string 'undefined'\");\n    }\n    \n    // Output: \n    // comparing x to undefined \n    // comparing the type of x to the string 'undefined'\n## 提高访问`字面值undefined`的性能：\n由于window对象的属性值是非常多的，在每一次与`字面值undefined`的比较中，搜索window对象的undefined属性都会花费时间。在需要频繁与undefined进行比较的函数中，这可能会是一个性能问题点。因此，在这种情况下，我们可以自行定义一个局部的undefined变量，来加快对undefined的比较速度。例如：\n\n    function anyFunc() {\n        var undefined; //自定义局部undefined变量\n        if (x == undefined){} //作用域上的引用比较\n        while (y != undefined){} //作用域上的引用比较\n    };\n其中，定义undefined局部变量时，其初始值会是对window.undefined属性值的引用。新定义的局部undefined变量存在与该函数的作用域上。\n在随后的比较操作中，JavaScript代码的书写方式没有任何的改变，但比较速度却很快。因为作用域上的变量数量会远远少于window对象的属性，搜索变量的速度会极大提高。\n这就是许多前端JS框架为什么常常要自己定义一个局部undefined变量的原因!!!\n比如jQuery 源码：\n\n    (function( window, undefined ) {\n        /*\n        * \n        * code\n        * \n        * */\n    })( window );\n    ","slug":"好好学学undefined！","published":1,"updated":"2016-02-02T05:56:57.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5exr0007703vfobfeacl"},{"title":"好好学学number!","date":"2016-01-29T01:55:43.000Z","comments":1,"_content":"# Number类型\n\nJavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相等的，而且1加上1.0得到的还是一个整数，不会像有些语言那样变成小数。\n<!--more-->\n```javascript\n1 === 1.0 // true\n1 + 1.0 // 2\n```\n也就是说，在JavaScript语言的底层，根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算。\n\n由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n```javascript    \n0.1 + 0.2 === 0.3  // false\n\n0.3 / 0.1          // 2.9999999999999996\n\n(0.3 - 0.2) === (0.2 - 0.1)    // false\n```\n{% asset_img number2.png %}\n\n解释：根据国际标准IEEE-754，64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分（共52位），第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数。\n\n```javascript\nMath.pow(2, 53)        // 9007199254740992\n\nMath.pow(2, 53) + 1    // 9007199254740992\n\nMath.pow(2, 53) + 2    // 9007199254740994\n\nMath.pow(2, 53) + 3    // 9007199254740996\n\nMath.pow(2, 53) + 4    // 9007199254740996\n```\n    \n从上面示例可以看到，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于等于2的53次方的数值，都无法保持精度。因此，JavaScript提供的有效数字的精度为53个二进制位（IEEE 754规定有效数字第一位默认总是为1，不保存在64位浮点数之中，这一位再加上后面的52位，就是总共53位），也就是说，绝对值小于2的53次方的整数，即-(2<sup>53</sup>-1)到2<sup>53</sup>-1，都可以精确表示。\n    \n那么超过2<sup>53</sup>部分的数字怎么处理呢？\n\n```javascript\nMath.pow(2, 53)    // 9007199254740992\n\n9007199254740992111    // 9007199254740992000    \n```\n上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的`111`）都会无法保存，变成0。\n\n另一方面，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。\n\n如果指数部分等于或超过最大正值1024，JavaScript会返回`Infinity`（关于Infinity的介绍参见下文），这称为“正向溢出”；如果等于或超过最小负值-1023（即非常接近0），JavaScript会直接把这个数转为0，这称为“负向溢出”。事实上，JavaScript对指数部分的两个极端值（`11111111111`(二进制)和`00000000000`(二进制)）做了定义，`11111111111`(二进制)表示`NaN`和`Infinity`，`00000000000`(二进制)表示0。\n    \n```javascript\n    var x = 0.5;\n    \n    for(var i = 0; i < 25; i++) {\n      x = x * x;\n    }\n    console.log(x);// 0\n```\n上面代码对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript就直接将其转为0。\n\n>* 精确地描述，Number类型拥有 18437736874454810627（即，2<sup>64</sup>-2<sup>53</sup>+3）个值，表示为 IEEE-754 格式 64 位双精度数值（IEEE 二进制浮点数算术中描述了它）。\n>* <span style=\"color: red;\">除了 IEEE 标准中的 9007199254740990（即，2<sup>53</sup>-2）个明显的“非数字”值；在 ECMAScript 中，它们被表示为一个单独的特殊值：NaN。</span>（请注意，NaN 值由程序表达式 NaN 产生，并假设执行程序不能调整定义的全局变量 NaN，在javascript中NaN是global全局对象的一个属性`window.NaN`） 在某些实现中，外部代码也许有能力探测出众多非数字值之间的不同，但此类行为依赖于具体实现；对于 ECMAScript 代码而言，NaN 值相互之间无法区别。\n>* 还有另外两个特殊值，称为正无穷和负无穷。为简洁起见，在说明目的时，用符号 +∞ 和 -∞ 分别代表它们。（请注意，两个无限数值由程序表达式 +Infinity（简作 Infinity） 和 -Infinity 产生，并假设执行程序不能调整定义的全局变量 Infinity，在javascript中global全局对象的一个Infinity属性`window.Infinity`）。\n>* 另外 18437736874454810624（即，2<sup>64</sup>-2<sup>53</sup>）个值被称为有限数值，其中的一半是正数，另一半是负数，对于每个正数而言，都有一个与之对应的、相同规模的负数。\n>* 请注意，还有一个正零和一个负零。\n>* [查看number类型数值的二进制](http://alvarto.github.io/VisualNumeric64/)\n\n数轴：\n\n{% asset_img number.png [200] [400] %}\n\n    \n> 对于这个如果有兴趣细扣就[点这里](http://www.cnblogs.com/kingwolfofsky/archive/2011/07/21/2112299.html)，[还有这里](https://www.w3.org/html/ig/zh/wiki/ES5/types#Number_.E7.B1.BB.E5.9E.8B)\n\n## 整数\n\n整数可以被表示成十进制（基数为10）、十六进制（基数为16）以及八进制（基数为8）。\n\n* 十进制：十进制整数字组成的数字序列，不带前导0（零）。\n* 八进制：八进制整数只能包括数字0-7，通过在八进制整数前面加前导`0`（零）或者或`0o`的数值来表示八进制整数。八进制整数只包含 0 到 7 的数字。<span style=\"color:red;\">具有前导`0`并包含数字“8”和/或“9”的数字将被解释为十进制数字</span>，具有前导`0o`并包含数字“8”和/或“9”的数字将会报错。\n* 十六进制：通过在整数前面加前导“0x”（零和 x|X）来表示十六进制（“hex”）整数。字母 A 到 F 以单个数字的形式表示以 10 为基数的 10 到 15。字母 A 到 F 用于以单个数字的形式表示以 10 为基数的 10 到 15。即，0xF 相当于 15，0x10 相当于 16。\n* 二进制：有前缀`0b`或`0B`的数值。\n\n在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值，还有严格模式下禁止使用八进制。\n    \n```javascript\n    //默认情况下，JavaScript内部会自动将八进制、十六进制、二进制转为十进制。    \n    0xff   // 255\n    -0xF1A7// -61863\n    0o377  // 255\n    015    // 13\n    019    // 19\n    0b11   // 3\n    \n    //如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。\n    0xzz // 报错\n    0o88 // 报错\n    0b22 // 报错\n```\n\n<span style=\"color:#555;\">IEBUG：从 Internet Explorer 9 标准模式、Internet Explorer 10 标准模式、Internet Explorer 11 标准模式和 Windows 应用商店应用 开始，parseInt 函数不将前缀为“0”的字符串视为八进制。但在不使用 parseInt 函数时，前缀为“0”的字符串仍可被解释为八进制。</span>\n\n## 浮点值\n\n* 一个十进制整数，它可以带符号（即前面的“+”或“ - ”号），\n* 一个小数点（“.”），\n* 一个小数部分（由一串十进制数表示），\n* 一个指数部分\n指数部分是以“e”或“E”开头后面跟着一个整数，可以有正负号（即前面写“+”或“-”）。一个浮点数字面值必须至少有一位数字，后接小数点或者“e”（大写“E”也可）组成。一些浮点数字面值的例子，如3.1415，-3.1E13，.1e12以及2E-12。\n简言之，其语法是：\n\n    [digits][.digits][(E|e)[(+|-)]digits]\n    //实例:\n    3.14\n    2345.789\n    .3333333333333333333 // 0 可以省略\n\n以下两种情况，JavaScript会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。\n\n* 小数点前的数字多于21位\n```javascript\n    console.log(1234567890123456789012)    // 1.2345678901234568e+21\n```\n* 小数点后的零多于5个\n```javascript\n    console.log(0.0000003) //3e-7\n```\n\n## NaN\n\nNaN(not a number)用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。由上面的表中可以看出，对于单精度浮点数，NaN 表示为指数为 emax + 1 = 128（指数域全为 1），且尾数域不等于零的浮点数。IEEE 标准没有要求具体的尾数域，所以 <span style=\"red;\">NaN 实际上不是一个，而是一族</span>，它是全局对象global对象的一个属性(`window.NaN`)。\n需要注意的是，NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。\n\n```javascript\n    console.log(typeof NaN) // 'number\n```\n### 特性：\n* NaN不等于任何值，包括它本身。`NaN === NaN // false`\n* 由于数组的indexOf方法，内部使用的是严格相等运算符，所以该方法对NaN不成立。`NaN].indexOf(NaN) // -1`\n* NaN在布尔运算时被当作false。`Boolean(NaN) // false`\n* NaN与任何数（包括它自己）的运算，得到的都是NaN。\n\n```javascript\n    NaN + 32 // NaN\n    NaN - 32 // NaN\n    NaN * 32 // NaN\n    NaN / 32 // NaN\n```\n    \n### 判断NaN的方法 isNaN\n\n```javascript\n    isNaN(NaN) // true\n    isNaN(123) // false\n```\n    \n但是，`isNaN`只对数值有效，<span style=\"color:red;\">如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成`NaN`，所以最后返回`true`</span>，这一点要特别引起注意。也就是说，`isNaN`为`true`的值，有可能不是`NaN`，而是一个字符串。出于同样的原因，对于对象和数组，`isNaN`也返回`true`。\n\n```javascript\n    isNaN('Hello') // true\n    // 等同于\n    isNaN(Number('Hello')) // true\n\n    isNaN({}) // true\n    // 等同于\n    isNaN(Number({})) // true\n\n    isNaN(['xzy']) // true\n    // 等同于\n    isNaN(Number(['xzy'])) // true\n```\n\n但是，对于空数组和只有一个数值成员的数组，`isNaN`返回`false`。\n\n```javascript\n    isNaN([]) // false\n    isNaN([123]) // false\n    isNaN(['123']) // false\n```\n \n上面的代码之所以返回`false`，原因是这些数组能被`Number`函数转成数值，请参见《数据类型转换》一节。\n\n因此，使用`isNaN`之前，最好判断一下数据类型。\n\n```javascript\n    function myIsNaN(value) {\n    return typeof value === 'number' && isNaN(value);\n    }\n    判断NaN更可靠的方法是，利用`NaN`是JavaScript之中唯一不等于自身的值这个特点，进行判断。\n\n    function myIsNaN(value) {\n    return value !== value;\n    }\n```\n    \n## +0 和 -0\n\n先看一道题： 假如 A === B 并且 1/A < 1/B; 请问 A 等于 几？\n\n### 产生原因\n数字需要被编码才能进行数字化存储.举个例子,假如我们要将一个整数编码为4位的二进制数,使用原码(sign-and-magnitude)方法,则最高位是符号位(0代表正,1代表负),剩下的三位表示大小(具体的值).因此,−2和+2会编码成为下面这样:\n\n    1010 // +2\n    0010 // -2\n    这就意味着将会有两个零:\n    1000 // -0\n    0000 // +0\n在JavaScript中,所有的数字都是浮点数,都是根据IEEE-754标准中的浮点数算法以双精度格式被编码。这个标准中正负号的处理方式类似于原码(sign-and-magnitude)方法中整数的编码方式,所以也有正负零。\n\n### 参与运算\n```javascript\n+0 === -0 //true 虽然有正0和负0但是他们两个是相等\n-0 < +0   //false  \n+0 < -0   //false\n\n-0 + -0  // -0\n-0 + +0  // +0\n+0 X -5  // -0\n-0 X -5  // +0\n1 / +0  // Infinity\n1 / -0  // -Infinity\n+0 / -0  // NaN\n```\n    \n### 参与Math对象的方法\n\n* Math.pow(x,y)方法可返回从  之间的角度。\n    \n```javascript\nMath.pow(+0, -1) // Infinity\nMath.pow(-0, -1) // -Infinity\n```\n    \n* Math.atan2(x,y)方法可返回从 x<sup>y</sup> 的值。\n        \n```javascript\nx = 0 , y <= -0     // π(3.141592653589793)\nMath.atan2(+0, -0)  // π(3.141592653589793)\n\nx = 0 , y >= 0      // 0\nMath.atan2(+0, +0)  // 0\n\nx = -0 , y >= +0    // -0\nMath.atan2(-0, +0)  // -0\n\nx = -0 , y <= -0    // -π(-3.141592653589793)\nMath.atan2(-0, -0)  // -π(-3.141592653589793)\n```\n    \n* Math.round()是另外一个参数不为零却产生-0结果的操作:\n```javascript\nMath.round(-0.1) // -0\n```\n\n### 区分这两个零\n\n方法1: 判断一个零是正还是负的标准解法是用它除1，然后看计算的结果是-Infinity还是+Infinity\n        \n```javascript\nfunction isNegativeZero(x) {\n    return x === 0 && (1/x < 0);\n}\n```\n\n方法2: 除了上面讲的几种解法.还有一个解法来自Allen Wirfs-Brock(译者注:TC39编辑,ES标准就是他写出来的。):\n        \n```javascript\nfunction isNegativeZero(x) {\n    if (x !== 0) return false;\n    var obj = {};\n    Object.defineProperty(obj, 'z', { value: -0, configurable: false });\n    try {\n        // 如果x的值和z属性的当前值不相等的话,就会抛出异常.\n        Object.defineProperty(obj, 'z', { value: x });\n    } catch (e) {\n        return false\n    };\n    return true;\n}\n```\n        \n解释: 通常情况下,你不能重新定义一个不可配置的对象属性，否则会抛出异常:`TypeError: Cannot redefine property: z`可是，如果你重新定义属性时指定的属性特性的值与该特性当前的值相等，则JavaScript会忽略掉这个重定义，不会抛出异常。其中在判断两个值是否相等时使用的运算不是===，是一个称之为SameValue的内部算法，该算法可以区分开 -0 和 +0 。可以从Wirfs-Brock的原文中了解更多细。(冻结一个对象会让该对象的所有属性变的不可配置)。\n\n> 在执行一些特殊方法的时候，比如alert或innerHTML等方法，它将由脚本解析器自动调用toString()方法。\n\n看完上面这些，那么这节开头的题目的结果自然而然就知道喽。\n\n## Infinity\nInfinity 表示“无穷”，挂在global对象下的Infinity属性上(window.Infinity)。除了0除以0得到NaN，其他任意数除以0，得到Infinity。获得方式\n\n```javascript\nNumber.NEGATIVE_INFINITY // +infinity\nNumber.POSITIVE_INFINITY // -infinity\n\nwindow.Infinity === Number.POSITIVE_INFINITY // ture\n```\n\n```javascript\n1 / -0 // -Infinity\n1 / +0 // Infinity\n```\n    \n### 正负之分\n和+0\\-0 不同，`Infinity` 不等于 `-Infinity`。\n\n```javascript\nInfinity === -Infinity // false\n```\n### 产生原因\n\n```javascript\nMath.pow(+0, -1) // Infinity\nMath.pow(-0, -1) // -Infinity\n\n//运算结果超出JavaScript可接受范围，也会返回无穷。\nMath.pow(2, 2048) // Infinity\n-Math.pow(2, 2048) // -Infinity\n```\n\n### 参与运算\n\nInfinity的四则运算，符合无穷的数学计算规则。\n\n```javascript\n5 * Infinity // Infinity\n5 - Infinity // -Infinity\nInfinity / 5 // Infinity\n5 / Infinity // 0\n```\n\n```javascript\nInfinity - Infinity // NaN\nInfinity / Infinity // NaN\n\nInfinity + Infinity // Infinity\nInfinity * Infinity // Infinity\n```\n    \nnfinity可以用于布尔运算。可以记住，Infinity是JavaScript中最大的值（NaN除外），-Infinity是最小的值（NaN除外）。\n\n```javascript    \n5 > -Infinity // true\n5 > Infinity // false\n```\n\n由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript都不报错，所以单纯的数学运算几乎没有可能抛出错误。\n\n### isFinite函数\nisFinite函数返回一个布尔值，检查某个值是否为正常值，而不是Infinity。\n\n```javascript\nisFinite(Infinity) // false\nisFinite(-1) // true\nisFinite(true) // true\nisFinite(NaN) // false //如果对NaN使用isFinite函数，也返回false，表示NaN不是一个正常值\n```\n\n# 数值转换\n\n## Number()\n\n使用Number函数，可以将任意类型的值(<span style=\"color:red;\">parseInt和parseFloat只能转换字符串和数值类型</span>)转化成数字。\n\n* **简单类型转换规则**\n\n    - 数值：转换为十进制(因为默认调用toString()，会以十进制输出)。\n        ```javascript\n        Number(10);     // 10 \n        Number(010);    // 8\n        Number(090);    // 90 因为八进制中没有9，所以按照十进制处理 \n        Number(0x16);   // 22 \n        \n        Number(0o10);   //  在chrome和firefox为8，IE报错 `缺少 “)”` \n        Number(0b1000); //  在chrome和firefox为8，IE报错 `缺少 “)”` \n        ```\n\n    - 字符串：先去掉字符串前后的空格，如果可以被解析为数值，则转换为相应的数值，否则得到NaN。**空字符串`\"\"`转为0**。\n        - 如果字符串是`Number(\"0o17\")`和`Number(\"0b10000\")`（包括前面带正号或负号的情况）在chrome和firefox会按照八进制转换为十进制 16，但是IE不会生产`NaN`，十六进制没问题chrome和firefox、IE没问题。\n        - 如果字符串中包含有效的浮点格式，如\"1.1\"，则将其转换为对应的浮点数值（同样，也会忽略前导零）。\n        \n    - 布尔值：`true`转成 1，`false` 转成 0。\n\n    - `undefined`：转成`NaN`。\n\n    - `null`：转成0。\n\n    ```javascript\n    Number(\"324\") // 324\n    Number(\" -9.8 \") // -9.8\n    \n    Number(\"010\") // 10 和parseInt(\"010\")为不同\n    Number(\"0o17\")//  在chrome和firefox为16。IE为NaN。 \n    Number(\"0b10000\") // 在chrome和firefox为16。IE为NaN。 \n    Number(\"0x10\") // 在chrome和firefox为16。IE也为16。\n    \n    Number(\"324abc\") // NaN\n\n    Number(\"\") // 0\n\n    Number(false) // 0\n\n    Number(undefined) // NaN\n\n    Number(null) // 0\n    ```\n* **对象的转换规则**\n    对象的转换规则比较复杂。\n    1. 先调用对象自身的`valueOf`方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用`Number`方法，不再进行后续步骤。\n    2. 如果`valueOf`方法返回复合类型的值，再调用对象自身的`toString`方法，如果`toString`方法返回原始类型的值，则对该值使用`Number`方法，不再进行后续步骤。\n    3. 如果`toString`方法返回的是复合类型的值，则报错。\n    \n    ```javascript\n    Number({a:1,valueOf:function(){return \"5\"}}); //5  先调用对象自身的`valueOf`方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用`Number`方法，不再进行后续步骤。\n    Number({a:1,valueOf:function(){return {b:5}},toString:function(){return 4}}); //4  如果`valueOf`方法返回复合类型的值，再调用对象自身的`toString`方法，如果`toString`方法返回原始类型的值，则对该值使用`Number`方法，不再进行后续步骤。\n    Number({a:1,valueOf:function(){return {b:5}},toString:function(){return {}}}); //TypeError: Cannot convert object to primitive value 如果`toString`方法返回的是复合类型的值，则报错。\n    ```\n## parseInt()\n* 基本用法    \n    `parseInt()`方法可以将字符串转化为整数。如果字符串头部有空格，空格会被自动去除。\n    ```javascript\n        parseInt('8a') // 8\n        parseInt(\" -12 ba\") //-12\n        \n        //十六进制\n        parseInt('0xf00') // 3840 开头两个字符是`0x`或`0X`，`parseInt`将其视为十六进制数\n        //八进制\n        parseInt('056') // 56\n        parseInt('0o56') // 0\n        parseInt('0O56') // 0\n        //二进制\n        parseInt(\"0B10\") // 0\n    ```\n    上面代码中，`parseInt`的参数都是字符串，结果只返回字符串头部可以转为数字的部分。最后一行的`0xf00`之所以可以转为数字，因为如果开头两个字符是`0x`或`0X`，`parseInt`将其视为十六进制数，但是八进制和二进制确默认视为普通字符串。\n    如果字符串的第一个`非空格字符`不能转化为数字（数字的正负号除外），返回`NaN`。\n    \n    ```javascript\n    parseInt('abc') // NaN\n    parseInt('.3') // NaN\n    parseInt('') // NaN 不同于Number()\n    parseInt(null) // NaN 不同于Number()\n    parseInt('+') // NaN\n    ```\n* 进制转换\n`parseInt()`方法还可以接受第二个参数（2到36之间，超出区间(`包括负数但0除外`)返回`NaN`），表示被解析的值的进制，返回该值对应的十进制数。\n如果第二个参数不是数值，会被自动转为（调用`Number()`）一个整数，这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回`NaN`，如果转换的结果为`0，NaN`，都会直接忽略返回原值。\n如果第二个参数是`0`、`undefined`和`null`等等一些不能转为正常整数的值，则直接忽略。\n\n    ```javascript\n        parseInt(1000, 2) // 8\n        parseInt(1000, 6) // 216\n        parseInt(1000, 8) // 512\n        //特殊情况\n        parseInt(1000, \"8\") // 512 把\"8\"自动转为8\n        parseInt(1000, \" +8 \") // 512 会自动去掉前置和后置空格\n        parseInt(1000, \" -8 \") // NaN 负数超出范围\n        parseInt(1000, 1) // NaN 超出范围\n        parseInt(1000, 37) // NaN 超出范围\n        parseInt(1000, \"8aa\") // 1000 因为Number(\"8aa\")等于NaN\n        parseInt(1000, 0) // 1000  直接忽略返回原值\n        parseInt(1000, NaN) // 1000\n        parseInt(1000, null) // 1000 因为Number(NaN)等于0\n        parseInt(1000, undefined) // 1000 因为Number(undefined)等于NaN\n        parseInt(\"1000\", {\n            a:1,\n            valueOf:function(){\n                return 5;\n            }\n        }) //125  因为Number({a:1,valueOf:function(){return 5;}}) 返回5 所以\n    ```\n\n* 特别注意\n需要注意的是，进制转换的时候，参数是字符串或数值，`parseInt`的行为不一致。\n1. 如果第一个参数是数值，会将这个数值先转为十进制，然后再应用第二个参数。\n\n    ```javascript\n    parseInt(0x11, 36) // 43\n    parseInt(17, 36) // 43\n    ```\n    上面代码中，`0x11`会被先转为十进制的17，然后再用36进制解读这个17，最后返回结果43。\n\n2. 如果第一个参数是字符串，则会直接用指定进制解读这个字符串。\n    \n    ```javascript\n    parseInt('0x11', 36) // 42805\n    parseInt('x', 36) // 33\n    ```\n\n    上面代码中，字符串`0x11`会被直接当作一个36进制的数。由于字符`x`在36进制中代表33，导致`0x11`被解读为42805。\n\n    ```javascript\n    parseInt(010, 10) // 8\n    parseInt('010', 10) // 10\n\n    parseInt(010, 2) // NaN 因为`010数值`转换为十进制是8，而8在二进制是不存在的所以返回`NaN`\n    parseInt('010', 2) // 2\n\n    parseInt(010, 8) // NaN 因为`010数值`转换为十进制是8，而8在八进制是不存在的所以返回`NaN`\n    parseInt('010', 8) // 8\n\n    parseInt(020, 10) // 16\n    parseInt('020', 10) // 20\n\n    parseInt(020, 8) // 14 因为`020数值`转换为十进制是16，再转换为8进制刚好14\n    parseInt('020', 8) // 16 因为`020字符串`转换为十进制是20，再转换为8进制刚好16\n    ```\n\n    上面代码中，`010`会被先转为十进制8，然后再应用第二个参数，由于二进制和八进制中没有8这个数字，所以`parseInt(010, 2)`和`parseInt(010, 8)`返回`NaN`。同理，数值`020`会被先转为十进制的16，然后再应用第二个参数。\n    > `parseInt`的很多复杂行为，都是由八进制的前缀0引发的，这增加编程处理的复杂性。因此，ECMAScript 5不再允许parseInt将带有前缀0的数字，视为八进制数，而是要求忽略这个`0`。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。\n\n3. 如果第一个参数是以`0x`或`0X`开头的字符串，而第二个参数省略或为0，则`parseInt`自动将第二个参数设为16。\n    ```javascript\n        parseInt('0xFF') // 255\n        parseInt('0xFF', 0) // 255\n        parseInt('0xFF', 16) // 255\n        \n        parseInt('0xFF', 10) // 0\n        parseInt('0xFF', 17) // 0\n    ```\n    上面代码中，第二个参数除了0、16和省略，其他情况都会依次解析第一个参数，直到遇到第一个不可解析字符。\n\n4. 科学计数法产生的扯淡问题\n    对于那些会自动转为科学计数法的数字，`parseInt`会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。\n    \n    ```javascript\n    parseInt(1000000000000000000000.5, 10) // 1\n    // 等同于\n    parseInt('1e+21', 10) // 1\n\n    parseInt(0.0000008, 10) // 8\n    // 等同于\n    parseInt('8e-7', 10) // 8\n    ```\n\n## parseFloat()\n* 基本用法\n    parseFloat`方法用于将一个字符串转为浮点数。    \n    ```javascript\n    parseFloat(\"3.14\") // 3.14\n    ```\n\n1. 如果字符串符合科学计数法，则会进行相应的转换。\n    \n    ```javascript\n    parseFloat('314e-2') // 3.14\n    parseFloat('0.0314E+2') // 3.14\n    ```\n2. 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。\n    ```javascript\n    parseFloat('3.14more non-digit characters') // 3.14\n    ```\n    `parseFloat`方法会自动过滤字符串前导的空格。\n    ```javascript\n    parseFloat('\\t\\v\\r12.34\\n ') // 12.34\n    ```\n\n3. 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回`NaN`。\n    ```javascript\n    parseFloat([]) // NaN\n    parseFloat('FF2') // NaN\n\n    parseFloat(true)  // NaN 不同于`Number`函数\n    Number(true) // 1\n\n    parseFloat(null) // NaN 不同于`Number`函数\n    Number(null) // 0\n\n    parseFloat('') // NaN 不同于`Number`函数\n    Number('') // 0\n\n    parseFloat('123.45#') // 123.45  不同于`Number`函数\n    Number('123.45#') // NaN\n    ```\n** 特别注意：`parseInt()`和`parseFloat()`会先调用值的`toString()`方法，`Number()`是先调用`valueOf`，返回结果有问题再调用`toString`**\n```javascript\nparseInt({\na: 1,\ntoString: function(){\n            return \"11\"\n            }\n});\n\nparseFloat({\na: 1,\ntoString: function(){\n            return \"11\"\n            }\n});\n```\n上面这两种情况也会正确的返回`11`，看到这儿你会说“你不是说parseInt只能转换字符串”吗？其实真正的原因是，所有的转换第一步都是调用`toString()`方法。\n\n```javascript\nNumber.prototype.toString = function(){\n    console.log(\"我被调用了\")\n    return 123123;\n}\nNumber.prototype.valueOf = function(){\n    console.log(\"我被调用了-valueOf\")\n    return 123123;\n}\n\nvar a  = new Number(12);\n\n\nparseInt(a) // 我被调用了 123123\nNumber(a) // 我被调用了-valueOf 123123\n```\n上面这段code 足以证明**特别注意**。\n详见：[Ex igne vita](http://es5.github.io/#x15.1.2.2)\n\n** 引用：**\n\n> [紫云飞](http://www.cnblogs.com/ziyunfei/archive/2012/12/10/2777099.html)\n> [阮一峰](http://javascript.ruanyifeng.com/)","source":"_posts/好好学学number-2016-01-29.md","raw":"title: '好好学学number!'\ndate: 2016-01-29 09:55:43\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# Number类型\n\nJavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相等的，而且1加上1.0得到的还是一个整数，不会像有些语言那样变成小数。\n<!--more-->\n```javascript\n1 === 1.0 // true\n1 + 1.0 // 2\n```\n也就是说，在JavaScript语言的底层，根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算。\n\n由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n```javascript    \n0.1 + 0.2 === 0.3  // false\n\n0.3 / 0.1          // 2.9999999999999996\n\n(0.3 - 0.2) === (0.2 - 0.1)    // false\n```\n{% asset_img number2.png %}\n\n解释：根据国际标准IEEE-754，64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分（共52位），第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数。\n\n```javascript\nMath.pow(2, 53)        // 9007199254740992\n\nMath.pow(2, 53) + 1    // 9007199254740992\n\nMath.pow(2, 53) + 2    // 9007199254740994\n\nMath.pow(2, 53) + 3    // 9007199254740996\n\nMath.pow(2, 53) + 4    // 9007199254740996\n```\n    \n从上面示例可以看到，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于等于2的53次方的数值，都无法保持精度。因此，JavaScript提供的有效数字的精度为53个二进制位（IEEE 754规定有效数字第一位默认总是为1，不保存在64位浮点数之中，这一位再加上后面的52位，就是总共53位），也就是说，绝对值小于2的53次方的整数，即-(2<sup>53</sup>-1)到2<sup>53</sup>-1，都可以精确表示。\n    \n那么超过2<sup>53</sup>部分的数字怎么处理呢？\n\n```javascript\nMath.pow(2, 53)    // 9007199254740992\n\n9007199254740992111    // 9007199254740992000    \n```\n上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的`111`）都会无法保存，变成0。\n\n另一方面，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。\n\n如果指数部分等于或超过最大正值1024，JavaScript会返回`Infinity`（关于Infinity的介绍参见下文），这称为“正向溢出”；如果等于或超过最小负值-1023（即非常接近0），JavaScript会直接把这个数转为0，这称为“负向溢出”。事实上，JavaScript对指数部分的两个极端值（`11111111111`(二进制)和`00000000000`(二进制)）做了定义，`11111111111`(二进制)表示`NaN`和`Infinity`，`00000000000`(二进制)表示0。\n    \n```javascript\n    var x = 0.5;\n    \n    for(var i = 0; i < 25; i++) {\n      x = x * x;\n    }\n    console.log(x);// 0\n```\n上面代码对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript就直接将其转为0。\n\n>* 精确地描述，Number类型拥有 18437736874454810627（即，2<sup>64</sup>-2<sup>53</sup>+3）个值，表示为 IEEE-754 格式 64 位双精度数值（IEEE 二进制浮点数算术中描述了它）。\n>* <span style=\"color: red;\">除了 IEEE 标准中的 9007199254740990（即，2<sup>53</sup>-2）个明显的“非数字”值；在 ECMAScript 中，它们被表示为一个单独的特殊值：NaN。</span>（请注意，NaN 值由程序表达式 NaN 产生，并假设执行程序不能调整定义的全局变量 NaN，在javascript中NaN是global全局对象的一个属性`window.NaN`） 在某些实现中，外部代码也许有能力探测出众多非数字值之间的不同，但此类行为依赖于具体实现；对于 ECMAScript 代码而言，NaN 值相互之间无法区别。\n>* 还有另外两个特殊值，称为正无穷和负无穷。为简洁起见，在说明目的时，用符号 +∞ 和 -∞ 分别代表它们。（请注意，两个无限数值由程序表达式 +Infinity（简作 Infinity） 和 -Infinity 产生，并假设执行程序不能调整定义的全局变量 Infinity，在javascript中global全局对象的一个Infinity属性`window.Infinity`）。\n>* 另外 18437736874454810624（即，2<sup>64</sup>-2<sup>53</sup>）个值被称为有限数值，其中的一半是正数，另一半是负数，对于每个正数而言，都有一个与之对应的、相同规模的负数。\n>* 请注意，还有一个正零和一个负零。\n>* [查看number类型数值的二进制](http://alvarto.github.io/VisualNumeric64/)\n\n数轴：\n\n{% asset_img number.png [200] [400] %}\n\n    \n> 对于这个如果有兴趣细扣就[点这里](http://www.cnblogs.com/kingwolfofsky/archive/2011/07/21/2112299.html)，[还有这里](https://www.w3.org/html/ig/zh/wiki/ES5/types#Number_.E7.B1.BB.E5.9E.8B)\n\n## 整数\n\n整数可以被表示成十进制（基数为10）、十六进制（基数为16）以及八进制（基数为8）。\n\n* 十进制：十进制整数字组成的数字序列，不带前导0（零）。\n* 八进制：八进制整数只能包括数字0-7，通过在八进制整数前面加前导`0`（零）或者或`0o`的数值来表示八进制整数。八进制整数只包含 0 到 7 的数字。<span style=\"color:red;\">具有前导`0`并包含数字“8”和/或“9”的数字将被解释为十进制数字</span>，具有前导`0o`并包含数字“8”和/或“9”的数字将会报错。\n* 十六进制：通过在整数前面加前导“0x”（零和 x|X）来表示十六进制（“hex”）整数。字母 A 到 F 以单个数字的形式表示以 10 为基数的 10 到 15。字母 A 到 F 用于以单个数字的形式表示以 10 为基数的 10 到 15。即，0xF 相当于 15，0x10 相当于 16。\n* 二进制：有前缀`0b`或`0B`的数值。\n\n在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值，还有严格模式下禁止使用八进制。\n    \n```javascript\n    //默认情况下，JavaScript内部会自动将八进制、十六进制、二进制转为十进制。    \n    0xff   // 255\n    -0xF1A7// -61863\n    0o377  // 255\n    015    // 13\n    019    // 19\n    0b11   // 3\n    \n    //如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。\n    0xzz // 报错\n    0o88 // 报错\n    0b22 // 报错\n```\n\n<span style=\"color:#555;\">IEBUG：从 Internet Explorer 9 标准模式、Internet Explorer 10 标准模式、Internet Explorer 11 标准模式和 Windows 应用商店应用 开始，parseInt 函数不将前缀为“0”的字符串视为八进制。但在不使用 parseInt 函数时，前缀为“0”的字符串仍可被解释为八进制。</span>\n\n## 浮点值\n\n* 一个十进制整数，它可以带符号（即前面的“+”或“ - ”号），\n* 一个小数点（“.”），\n* 一个小数部分（由一串十进制数表示），\n* 一个指数部分\n指数部分是以“e”或“E”开头后面跟着一个整数，可以有正负号（即前面写“+”或“-”）。一个浮点数字面值必须至少有一位数字，后接小数点或者“e”（大写“E”也可）组成。一些浮点数字面值的例子，如3.1415，-3.1E13，.1e12以及2E-12。\n简言之，其语法是：\n\n    [digits][.digits][(E|e)[(+|-)]digits]\n    //实例:\n    3.14\n    2345.789\n    .3333333333333333333 // 0 可以省略\n\n以下两种情况，JavaScript会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。\n\n* 小数点前的数字多于21位\n```javascript\n    console.log(1234567890123456789012)    // 1.2345678901234568e+21\n```\n* 小数点后的零多于5个\n```javascript\n    console.log(0.0000003) //3e-7\n```\n\n## NaN\n\nNaN(not a number)用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。由上面的表中可以看出，对于单精度浮点数，NaN 表示为指数为 emax + 1 = 128（指数域全为 1），且尾数域不等于零的浮点数。IEEE 标准没有要求具体的尾数域，所以 <span style=\"red;\">NaN 实际上不是一个，而是一族</span>，它是全局对象global对象的一个属性(`window.NaN`)。\n需要注意的是，NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。\n\n```javascript\n    console.log(typeof NaN) // 'number\n```\n### 特性：\n* NaN不等于任何值，包括它本身。`NaN === NaN // false`\n* 由于数组的indexOf方法，内部使用的是严格相等运算符，所以该方法对NaN不成立。`NaN].indexOf(NaN) // -1`\n* NaN在布尔运算时被当作false。`Boolean(NaN) // false`\n* NaN与任何数（包括它自己）的运算，得到的都是NaN。\n\n```javascript\n    NaN + 32 // NaN\n    NaN - 32 // NaN\n    NaN * 32 // NaN\n    NaN / 32 // NaN\n```\n    \n### 判断NaN的方法 isNaN\n\n```javascript\n    isNaN(NaN) // true\n    isNaN(123) // false\n```\n    \n但是，`isNaN`只对数值有效，<span style=\"color:red;\">如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成`NaN`，所以最后返回`true`</span>，这一点要特别引起注意。也就是说，`isNaN`为`true`的值，有可能不是`NaN`，而是一个字符串。出于同样的原因，对于对象和数组，`isNaN`也返回`true`。\n\n```javascript\n    isNaN('Hello') // true\n    // 等同于\n    isNaN(Number('Hello')) // true\n\n    isNaN({}) // true\n    // 等同于\n    isNaN(Number({})) // true\n\n    isNaN(['xzy']) // true\n    // 等同于\n    isNaN(Number(['xzy'])) // true\n```\n\n但是，对于空数组和只有一个数值成员的数组，`isNaN`返回`false`。\n\n```javascript\n    isNaN([]) // false\n    isNaN([123]) // false\n    isNaN(['123']) // false\n```\n \n上面的代码之所以返回`false`，原因是这些数组能被`Number`函数转成数值，请参见《数据类型转换》一节。\n\n因此，使用`isNaN`之前，最好判断一下数据类型。\n\n```javascript\n    function myIsNaN(value) {\n    return typeof value === 'number' && isNaN(value);\n    }\n    判断NaN更可靠的方法是，利用`NaN`是JavaScript之中唯一不等于自身的值这个特点，进行判断。\n\n    function myIsNaN(value) {\n    return value !== value;\n    }\n```\n    \n## +0 和 -0\n\n先看一道题： 假如 A === B 并且 1/A < 1/B; 请问 A 等于 几？\n\n### 产生原因\n数字需要被编码才能进行数字化存储.举个例子,假如我们要将一个整数编码为4位的二进制数,使用原码(sign-and-magnitude)方法,则最高位是符号位(0代表正,1代表负),剩下的三位表示大小(具体的值).因此,−2和+2会编码成为下面这样:\n\n    1010 // +2\n    0010 // -2\n    这就意味着将会有两个零:\n    1000 // -0\n    0000 // +0\n在JavaScript中,所有的数字都是浮点数,都是根据IEEE-754标准中的浮点数算法以双精度格式被编码。这个标准中正负号的处理方式类似于原码(sign-and-magnitude)方法中整数的编码方式,所以也有正负零。\n\n### 参与运算\n```javascript\n+0 === -0 //true 虽然有正0和负0但是他们两个是相等\n-0 < +0   //false  \n+0 < -0   //false\n\n-0 + -0  // -0\n-0 + +0  // +0\n+0 X -5  // -0\n-0 X -5  // +0\n1 / +0  // Infinity\n1 / -0  // -Infinity\n+0 / -0  // NaN\n```\n    \n### 参与Math对象的方法\n\n* Math.pow(x,y)方法可返回从  之间的角度。\n    \n```javascript\nMath.pow(+0, -1) // Infinity\nMath.pow(-0, -1) // -Infinity\n```\n    \n* Math.atan2(x,y)方法可返回从 x<sup>y</sup> 的值。\n        \n```javascript\nx = 0 , y <= -0     // π(3.141592653589793)\nMath.atan2(+0, -0)  // π(3.141592653589793)\n\nx = 0 , y >= 0      // 0\nMath.atan2(+0, +0)  // 0\n\nx = -0 , y >= +0    // -0\nMath.atan2(-0, +0)  // -0\n\nx = -0 , y <= -0    // -π(-3.141592653589793)\nMath.atan2(-0, -0)  // -π(-3.141592653589793)\n```\n    \n* Math.round()是另外一个参数不为零却产生-0结果的操作:\n```javascript\nMath.round(-0.1) // -0\n```\n\n### 区分这两个零\n\n方法1: 判断一个零是正还是负的标准解法是用它除1，然后看计算的结果是-Infinity还是+Infinity\n        \n```javascript\nfunction isNegativeZero(x) {\n    return x === 0 && (1/x < 0);\n}\n```\n\n方法2: 除了上面讲的几种解法.还有一个解法来自Allen Wirfs-Brock(译者注:TC39编辑,ES标准就是他写出来的。):\n        \n```javascript\nfunction isNegativeZero(x) {\n    if (x !== 0) return false;\n    var obj = {};\n    Object.defineProperty(obj, 'z', { value: -0, configurable: false });\n    try {\n        // 如果x的值和z属性的当前值不相等的话,就会抛出异常.\n        Object.defineProperty(obj, 'z', { value: x });\n    } catch (e) {\n        return false\n    };\n    return true;\n}\n```\n        \n解释: 通常情况下,你不能重新定义一个不可配置的对象属性，否则会抛出异常:`TypeError: Cannot redefine property: z`可是，如果你重新定义属性时指定的属性特性的值与该特性当前的值相等，则JavaScript会忽略掉这个重定义，不会抛出异常。其中在判断两个值是否相等时使用的运算不是===，是一个称之为SameValue的内部算法，该算法可以区分开 -0 和 +0 。可以从Wirfs-Brock的原文中了解更多细。(冻结一个对象会让该对象的所有属性变的不可配置)。\n\n> 在执行一些特殊方法的时候，比如alert或innerHTML等方法，它将由脚本解析器自动调用toString()方法。\n\n看完上面这些，那么这节开头的题目的结果自然而然就知道喽。\n\n## Infinity\nInfinity 表示“无穷”，挂在global对象下的Infinity属性上(window.Infinity)。除了0除以0得到NaN，其他任意数除以0，得到Infinity。获得方式\n\n```javascript\nNumber.NEGATIVE_INFINITY // +infinity\nNumber.POSITIVE_INFINITY // -infinity\n\nwindow.Infinity === Number.POSITIVE_INFINITY // ture\n```\n\n```javascript\n1 / -0 // -Infinity\n1 / +0 // Infinity\n```\n    \n### 正负之分\n和+0\\-0 不同，`Infinity` 不等于 `-Infinity`。\n\n```javascript\nInfinity === -Infinity // false\n```\n### 产生原因\n\n```javascript\nMath.pow(+0, -1) // Infinity\nMath.pow(-0, -1) // -Infinity\n\n//运算结果超出JavaScript可接受范围，也会返回无穷。\nMath.pow(2, 2048) // Infinity\n-Math.pow(2, 2048) // -Infinity\n```\n\n### 参与运算\n\nInfinity的四则运算，符合无穷的数学计算规则。\n\n```javascript\n5 * Infinity // Infinity\n5 - Infinity // -Infinity\nInfinity / 5 // Infinity\n5 / Infinity // 0\n```\n\n```javascript\nInfinity - Infinity // NaN\nInfinity / Infinity // NaN\n\nInfinity + Infinity // Infinity\nInfinity * Infinity // Infinity\n```\n    \nnfinity可以用于布尔运算。可以记住，Infinity是JavaScript中最大的值（NaN除外），-Infinity是最小的值（NaN除外）。\n\n```javascript    \n5 > -Infinity // true\n5 > Infinity // false\n```\n\n由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript都不报错，所以单纯的数学运算几乎没有可能抛出错误。\n\n### isFinite函数\nisFinite函数返回一个布尔值，检查某个值是否为正常值，而不是Infinity。\n\n```javascript\nisFinite(Infinity) // false\nisFinite(-1) // true\nisFinite(true) // true\nisFinite(NaN) // false //如果对NaN使用isFinite函数，也返回false，表示NaN不是一个正常值\n```\n\n# 数值转换\n\n## Number()\n\n使用Number函数，可以将任意类型的值(<span style=\"color:red;\">parseInt和parseFloat只能转换字符串和数值类型</span>)转化成数字。\n\n* **简单类型转换规则**\n\n    - 数值：转换为十进制(因为默认调用toString()，会以十进制输出)。\n        ```javascript\n        Number(10);     // 10 \n        Number(010);    // 8\n        Number(090);    // 90 因为八进制中没有9，所以按照十进制处理 \n        Number(0x16);   // 22 \n        \n        Number(0o10);   //  在chrome和firefox为8，IE报错 `缺少 “)”` \n        Number(0b1000); //  在chrome和firefox为8，IE报错 `缺少 “)”` \n        ```\n\n    - 字符串：先去掉字符串前后的空格，如果可以被解析为数值，则转换为相应的数值，否则得到NaN。**空字符串`\"\"`转为0**。\n        - 如果字符串是`Number(\"0o17\")`和`Number(\"0b10000\")`（包括前面带正号或负号的情况）在chrome和firefox会按照八进制转换为十进制 16，但是IE不会生产`NaN`，十六进制没问题chrome和firefox、IE没问题。\n        - 如果字符串中包含有效的浮点格式，如\"1.1\"，则将其转换为对应的浮点数值（同样，也会忽略前导零）。\n        \n    - 布尔值：`true`转成 1，`false` 转成 0。\n\n    - `undefined`：转成`NaN`。\n\n    - `null`：转成0。\n\n    ```javascript\n    Number(\"324\") // 324\n    Number(\" -9.8 \") // -9.8\n    \n    Number(\"010\") // 10 和parseInt(\"010\")为不同\n    Number(\"0o17\")//  在chrome和firefox为16。IE为NaN。 \n    Number(\"0b10000\") // 在chrome和firefox为16。IE为NaN。 \n    Number(\"0x10\") // 在chrome和firefox为16。IE也为16。\n    \n    Number(\"324abc\") // NaN\n\n    Number(\"\") // 0\n\n    Number(false) // 0\n\n    Number(undefined) // NaN\n\n    Number(null) // 0\n    ```\n* **对象的转换规则**\n    对象的转换规则比较复杂。\n    1. 先调用对象自身的`valueOf`方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用`Number`方法，不再进行后续步骤。\n    2. 如果`valueOf`方法返回复合类型的值，再调用对象自身的`toString`方法，如果`toString`方法返回原始类型的值，则对该值使用`Number`方法，不再进行后续步骤。\n    3. 如果`toString`方法返回的是复合类型的值，则报错。\n    \n    ```javascript\n    Number({a:1,valueOf:function(){return \"5\"}}); //5  先调用对象自身的`valueOf`方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用`Number`方法，不再进行后续步骤。\n    Number({a:1,valueOf:function(){return {b:5}},toString:function(){return 4}}); //4  如果`valueOf`方法返回复合类型的值，再调用对象自身的`toString`方法，如果`toString`方法返回原始类型的值，则对该值使用`Number`方法，不再进行后续步骤。\n    Number({a:1,valueOf:function(){return {b:5}},toString:function(){return {}}}); //TypeError: Cannot convert object to primitive value 如果`toString`方法返回的是复合类型的值，则报错。\n    ```\n## parseInt()\n* 基本用法    \n    `parseInt()`方法可以将字符串转化为整数。如果字符串头部有空格，空格会被自动去除。\n    ```javascript\n        parseInt('8a') // 8\n        parseInt(\" -12 ba\") //-12\n        \n        //十六进制\n        parseInt('0xf00') // 3840 开头两个字符是`0x`或`0X`，`parseInt`将其视为十六进制数\n        //八进制\n        parseInt('056') // 56\n        parseInt('0o56') // 0\n        parseInt('0O56') // 0\n        //二进制\n        parseInt(\"0B10\") // 0\n    ```\n    上面代码中，`parseInt`的参数都是字符串，结果只返回字符串头部可以转为数字的部分。最后一行的`0xf00`之所以可以转为数字，因为如果开头两个字符是`0x`或`0X`，`parseInt`将其视为十六进制数，但是八进制和二进制确默认视为普通字符串。\n    如果字符串的第一个`非空格字符`不能转化为数字（数字的正负号除外），返回`NaN`。\n    \n    ```javascript\n    parseInt('abc') // NaN\n    parseInt('.3') // NaN\n    parseInt('') // NaN 不同于Number()\n    parseInt(null) // NaN 不同于Number()\n    parseInt('+') // NaN\n    ```\n* 进制转换\n`parseInt()`方法还可以接受第二个参数（2到36之间，超出区间(`包括负数但0除外`)返回`NaN`），表示被解析的值的进制，返回该值对应的十进制数。\n如果第二个参数不是数值，会被自动转为（调用`Number()`）一个整数，这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回`NaN`，如果转换的结果为`0，NaN`，都会直接忽略返回原值。\n如果第二个参数是`0`、`undefined`和`null`等等一些不能转为正常整数的值，则直接忽略。\n\n    ```javascript\n        parseInt(1000, 2) // 8\n        parseInt(1000, 6) // 216\n        parseInt(1000, 8) // 512\n        //特殊情况\n        parseInt(1000, \"8\") // 512 把\"8\"自动转为8\n        parseInt(1000, \" +8 \") // 512 会自动去掉前置和后置空格\n        parseInt(1000, \" -8 \") // NaN 负数超出范围\n        parseInt(1000, 1) // NaN 超出范围\n        parseInt(1000, 37) // NaN 超出范围\n        parseInt(1000, \"8aa\") // 1000 因为Number(\"8aa\")等于NaN\n        parseInt(1000, 0) // 1000  直接忽略返回原值\n        parseInt(1000, NaN) // 1000\n        parseInt(1000, null) // 1000 因为Number(NaN)等于0\n        parseInt(1000, undefined) // 1000 因为Number(undefined)等于NaN\n        parseInt(\"1000\", {\n            a:1,\n            valueOf:function(){\n                return 5;\n            }\n        }) //125  因为Number({a:1,valueOf:function(){return 5;}}) 返回5 所以\n    ```\n\n* 特别注意\n需要注意的是，进制转换的时候，参数是字符串或数值，`parseInt`的行为不一致。\n1. 如果第一个参数是数值，会将这个数值先转为十进制，然后再应用第二个参数。\n\n    ```javascript\n    parseInt(0x11, 36) // 43\n    parseInt(17, 36) // 43\n    ```\n    上面代码中，`0x11`会被先转为十进制的17，然后再用36进制解读这个17，最后返回结果43。\n\n2. 如果第一个参数是字符串，则会直接用指定进制解读这个字符串。\n    \n    ```javascript\n    parseInt('0x11', 36) // 42805\n    parseInt('x', 36) // 33\n    ```\n\n    上面代码中，字符串`0x11`会被直接当作一个36进制的数。由于字符`x`在36进制中代表33，导致`0x11`被解读为42805。\n\n    ```javascript\n    parseInt(010, 10) // 8\n    parseInt('010', 10) // 10\n\n    parseInt(010, 2) // NaN 因为`010数值`转换为十进制是8，而8在二进制是不存在的所以返回`NaN`\n    parseInt('010', 2) // 2\n\n    parseInt(010, 8) // NaN 因为`010数值`转换为十进制是8，而8在八进制是不存在的所以返回`NaN`\n    parseInt('010', 8) // 8\n\n    parseInt(020, 10) // 16\n    parseInt('020', 10) // 20\n\n    parseInt(020, 8) // 14 因为`020数值`转换为十进制是16，再转换为8进制刚好14\n    parseInt('020', 8) // 16 因为`020字符串`转换为十进制是20，再转换为8进制刚好16\n    ```\n\n    上面代码中，`010`会被先转为十进制8，然后再应用第二个参数，由于二进制和八进制中没有8这个数字，所以`parseInt(010, 2)`和`parseInt(010, 8)`返回`NaN`。同理，数值`020`会被先转为十进制的16，然后再应用第二个参数。\n    > `parseInt`的很多复杂行为，都是由八进制的前缀0引发的，这增加编程处理的复杂性。因此，ECMAScript 5不再允许parseInt将带有前缀0的数字，视为八进制数，而是要求忽略这个`0`。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。\n\n3. 如果第一个参数是以`0x`或`0X`开头的字符串，而第二个参数省略或为0，则`parseInt`自动将第二个参数设为16。\n    ```javascript\n        parseInt('0xFF') // 255\n        parseInt('0xFF', 0) // 255\n        parseInt('0xFF', 16) // 255\n        \n        parseInt('0xFF', 10) // 0\n        parseInt('0xFF', 17) // 0\n    ```\n    上面代码中，第二个参数除了0、16和省略，其他情况都会依次解析第一个参数，直到遇到第一个不可解析字符。\n\n4. 科学计数法产生的扯淡问题\n    对于那些会自动转为科学计数法的数字，`parseInt`会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。\n    \n    ```javascript\n    parseInt(1000000000000000000000.5, 10) // 1\n    // 等同于\n    parseInt('1e+21', 10) // 1\n\n    parseInt(0.0000008, 10) // 8\n    // 等同于\n    parseInt('8e-7', 10) // 8\n    ```\n\n## parseFloat()\n* 基本用法\n    parseFloat`方法用于将一个字符串转为浮点数。    \n    ```javascript\n    parseFloat(\"3.14\") // 3.14\n    ```\n\n1. 如果字符串符合科学计数法，则会进行相应的转换。\n    \n    ```javascript\n    parseFloat('314e-2') // 3.14\n    parseFloat('0.0314E+2') // 3.14\n    ```\n2. 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。\n    ```javascript\n    parseFloat('3.14more non-digit characters') // 3.14\n    ```\n    `parseFloat`方法会自动过滤字符串前导的空格。\n    ```javascript\n    parseFloat('\\t\\v\\r12.34\\n ') // 12.34\n    ```\n\n3. 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回`NaN`。\n    ```javascript\n    parseFloat([]) // NaN\n    parseFloat('FF2') // NaN\n\n    parseFloat(true)  // NaN 不同于`Number`函数\n    Number(true) // 1\n\n    parseFloat(null) // NaN 不同于`Number`函数\n    Number(null) // 0\n\n    parseFloat('') // NaN 不同于`Number`函数\n    Number('') // 0\n\n    parseFloat('123.45#') // 123.45  不同于`Number`函数\n    Number('123.45#') // NaN\n    ```\n** 特别注意：`parseInt()`和`parseFloat()`会先调用值的`toString()`方法，`Number()`是先调用`valueOf`，返回结果有问题再调用`toString`**\n```javascript\nparseInt({\na: 1,\ntoString: function(){\n            return \"11\"\n            }\n});\n\nparseFloat({\na: 1,\ntoString: function(){\n            return \"11\"\n            }\n});\n```\n上面这两种情况也会正确的返回`11`，看到这儿你会说“你不是说parseInt只能转换字符串”吗？其实真正的原因是，所有的转换第一步都是调用`toString()`方法。\n\n```javascript\nNumber.prototype.toString = function(){\n    console.log(\"我被调用了\")\n    return 123123;\n}\nNumber.prototype.valueOf = function(){\n    console.log(\"我被调用了-valueOf\")\n    return 123123;\n}\n\nvar a  = new Number(12);\n\n\nparseInt(a) // 我被调用了 123123\nNumber(a) // 我被调用了-valueOf 123123\n```\n上面这段code 足以证明**特别注意**。\n详见：[Ex igne vita](http://es5.github.io/#x15.1.2.2)\n\n** 引用：**\n\n> [紫云飞](http://www.cnblogs.com/ziyunfei/archive/2012/12/10/2777099.html)\n> [阮一峰](http://javascript.ruanyifeng.com/)","slug":"好好学学number","published":1,"updated":"2016-02-02T07:09:17.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5exx000c703vahn838t7"},{"title":"好好学学String!","date":"2016-02-02T06:36:10.000Z","comments":1,"_content":"## 概述\n\n### 定义\n\n字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。\n<!--more-->\n```javascript\n'abc'\n\"abc\"\n```\n\n单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。\n\n```javascript\n'key=\"value\"'\n\"It's a long journey\"\n```\n\n上面两个都是合法的字符串。\n\n如果要在单引号字符串的内部，使用单引号（或者在双引号字符串的内部，使用双引号），就必须在内部的单引号（或者双引号）前面加上反斜杠，用来转义。\n\n```javascript\n'Did she say \\'Hello\\'?'\n// \"Did she say 'Hello'?\"\n\n\"Did she say \\\"Hello\\\"?\"\n// \"Did she say \"Hello\"?\"\n```\n\n字符串默认只能写在一行内，分成多行将会报错。\n\n```javascript\n'a\nb\nc'\n// SyntaxError: Unexpected token ILLEGAL\n```\n\n上面代码将一个字符串分成三行，JavaScript就会报错。\n\n多行字符串是正式规范(ECMA 265 5th edition)的一部分，ES5扩展了字符串字面量的语法。在(7.8.4 String Literals)中添加了`DoubleStringCharacter`和 `SingleStringCharacter`: `LineContinuation`。\nLineTerminatorSequence 指的是下面这些字符中的一个：\n* 换行符 `<LF>`\n* 回车符 `<CR>`\n* 行分割符 `<LS>`\n* 段分隔符 `<PS>`\n\nLineContinuation 的语法是:\n```javascript\n    \\ LineTerminatorSequence\n```\n如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\n\n```javascript\nvar longString = \"Long\\\\n\\\nlong \\\nlong \\\nstring\";\n\nlongString\n// \"Long\\nlong long string\"\n```\n\n上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行，效果与写在同一行完全一样。注意，反斜杠的后面必须是`LineTerminatorSequence`中的一个上例中的是换行符，而不能有其他字符（比如空格），否则会报错。\n\n连接运算符（`+`）可以连接多个单行字符串，用来模拟多行字符串。\n\n```javascript\nvar longString = 'Long '\n  + 'long '\n  + 'long '\n  + 'string';\n```\n\n另外，有一种利用多行注释，生成多行字符串的变通方法。\n\n```javascript\n(function () { /*\nline 1\nline 2\nline 3\n*/}).toString().split('\\n').slice(1,-1).join('\\n')\n// \"line 1 line 2 line 3\"\n\n### 转义\n\n反斜杠（`\\\\`）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。\n\n需要用反斜杠转义的特殊字符，主要有下面这些：\n\n- `\\0` 代表没有内容的字符（\\u0000）\n- `\\b` 后退键（\\u0008）\n- `\\f` 换页符（\\u000C）\n- `\\n` 换行符（\\u000A）\n- `\\r` 回车键（\\u000D）\n- `\\t` 制表符（\\u0009）\n- `\\v` 垂直制表符（\\u000B）\n- `\\'` 单引号（\\u0027）\n- `\\\"` 双引号（\\u0022）\n- `\\\\\\\\` 反斜杠（\\u005C）\n- `\\XXX` 用三个八进制数（000到377）表示字符，`XXX`对应该字符的Unicode，比如`\\251`表示版权符号。\n- `\\xXX` 用两个十六进制数（00到FF）表示字符，`XX`对应该字符的Unicode，比如`\\xA9`表示版权符号。\n- `\\uXXXX` 用四位十六进制的Unicode编号代表某个字符，比如`\\u00A9`表示版权符号。\n\n下面是最后三种字符的特殊写法的例子。\n\n```javascript\n'\\251' // \"©\"\n'\\xA9' // \"©\"\n'\\u00A9' // \"©\"\n\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n```\n\n如果非特殊字符前面使用反斜杠，则反斜杠会被省略。\n\n```javascript\n'\\a' // \"a\"\n```\n\n上面代码表示`a`是一个正常字符，前面加反斜杠没有特殊含义，则反斜杠会被自动省略。\n\n如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前需要再加一个反斜杠，用来对自身转义。\n\n```javascript\n\"Prev \\\\ Next\" // \"Prev \\ Next\"\n```\n\n### 字符串与数组\n\n字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（从0开始）。\n\n```javascript\nvar s = 'hello';\n\ns[0] // \"h\"\ns[1] // \"e\"\ns[4] // \"o\"\n\n// 也可以直接对字符串使用方括号运算符\n'hello'[1] // \"e\"\n```\n\n如果方括号中的数字超过字符串的范围，或者方括号中根本不是数字，则返回`undefined`。\n\n```javascript\n'abc'[3] // undefined\n'abc'[-1] // undefined\n'abc'['x'] // undefined\n```\n\n但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。\n\n```javascript\nvar s = 'hello';\n\ndelete s[0];\ns // \"hello\"\n\ns[1] = 'a';\ns // \"hello\"\n\ns[5] = '!';\ns // \"hello\"\n```\n\n上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。\n\n字符串也无法添加新属性。\n\n```javascript\nvar s = 'Hello World';\ns.x = 123;\ns.x // undefined\n```\n\n上面代码为字符串`s`添加了一个`x`属性，结果无效，总是返回`undefined`。\n\n上面这些行为的原因是，在JavaScript内部，变量`s`其实指向字符串`Hello World`的地址，而`Hello World`本身是一个常量，所以无法改变它，既不能新增，也不能删除。另一方面，当一个字符串被调用属性时，它会自动转为String对象的实例（参见《标准库》一章），调用结束后，该对象自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个临时生成的新对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果想要为字符串添加属性，只有在它的原型对象`String.prototype`上定义（参见《面向对象编程》一章）。\n\n### length属性\n\n`length`属性返回字符串的长度，该属性也是无法改变的。\n\n```javascript\nvar s = 'hello';\ns.length // 5\n\ns.length = 3;\ns.length // 5\n\ns.length = 7;\ns.length // 5\n```\n\n上面代码表示字符串的`length`属性无法改变，但是不会报错。\n\n## 字符集\n\nJavaScript使用Unicode字符集，也就是说在JavaScript内部，所有字符都用Unicode表示。\n\n不仅JavaScript内部使用Unicode储存字符，而且还可以直接在程序中使用Unicode，所有字符都可以写成\"\\uxxxx\"的形式，其中xxxx代表该字符的Unicode编码。比如，`\\u00A9`代表版权符号。\n\n```javascript\nvar s = '\\u00A9';\ns // \"©\"\n```\n\n每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。\n\n但是，UTF-16有两种长度：对于`U+0000`到`U+FFFF`之间的字符，长度为16位（即2个字节）；对于`U+10000`到`U+10FFFF`之间的字符，长度为32位（即4个字节），而且前两个字节在`0xD800`到`0xDBFF`之间，后两个字节在`0xDC00`到`0xDFFF`之间。举例来说，`U+1D306`对应的字符为𝌆，它写成UTF-16就是`0xD834 0xDF06`。浏览器会正确将这四个字节识别为一个字符，但是JavaScript内部的字符长度总是固定为16位，会把这四个字节视为两个字符。\n\n```javascript\nvar s = '\\uD834\\uDF06';\n\ns // \"𝌆\"\ns.length // 2\n/^.$/.test(s) // false\ns.charAt(0) // \"\"\ns.charAt(1) // \"\"\ns.charCodeAt(0) // 55348\ns.charCodeAt(1) // 57094\n```\n\n上面代码说明，对于于`U+10000`到`U+10FFFF`之间的字符，JavaScript总是视为两个字符（字符的`length`属性为2），用来匹配单个字符的正则表达式会失败（JavaScript认为这里不止一个字符），`charAt`方法无法返回单个字符，`charCodeAt`方法返回每个字节对应的十进制值。\n\n所以处理的时候，必须把这一点考虑在内。对于4个字节的Unicode字符，假定`C`是字符的Unicode编号，`H`是前两个字节，`L`是后两个字节，则它们之间的换算关系如下。\n\n```javascript\n// 将大于U+FFFF的字符，从Unicode转为UTF-16\nH = Math.floor((C - 0x10000) / 0x400) + 0xD800\nL = (C - 0x10000) % 0x400 + 0xDC00\n\n// 将大于U+FFFF的字符，从UTF-16转为Unicode\nC = (H - 0xD800) * 0x400 + L - 0xDC00 + 0x10000\n```\n\n下面的正则表达式可以识别所有UTF-16字符。\n\n```javascript\n([\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])\n```\n\n由于JavaScript引擎（严格说是ES5规格）不能自动识别辅助平面（编号大于0xFFFF）的Unicode字符，导致所有字符串处理函数遇到这类字符，都会产生错误的结果（详见《标准库》一章的`String`对象章节）。如果要完成字符串相关操作，就必须判断字符是否落在`0xD800`到`0xDFFF`这个区间。\n\n下面是能够正确处理字符串遍历的函数。\n\n```javascript\nfunction getSymbols(string) {\n  var length = string.length;\n  var index = -1;\n  var output = [];\n  var character;\n  var charCode;\n  while (++index < length) {\n    character = string.charAt(index);\n    charCode = character.charCodeAt(0);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      output.push(character + string.charAt(++index));\n    } else {\n      output.push(character);\n    }\n  }\n  return output;\n}\n\nvar symbols = getSymbols('𝌆');\n\nsymbols.forEach(function(symbol) {\n  // ...\n});\n```\n\n替换（`String.prototype.replace`）、截取子字符串（`String.prototype.substring`, `String.prototype.slice`）等其他字符串操作，都必须做类似的处理。\n\n## Base64转码\n\nBase64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是为了不出现特殊字符，简化程序的处理。\n\nJavaScript原生提供两个Base64相关方法。\n\n- btoa()：字符串或二进制值转为Base64编码\n- atob()：Base64编码转为原来的编码\n\n```javascript\nvar string = 'Hello World!';\nbtoa(string) // \"SGVsbG8gV29ybGQh\"\natob('SGVsbG8gV29ybGQh') // \"Hello World!\"\n```\n\n这两个方法不适合非ASCII码的字符，会报错。\n\n```javascript\nbtoa('你好')\n// Uncaught DOMException: The string to be encoded contains characters outside of the Latin1 range.\n```\n\n要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。\n\n```javascript\nfunction b64Encode( str ) {\n  return btoa(unescape(encodeURIComponent( str )));\n}\n\nfunction b64Decode( str ) {\n  return decodeURIComponent(escape(atob( str )));\n}\n\nb64Encode('你好') // \"5L2g5aW9\"\nb64Decode('5L2g5aW9') // \"你好\"\n```\n## 转换为字符串 String()\n\n### toString()\n数值、布尔值、对象和字符串值（没错，每个字符串也都有一个`toString()`方法，该方法返回字符串的一个副本）都有`toString()`方法。但`null` 和 `undefined` 值没有这个方法。\n多数情况下，调用`toString()`方法不必传递参数。但是，在调用数值的`toString()`方法时，可以传递一个参数：输出数值的基数。默认情况下，`toString()`方法以十进制格式返回数值的字符串表示。而通过传递基数，`toString()`可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。\n在不知道要转换的值是不是`null` 或 `undefined` 的情况下，还可以使用转型函数`String()`。\n### String()\n\n使用String函数，可以将任意类型的值转化成字符串。规则如下：\n\n1. 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果。\n2. 如果值是null，则返回\"null\"。\n3. 如果值是undefined，则返回\"undefined\"。\n\n**（1）原始类型值的转换规则**\n\n- **数值**：调用Number的toString()方法，转换后还是原来的值。转为相应的字符串。\n\n- **字符串**：调用String的toString()方法，转换后还是原来的值。\n\n- **布尔值**：调用Boolean的toString()方法，true转为“true”，false转为“false”。\n\n- **undefined**：转为“undefined”。\n\n- **null**：转为“null”。\n```javascript\nString(123) // \"123\"\n\nString(\"abc\") // \"abc\"\n\nString(true) // \"true\"\n\nString(undefined) // \"undefined\"\n\nString(null) // \"null\"\n\nBoolean.prototype.toString = function(){\n    console.log(\"wo bei diaoyongle\");\n}\nvar a = new Boolean(true);\nString(a) // \"wo bei diaoyongle\" \"undefined\"\n\n```\n**（2）对象的转换规则**\n\n如果要将对象转为字符串，则是采用以下步骤。\n\n1. 先调用`toString`方法，如果toString方法返回的是简单类型(`Boolean`、`number`、`string`、`null`、`undefined`)的值，则对该值使用`String`方法，不再进行以下步骤。\n\n2. 如果`toString`方法返回的是复合类型的值，再调用`valueOf`方法，如果`valueOf`方法返回的是原始类型的值，则对该值使用String方法，不再进行以下步骤。\n\n3. 如果`valueOf`方法返回的是复合类型的值，则报错。\n\nString方法的这种过程正好与Number方法相反。\n\n```javascript\n\nString({a:1}) // \"[object Object]\"\n```\n\n上面代码相当于下面这样。\n\n```javascript\n\nString({a:1}.toString()) // \"[object Object]\"\n\n```\n\n如果toString方法和valueOf方法，返回的都不是原始类型的值，则String方法报错。\n```javascript\nvar  T = {toString:function(){return true},valueOf:function(){return undefined}};\nString(T) // \"true\" 调用toString\n\nvar  T = {toString:function(){return {}},valueOf:function(){return undefined}};\nString(T) // \"undefined\" 调用valueOf\n\nvar  T = {toString:function(){return {}},valueOf:function(){return {}}};\nString(T) // Error Uncaught TypeError: Cannot convert object to primitive value(…)\n\n```\n\n下面是一个自定义toString方法的例子。\n\n```javascript\n\nString({toString:function(){return 3;}}) // \"3\"\n\nString({valueOf:function (){return 2;}}) // \"[object Object]\"\n\nString({valueOf:function (){return 2;},toString:function(){return 3;}}) // \"3\"\n```\n\n上面代码对三个对象使用String方法。第一个对象返回toString方法的值（数值3），然后对其使用String方法，得到字符串“3”；第二个对象返回的还是toString方法的值（\"[object Object]\"），这次直接就是字符串；第三个对象表示toString方法先于valueOf方法执行。\n\n\n> ** 转自：** (阮一峰)[http://javascript.ruanyifeng.com/grammar/string.html]","source":"_posts/好好学学String-2016-02-02.md","raw":"title: 好好学学String!\ndate: 2016-02-02 14:36:10\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n## 概述\n\n### 定义\n\n字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。\n<!--more-->\n```javascript\n'abc'\n\"abc\"\n```\n\n单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。\n\n```javascript\n'key=\"value\"'\n\"It's a long journey\"\n```\n\n上面两个都是合法的字符串。\n\n如果要在单引号字符串的内部，使用单引号（或者在双引号字符串的内部，使用双引号），就必须在内部的单引号（或者双引号）前面加上反斜杠，用来转义。\n\n```javascript\n'Did she say \\'Hello\\'?'\n// \"Did she say 'Hello'?\"\n\n\"Did she say \\\"Hello\\\"?\"\n// \"Did she say \"Hello\"?\"\n```\n\n字符串默认只能写在一行内，分成多行将会报错。\n\n```javascript\n'a\nb\nc'\n// SyntaxError: Unexpected token ILLEGAL\n```\n\n上面代码将一个字符串分成三行，JavaScript就会报错。\n\n多行字符串是正式规范(ECMA 265 5th edition)的一部分，ES5扩展了字符串字面量的语法。在(7.8.4 String Literals)中添加了`DoubleStringCharacter`和 `SingleStringCharacter`: `LineContinuation`。\nLineTerminatorSequence 指的是下面这些字符中的一个：\n* 换行符 `<LF>`\n* 回车符 `<CR>`\n* 行分割符 `<LS>`\n* 段分隔符 `<PS>`\n\nLineContinuation 的语法是:\n```javascript\n    \\ LineTerminatorSequence\n```\n如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\n\n```javascript\nvar longString = \"Long\\\\n\\\nlong \\\nlong \\\nstring\";\n\nlongString\n// \"Long\\nlong long string\"\n```\n\n上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行，效果与写在同一行完全一样。注意，反斜杠的后面必须是`LineTerminatorSequence`中的一个上例中的是换行符，而不能有其他字符（比如空格），否则会报错。\n\n连接运算符（`+`）可以连接多个单行字符串，用来模拟多行字符串。\n\n```javascript\nvar longString = 'Long '\n  + 'long '\n  + 'long '\n  + 'string';\n```\n\n另外，有一种利用多行注释，生成多行字符串的变通方法。\n\n```javascript\n(function () { /*\nline 1\nline 2\nline 3\n*/}).toString().split('\\n').slice(1,-1).join('\\n')\n// \"line 1 line 2 line 3\"\n\n### 转义\n\n反斜杠（`\\\\`）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。\n\n需要用反斜杠转义的特殊字符，主要有下面这些：\n\n- `\\0` 代表没有内容的字符（\\u0000）\n- `\\b` 后退键（\\u0008）\n- `\\f` 换页符（\\u000C）\n- `\\n` 换行符（\\u000A）\n- `\\r` 回车键（\\u000D）\n- `\\t` 制表符（\\u0009）\n- `\\v` 垂直制表符（\\u000B）\n- `\\'` 单引号（\\u0027）\n- `\\\"` 双引号（\\u0022）\n- `\\\\\\\\` 反斜杠（\\u005C）\n- `\\XXX` 用三个八进制数（000到377）表示字符，`XXX`对应该字符的Unicode，比如`\\251`表示版权符号。\n- `\\xXX` 用两个十六进制数（00到FF）表示字符，`XX`对应该字符的Unicode，比如`\\xA9`表示版权符号。\n- `\\uXXXX` 用四位十六进制的Unicode编号代表某个字符，比如`\\u00A9`表示版权符号。\n\n下面是最后三种字符的特殊写法的例子。\n\n```javascript\n'\\251' // \"©\"\n'\\xA9' // \"©\"\n'\\u00A9' // \"©\"\n\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n```\n\n如果非特殊字符前面使用反斜杠，则反斜杠会被省略。\n\n```javascript\n'\\a' // \"a\"\n```\n\n上面代码表示`a`是一个正常字符，前面加反斜杠没有特殊含义，则反斜杠会被自动省略。\n\n如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前需要再加一个反斜杠，用来对自身转义。\n\n```javascript\n\"Prev \\\\ Next\" // \"Prev \\ Next\"\n```\n\n### 字符串与数组\n\n字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（从0开始）。\n\n```javascript\nvar s = 'hello';\n\ns[0] // \"h\"\ns[1] // \"e\"\ns[4] // \"o\"\n\n// 也可以直接对字符串使用方括号运算符\n'hello'[1] // \"e\"\n```\n\n如果方括号中的数字超过字符串的范围，或者方括号中根本不是数字，则返回`undefined`。\n\n```javascript\n'abc'[3] // undefined\n'abc'[-1] // undefined\n'abc'['x'] // undefined\n```\n\n但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。\n\n```javascript\nvar s = 'hello';\n\ndelete s[0];\ns // \"hello\"\n\ns[1] = 'a';\ns // \"hello\"\n\ns[5] = '!';\ns // \"hello\"\n```\n\n上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。\n\n字符串也无法添加新属性。\n\n```javascript\nvar s = 'Hello World';\ns.x = 123;\ns.x // undefined\n```\n\n上面代码为字符串`s`添加了一个`x`属性，结果无效，总是返回`undefined`。\n\n上面这些行为的原因是，在JavaScript内部，变量`s`其实指向字符串`Hello World`的地址，而`Hello World`本身是一个常量，所以无法改变它，既不能新增，也不能删除。另一方面，当一个字符串被调用属性时，它会自动转为String对象的实例（参见《标准库》一章），调用结束后，该对象自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个临时生成的新对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果想要为字符串添加属性，只有在它的原型对象`String.prototype`上定义（参见《面向对象编程》一章）。\n\n### length属性\n\n`length`属性返回字符串的长度，该属性也是无法改变的。\n\n```javascript\nvar s = 'hello';\ns.length // 5\n\ns.length = 3;\ns.length // 5\n\ns.length = 7;\ns.length // 5\n```\n\n上面代码表示字符串的`length`属性无法改变，但是不会报错。\n\n## 字符集\n\nJavaScript使用Unicode字符集，也就是说在JavaScript内部，所有字符都用Unicode表示。\n\n不仅JavaScript内部使用Unicode储存字符，而且还可以直接在程序中使用Unicode，所有字符都可以写成\"\\uxxxx\"的形式，其中xxxx代表该字符的Unicode编码。比如，`\\u00A9`代表版权符号。\n\n```javascript\nvar s = '\\u00A9';\ns // \"©\"\n```\n\n每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。\n\n但是，UTF-16有两种长度：对于`U+0000`到`U+FFFF`之间的字符，长度为16位（即2个字节）；对于`U+10000`到`U+10FFFF`之间的字符，长度为32位（即4个字节），而且前两个字节在`0xD800`到`0xDBFF`之间，后两个字节在`0xDC00`到`0xDFFF`之间。举例来说，`U+1D306`对应的字符为𝌆，它写成UTF-16就是`0xD834 0xDF06`。浏览器会正确将这四个字节识别为一个字符，但是JavaScript内部的字符长度总是固定为16位，会把这四个字节视为两个字符。\n\n```javascript\nvar s = '\\uD834\\uDF06';\n\ns // \"𝌆\"\ns.length // 2\n/^.$/.test(s) // false\ns.charAt(0) // \"\"\ns.charAt(1) // \"\"\ns.charCodeAt(0) // 55348\ns.charCodeAt(1) // 57094\n```\n\n上面代码说明，对于于`U+10000`到`U+10FFFF`之间的字符，JavaScript总是视为两个字符（字符的`length`属性为2），用来匹配单个字符的正则表达式会失败（JavaScript认为这里不止一个字符），`charAt`方法无法返回单个字符，`charCodeAt`方法返回每个字节对应的十进制值。\n\n所以处理的时候，必须把这一点考虑在内。对于4个字节的Unicode字符，假定`C`是字符的Unicode编号，`H`是前两个字节，`L`是后两个字节，则它们之间的换算关系如下。\n\n```javascript\n// 将大于U+FFFF的字符，从Unicode转为UTF-16\nH = Math.floor((C - 0x10000) / 0x400) + 0xD800\nL = (C - 0x10000) % 0x400 + 0xDC00\n\n// 将大于U+FFFF的字符，从UTF-16转为Unicode\nC = (H - 0xD800) * 0x400 + L - 0xDC00 + 0x10000\n```\n\n下面的正则表达式可以识别所有UTF-16字符。\n\n```javascript\n([\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])\n```\n\n由于JavaScript引擎（严格说是ES5规格）不能自动识别辅助平面（编号大于0xFFFF）的Unicode字符，导致所有字符串处理函数遇到这类字符，都会产生错误的结果（详见《标准库》一章的`String`对象章节）。如果要完成字符串相关操作，就必须判断字符是否落在`0xD800`到`0xDFFF`这个区间。\n\n下面是能够正确处理字符串遍历的函数。\n\n```javascript\nfunction getSymbols(string) {\n  var length = string.length;\n  var index = -1;\n  var output = [];\n  var character;\n  var charCode;\n  while (++index < length) {\n    character = string.charAt(index);\n    charCode = character.charCodeAt(0);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      output.push(character + string.charAt(++index));\n    } else {\n      output.push(character);\n    }\n  }\n  return output;\n}\n\nvar symbols = getSymbols('𝌆');\n\nsymbols.forEach(function(symbol) {\n  // ...\n});\n```\n\n替换（`String.prototype.replace`）、截取子字符串（`String.prototype.substring`, `String.prototype.slice`）等其他字符串操作，都必须做类似的处理。\n\n## Base64转码\n\nBase64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是为了不出现特殊字符，简化程序的处理。\n\nJavaScript原生提供两个Base64相关方法。\n\n- btoa()：字符串或二进制值转为Base64编码\n- atob()：Base64编码转为原来的编码\n\n```javascript\nvar string = 'Hello World!';\nbtoa(string) // \"SGVsbG8gV29ybGQh\"\natob('SGVsbG8gV29ybGQh') // \"Hello World!\"\n```\n\n这两个方法不适合非ASCII码的字符，会报错。\n\n```javascript\nbtoa('你好')\n// Uncaught DOMException: The string to be encoded contains characters outside of the Latin1 range.\n```\n\n要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。\n\n```javascript\nfunction b64Encode( str ) {\n  return btoa(unescape(encodeURIComponent( str )));\n}\n\nfunction b64Decode( str ) {\n  return decodeURIComponent(escape(atob( str )));\n}\n\nb64Encode('你好') // \"5L2g5aW9\"\nb64Decode('5L2g5aW9') // \"你好\"\n```\n## 转换为字符串 String()\n\n### toString()\n数值、布尔值、对象和字符串值（没错，每个字符串也都有一个`toString()`方法，该方法返回字符串的一个副本）都有`toString()`方法。但`null` 和 `undefined` 值没有这个方法。\n多数情况下，调用`toString()`方法不必传递参数。但是，在调用数值的`toString()`方法时，可以传递一个参数：输出数值的基数。默认情况下，`toString()`方法以十进制格式返回数值的字符串表示。而通过传递基数，`toString()`可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。\n在不知道要转换的值是不是`null` 或 `undefined` 的情况下，还可以使用转型函数`String()`。\n### String()\n\n使用String函数，可以将任意类型的值转化成字符串。规则如下：\n\n1. 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果。\n2. 如果值是null，则返回\"null\"。\n3. 如果值是undefined，则返回\"undefined\"。\n\n**（1）原始类型值的转换规则**\n\n- **数值**：调用Number的toString()方法，转换后还是原来的值。转为相应的字符串。\n\n- **字符串**：调用String的toString()方法，转换后还是原来的值。\n\n- **布尔值**：调用Boolean的toString()方法，true转为“true”，false转为“false”。\n\n- **undefined**：转为“undefined”。\n\n- **null**：转为“null”。\n```javascript\nString(123) // \"123\"\n\nString(\"abc\") // \"abc\"\n\nString(true) // \"true\"\n\nString(undefined) // \"undefined\"\n\nString(null) // \"null\"\n\nBoolean.prototype.toString = function(){\n    console.log(\"wo bei diaoyongle\");\n}\nvar a = new Boolean(true);\nString(a) // \"wo bei diaoyongle\" \"undefined\"\n\n```\n**（2）对象的转换规则**\n\n如果要将对象转为字符串，则是采用以下步骤。\n\n1. 先调用`toString`方法，如果toString方法返回的是简单类型(`Boolean`、`number`、`string`、`null`、`undefined`)的值，则对该值使用`String`方法，不再进行以下步骤。\n\n2. 如果`toString`方法返回的是复合类型的值，再调用`valueOf`方法，如果`valueOf`方法返回的是原始类型的值，则对该值使用String方法，不再进行以下步骤。\n\n3. 如果`valueOf`方法返回的是复合类型的值，则报错。\n\nString方法的这种过程正好与Number方法相反。\n\n```javascript\n\nString({a:1}) // \"[object Object]\"\n```\n\n上面代码相当于下面这样。\n\n```javascript\n\nString({a:1}.toString()) // \"[object Object]\"\n\n```\n\n如果toString方法和valueOf方法，返回的都不是原始类型的值，则String方法报错。\n```javascript\nvar  T = {toString:function(){return true},valueOf:function(){return undefined}};\nString(T) // \"true\" 调用toString\n\nvar  T = {toString:function(){return {}},valueOf:function(){return undefined}};\nString(T) // \"undefined\" 调用valueOf\n\nvar  T = {toString:function(){return {}},valueOf:function(){return {}}};\nString(T) // Error Uncaught TypeError: Cannot convert object to primitive value(…)\n\n```\n\n下面是一个自定义toString方法的例子。\n\n```javascript\n\nString({toString:function(){return 3;}}) // \"3\"\n\nString({valueOf:function (){return 2;}}) // \"[object Object]\"\n\nString({valueOf:function (){return 2;},toString:function(){return 3;}}) // \"3\"\n```\n\n上面代码对三个对象使用String方法。第一个对象返回toString方法的值（数值3），然后对其使用String方法，得到字符串“3”；第二个对象返回的还是toString方法的值（\"[object Object]\"），这次直接就是字符串；第三个对象表示toString方法先于valueOf方法执行。\n\n\n> ** 转自：** (阮一峰)[http://javascript.ruanyifeng.com/grammar/string.html]","slug":"好好学学String","published":1,"updated":"2016-02-03T08:10:14.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5eyf000f703vkugxa669"},{"title":"严格模式","date":"2016-01-21T05:55:51.000Z","comments":1,"_content":"# 概述\nECMAScript 5 的严格模式是JavaScript中的一种限制性更强的变种方式。严格模式不是一个子集：它在语义上与正常代码有着明显的差异。不支持严格模式的浏览器与同支持严格模式的浏览器行为上也不一样， 所以不要在未经严格模式特性测试情况下使用严格模式。严格模式可以与非严格模式共存，所以脚本可以逐渐的选择性加入严格模式。\n支持情况：IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱。（github上面好多项目都是用的严格模式）\n严格模式在语义上与正常的JavaScript有一些不同。\n* 首先，严格模式会将JavaScript陷阱直接变成明显的错误。\n* 其次，严格模式修正了一些引擎难以优化的错误：同样的代码有些时候严格模式会比非严格模式下更快。\n* 第三，严格模式禁用了一些有可能在未来版本中定义的语法。\n<!--more-->\n# 开启严格模式\n严格模式可以应用到整个script标签或某个别函数中。不要在封闭大括弧（ {} ）内这样做，在这样的上下文中这么做是没有效果的。\n## 为某个script标签开启严格模式\n为整个script标签开启严格模式, 需要在所有语句之前放一个特定语句 `\"use strict\";` （或 `'use strict';`）。\n      // 整个语句都开启严格模式的语法\n      \"use strict\";\n      var v = \"Hi!  I'm a strict mode script!\";\n这种语法存在陷阱，在代码上线前会进行压缩，如果用这种语法，一个js文件是严格模式的脚本另一个是非严格模式的脚本，压缩后合二为一，合并后的脚本代码可能会失去严格模式以正常模式展现。\n>将`\"use strict\"`放在脚本文件的第一行，则整个脚本都将以\"严格模式\"运行。如果这行语句不在第一行，则无效，整个脚本以\"正常模式\"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。\n>\n      ;//有这个分号 就是正常模式，没有这个分号就是严格模式\n      \"use strict\";\n      eval(\"var x; delete x;\"); // !!! 语法错误\n\n## 为某个函数开启严格模式\n      function strict() {\n        // 函数级别严格模式语法\n        'use strict';\n        function nested() {\n          return \"And so am I!\";\n        }\n        return \"Hi!  I'm a strict mode function!  \" + nested();\n      }\n## Chrome中调试严格模式\n我有这么一段代码：\n```javascript\n'use strict'\nname = \"reeoo\";\nconsole.log(name)\n```\n把这段代码直接粘贴到Chrome的控制台中执行，正常情况下应该报错，但是并没有报错。\n{% asset_img stracit.png %}\n很显然，严格模式下变量不适用var声明是不合法的，但是为什么没有报错？这是什么鬼，难道Chrome不支持严格模式？开什么玩笑。。。\n网上搜了一下，原来Chrome的控制台的代码是运行在eval之中的，你没法对eval函数使用严格模式（应该也不完全对，但是具体Chrome做了什么，不得而知），总之要想在Chrome浏览器中对严格模式正常报错，需要在代码外层套一个立即执行函数，或者其它类似的措施。\n```javascript\n(function(){\n    'use strict'\n    name = \"reeoo\";\n    console.log(name) \n})()\n```\n\n# 严格模式有哪些不同？\n* 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;(将问题直接转化为错误,如语法错误或运行时错误)。\n* 提高编译器效率，增加运行速度。\n* 消除代码运行的一些不安全之处，保证代码运行的安全。\n* 为未来新版本的Javascript做好铺垫。\n\n# 代码在严格模式下受到的限制\n## 全局变量显式声明\n在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n\n      \"use strict\";\n      mistypedVaraible = 17; // 报错，mistypedVaraible未声明\n## 静态绑定\nJavascript语言的一个特点，就是允许\"动态绑定\"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。\n具体来说，涉及以下几个方面。\n### 禁止使用with语句\n因为with语句无法在编译时就确定，属性到底归属哪个对象。\n\n    \"use strict\";\n    var x = 17;\n    with (obj) // !!! 语法错误\n    {\n      // 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？\n      // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\n      x;\n    }\n### 创设eval作用域\n正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。\n严格模式创设了第三种作用域：eval作用域。\n正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。\n严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。\n\n    \"use strict\";\n    eval(\"var testvar = 10\");\n    console.log(testvar);//在严格模式下报错，在非严格模式下 打印 10\n## 禁止删除变量\n严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。\n\n    \"use strict\";\n    var x;\n    delete x; // 语法错误\n\n    eval(\"var x; delete x;\"); // !!! 语法错误\n\n    var o = Object.create(null, {'x': {\n        value: 1,\n        configurable: true\n    }});\n    delete o.x; // 删除成功\n## 增强的安全措施\n### 禁止this关键字指向全局对象，默认值undefined\n\n    function f(){\n    　　return !this;\n    }\n    // 返回false，因为\"this\"指向全局对象，\"!this\"就是false\n    function f(){\n    　　\"use strict\";\n    　　return !this;\n    }\n    // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\n### 禁止在函数内部遍历调用栈\n    function f1() {　　　　\n        \"use strict\";　　　　\n        f1.caller; // 报错 正常模式下f1.caller是最后一个调用f1的函数\n        f1.arguments; // 报错\n        　　\n    }　　\n    f1();\n### 显式报错\nNaN 是一个不可写的全局变量. 在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常\n\n    \"use strict\";\n    NaN = 2;//报错\n正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.defineProperty(o, \"v\", {\n        value: 1,\n        writable: false\n    });　　\n    o.v = 2; // 报错\n严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。\n\n    \"use strict\";\n    　\n    var o = {\n        　get v() {return 1; }　　\n    };　　\n    o.v = 2; // 报错\n严格模式下，对禁止扩展的对象添加新属性，会报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.preventExtensions(o);　　\n    o.v = 1; // 报错\n严格模式下，删除一个不可删除的属性，会报错。\n\n    \"use strict\";　　\n    delete Object.prototype; // 报错\n## 重名错误\n### 对象不能有重名的属性\n正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    var o = {　　　　\n        p: 1,\n        　　　　p: 2　　\n    }; // 语法错误\n### 函数不能有重名的参数\n正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    function f(a, a, b) { // 语法错误\n        　　　　\n        return;　　\n    }\n## 禁止八进制表示法\n正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。\n\n    \"use strict\";　　\n    var n = 0100; // 语法错误\n## eval和arguments对象的限制\n### 赋值和绑定\n首先, 名称 eval 和 arguments 不能通过程序语法被绑定(be bound)或赋值，以下这些尝试都将报错：\n\n    \"use strict\";\n    eval = 17;\n    arguments++;\n    ++eval;\n    var obj = { set p(arguments) { } };\n    var eval;\n    try { } catch (arguments) { }\n    function x(eval) { }\n    function arguments() { }\n    var y = function eval() { };\n    var f = new Function(\"arguments\", \"'use strict'; return 17;\");\n### arguments不再追踪参数的变化\n\n    function f(a) {　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 正常模式为[2,2]\n    　　\n    function f(a) {　　　　\n        \"use strict\";　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 严格模式为[2,1]\n### 禁止使用arguments.callee\n这意味着，你无法在匿名函数内部调用自身了，可以用命名函数表达式解决这个问题。\n\n    \"use strict\";　　\n    var f = function() {\n        return arguments.callee;\n    };　　\n    f(); // 报错\n## 函数必须声明在顶层\n将来Javascript的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n\n    \"use strict\";　　\n    if (true) {　　　　\n        function f() {} // 语法错误\n            　　\n    }　　\n    for (var i = 0; i < 5; i++) {　　　　\n        function f2() {} // 语法错误\n            　　\n    }\n\n## 保留字\n为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n使用这些词作为变量名将会报错。此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。\n\n# 向严格模式过度\n## 逐步过渡\n严格模式被仔细设计过，因此可以逐渐地进行迁移。你可以分别改变各个文件，甚至以函数级的粒度迁移至严格模式。\n## 过程\n如果代码中使用\"use strict\"开启了严格模式,则下面的情况都会在脚本运行之前抛出`SyntaxError`异常:\n### 语法错误\n\n* 八进制语法:var n = 023和var s = \"\\047\"\n* with语句\n* 使用delete删除一个变量名(而不是属性名):delete myVariable\n* 使用eval或arguments作为变量名或函数名\n* 使用未来保留字(也许会在ECMAScript 6中使用):implements, interface, let, package, private, protected, public, static,和yield作为变量名或函数名\n* 在语句块中使用函数声明:if(a<b){ function f(){} }\n* 其他错误:\n* * 对象子面量中使用两个相同的属性名:{a: 1, b: 3, a: 7}\n* * 函数形参中使用两个相同的参数名:function f(a, b, b){}\n\n这些错误是有利的，因为可以揭示简陋的错误和坏的实践，这些错误会在代码运行前被抛出。\n\n### 运行时错误\nJavaScript曾经会在一些上下文的某些情况中静默的失败，严格模式会在这些情况下抛出错误。如果你的代码包含这样的场景，请务必测试以确保没有代码受到影响。再说一次，严格模式是可以设置在代码粒度下的。\n\n1. 给一个未声明的变量赋值\n2. 改变一个全局对象的值可能会造成不可预期的后果。如果你真的想设置一个全局对象的值，把他作为一个参数并且明确的把它作为一个属性。\n          var global = this; // in the top-level context, \"this\" always refers the global object\n          function f() {\n              \"use strict\";\n              var a = 12;\n              global.b = a + x * 35;\n          }\n          f();\n\n3. 尝试删除一个不可配置的属性。\n          \"use strict\";\n          delete Object.prototype; // error!\n   在非严格模式中,这样的代码只会静默失败,这样可能会导致用户误以为删除操作成功了.\n\n4. `arguments`对象和函数属性\n\n在严格模式下,访问`arguments.callee`, `arguments.caller`, `anyFunction.caller`以及`anyFunction.arguments`都会抛出异常.唯一合法的使用应该是在其中命名一个函数并且重用之\n\n### 语义差异\n1. 函数调用中的this\n在普通的函数调用f()中，this的值会指向全局对象。在严格模式中，this的值会指向undefined。当函数通过call和apply调用时，如果传入的thisvalue参数是一个null和undefined除外的原始值(字符串，数字，布尔值)，则this的值会成为那个原始值对应的包装对象，如果thisvalue参数的值是undefined或null，则this的值会指向全局对象。在严格模式中，this的值就是thisvalue参数的值，没有任何类型转换。\n2. arguments对象属性不与对应的形参变量同步更新\n在非严格模式中，修改arguments对象中某个索引属性的值，和这个属性对应的形参变量的值也会同时变化，反之亦然.这会让JavaScript的代码混淆引擎让代码变得更难读和理解。在严格模式中arguments 对象会以形参变量的拷贝的形式被创建和初始化，因此 arguments 对象的改变不会影响形参。\n3. eval相关的区别\n在严格模式中，eval不会在当前的作用域内创建新的变量。另外，传入eval的字符串参数也会按照严格模式来解析。你需要全面测试来确保没有代码收到影响。另外，如果你并不是为了解决一个非常实际的解决方案中，尽量不要使用eval。\n\n## 严格中立的代码\n迁移严格代码至严格模式的一个潜在消极面是，在遗留的老版本浏览器上，由于没有实现严格模式，javascript语义可能会有所不同。在一些罕见的机会下（比如差劲的关联关系或者代码最小化），你的代码可能不能按照你书写或者测试里的模式那样运行。这里有一些让你的代码保持中立的规范：\n1. 按照严格模式书写你的代码，并且确保你的代码不会发生仅仅在严格模式下发生的错误（比如上文所说的运行时错误）。\n2. 原理语义的歧义：\n * eval: 仅仅在你知道你在干什么的情况下使用它\n * arguments: 总是通过他们的名字访问函数的参数，或者作为参数对象的拷贝来使用: `var args = Array.prototype.slice.call(arguments)`，并且这样的代码应该在你的函数第一行\n * this: 只在它指向你之前创建的对象的情况下使用 this  \n\n>摘自：[MDN-严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)\n>摘自：[MDN-向严格模式过渡](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode)\n","source":"_posts/严格模式-2016-01-21.md","raw":"title: 严格模式\ndate: 2016-01-21 13:55:51\ntags:\n- jQuery\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# 概述\nECMAScript 5 的严格模式是JavaScript中的一种限制性更强的变种方式。严格模式不是一个子集：它在语义上与正常代码有着明显的差异。不支持严格模式的浏览器与同支持严格模式的浏览器行为上也不一样， 所以不要在未经严格模式特性测试情况下使用严格模式。严格模式可以与非严格模式共存，所以脚本可以逐渐的选择性加入严格模式。\n支持情况：IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱。（github上面好多项目都是用的严格模式）\n严格模式在语义上与正常的JavaScript有一些不同。\n* 首先，严格模式会将JavaScript陷阱直接变成明显的错误。\n* 其次，严格模式修正了一些引擎难以优化的错误：同样的代码有些时候严格模式会比非严格模式下更快。\n* 第三，严格模式禁用了一些有可能在未来版本中定义的语法。\n<!--more-->\n# 开启严格模式\n严格模式可以应用到整个script标签或某个别函数中。不要在封闭大括弧（ {} ）内这样做，在这样的上下文中这么做是没有效果的。\n## 为某个script标签开启严格模式\n为整个script标签开启严格模式, 需要在所有语句之前放一个特定语句 `\"use strict\";` （或 `'use strict';`）。\n      // 整个语句都开启严格模式的语法\n      \"use strict\";\n      var v = \"Hi!  I'm a strict mode script!\";\n这种语法存在陷阱，在代码上线前会进行压缩，如果用这种语法，一个js文件是严格模式的脚本另一个是非严格模式的脚本，压缩后合二为一，合并后的脚本代码可能会失去严格模式以正常模式展现。\n>将`\"use strict\"`放在脚本文件的第一行，则整个脚本都将以\"严格模式\"运行。如果这行语句不在第一行，则无效，整个脚本以\"正常模式\"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。\n>\n      ;//有这个分号 就是正常模式，没有这个分号就是严格模式\n      \"use strict\";\n      eval(\"var x; delete x;\"); // !!! 语法错误\n\n## 为某个函数开启严格模式\n      function strict() {\n        // 函数级别严格模式语法\n        'use strict';\n        function nested() {\n          return \"And so am I!\";\n        }\n        return \"Hi!  I'm a strict mode function!  \" + nested();\n      }\n## Chrome中调试严格模式\n我有这么一段代码：\n```javascript\n'use strict'\nname = \"reeoo\";\nconsole.log(name)\n```\n把这段代码直接粘贴到Chrome的控制台中执行，正常情况下应该报错，但是并没有报错。\n{% asset_img stracit.png %}\n很显然，严格模式下变量不适用var声明是不合法的，但是为什么没有报错？这是什么鬼，难道Chrome不支持严格模式？开什么玩笑。。。\n网上搜了一下，原来Chrome的控制台的代码是运行在eval之中的，你没法对eval函数使用严格模式（应该也不完全对，但是具体Chrome做了什么，不得而知），总之要想在Chrome浏览器中对严格模式正常报错，需要在代码外层套一个立即执行函数，或者其它类似的措施。\n```javascript\n(function(){\n    'use strict'\n    name = \"reeoo\";\n    console.log(name) \n})()\n```\n\n# 严格模式有哪些不同？\n* 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;(将问题直接转化为错误,如语法错误或运行时错误)。\n* 提高编译器效率，增加运行速度。\n* 消除代码运行的一些不安全之处，保证代码运行的安全。\n* 为未来新版本的Javascript做好铺垫。\n\n# 代码在严格模式下受到的限制\n## 全局变量显式声明\n在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n\n      \"use strict\";\n      mistypedVaraible = 17; // 报错，mistypedVaraible未声明\n## 静态绑定\nJavascript语言的一个特点，就是允许\"动态绑定\"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。\n具体来说，涉及以下几个方面。\n### 禁止使用with语句\n因为with语句无法在编译时就确定，属性到底归属哪个对象。\n\n    \"use strict\";\n    var x = 17;\n    with (obj) // !!! 语法错误\n    {\n      // 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？\n      // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\n      x;\n    }\n### 创设eval作用域\n正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。\n严格模式创设了第三种作用域：eval作用域。\n正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。\n严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。\n\n    \"use strict\";\n    eval(\"var testvar = 10\");\n    console.log(testvar);//在严格模式下报错，在非严格模式下 打印 10\n## 禁止删除变量\n严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。\n\n    \"use strict\";\n    var x;\n    delete x; // 语法错误\n\n    eval(\"var x; delete x;\"); // !!! 语法错误\n\n    var o = Object.create(null, {'x': {\n        value: 1,\n        configurable: true\n    }});\n    delete o.x; // 删除成功\n## 增强的安全措施\n### 禁止this关键字指向全局对象，默认值undefined\n\n    function f(){\n    　　return !this;\n    }\n    // 返回false，因为\"this\"指向全局对象，\"!this\"就是false\n    function f(){\n    　　\"use strict\";\n    　　return !this;\n    }\n    // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\n### 禁止在函数内部遍历调用栈\n    function f1() {　　　　\n        \"use strict\";　　　　\n        f1.caller; // 报错 正常模式下f1.caller是最后一个调用f1的函数\n        f1.arguments; // 报错\n        　　\n    }　　\n    f1();\n### 显式报错\nNaN 是一个不可写的全局变量. 在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常\n\n    \"use strict\";\n    NaN = 2;//报错\n正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.defineProperty(o, \"v\", {\n        value: 1,\n        writable: false\n    });　　\n    o.v = 2; // 报错\n严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。\n\n    \"use strict\";\n    　\n    var o = {\n        　get v() {return 1; }　　\n    };　　\n    o.v = 2; // 报错\n严格模式下，对禁止扩展的对象添加新属性，会报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.preventExtensions(o);　　\n    o.v = 1; // 报错\n严格模式下，删除一个不可删除的属性，会报错。\n\n    \"use strict\";　　\n    delete Object.prototype; // 报错\n## 重名错误\n### 对象不能有重名的属性\n正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    var o = {　　　　\n        p: 1,\n        　　　　p: 2　　\n    }; // 语法错误\n### 函数不能有重名的参数\n正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    function f(a, a, b) { // 语法错误\n        　　　　\n        return;　　\n    }\n## 禁止八进制表示法\n正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。\n\n    \"use strict\";　　\n    var n = 0100; // 语法错误\n## eval和arguments对象的限制\n### 赋值和绑定\n首先, 名称 eval 和 arguments 不能通过程序语法被绑定(be bound)或赋值，以下这些尝试都将报错：\n\n    \"use strict\";\n    eval = 17;\n    arguments++;\n    ++eval;\n    var obj = { set p(arguments) { } };\n    var eval;\n    try { } catch (arguments) { }\n    function x(eval) { }\n    function arguments() { }\n    var y = function eval() { };\n    var f = new Function(\"arguments\", \"'use strict'; return 17;\");\n### arguments不再追踪参数的变化\n\n    function f(a) {　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 正常模式为[2,2]\n    　　\n    function f(a) {　　　　\n        \"use strict\";　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 严格模式为[2,1]\n### 禁止使用arguments.callee\n这意味着，你无法在匿名函数内部调用自身了，可以用命名函数表达式解决这个问题。\n\n    \"use strict\";　　\n    var f = function() {\n        return arguments.callee;\n    };　　\n    f(); // 报错\n## 函数必须声明在顶层\n将来Javascript的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n\n    \"use strict\";　　\n    if (true) {　　　　\n        function f() {} // 语法错误\n            　　\n    }　　\n    for (var i = 0; i < 5; i++) {　　　　\n        function f2() {} // 语法错误\n            　　\n    }\n\n## 保留字\n为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n使用这些词作为变量名将会报错。此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。\n\n# 向严格模式过度\n## 逐步过渡\n严格模式被仔细设计过，因此可以逐渐地进行迁移。你可以分别改变各个文件，甚至以函数级的粒度迁移至严格模式。\n## 过程\n如果代码中使用\"use strict\"开启了严格模式,则下面的情况都会在脚本运行之前抛出`SyntaxError`异常:\n### 语法错误\n\n* 八进制语法:var n = 023和var s = \"\\047\"\n* with语句\n* 使用delete删除一个变量名(而不是属性名):delete myVariable\n* 使用eval或arguments作为变量名或函数名\n* 使用未来保留字(也许会在ECMAScript 6中使用):implements, interface, let, package, private, protected, public, static,和yield作为变量名或函数名\n* 在语句块中使用函数声明:if(a<b){ function f(){} }\n* 其他错误:\n* * 对象子面量中使用两个相同的属性名:{a: 1, b: 3, a: 7}\n* * 函数形参中使用两个相同的参数名:function f(a, b, b){}\n\n这些错误是有利的，因为可以揭示简陋的错误和坏的实践，这些错误会在代码运行前被抛出。\n\n### 运行时错误\nJavaScript曾经会在一些上下文的某些情况中静默的失败，严格模式会在这些情况下抛出错误。如果你的代码包含这样的场景，请务必测试以确保没有代码受到影响。再说一次，严格模式是可以设置在代码粒度下的。\n\n1. 给一个未声明的变量赋值\n2. 改变一个全局对象的值可能会造成不可预期的后果。如果你真的想设置一个全局对象的值，把他作为一个参数并且明确的把它作为一个属性。\n          var global = this; // in the top-level context, \"this\" always refers the global object\n          function f() {\n              \"use strict\";\n              var a = 12;\n              global.b = a + x * 35;\n          }\n          f();\n\n3. 尝试删除一个不可配置的属性。\n          \"use strict\";\n          delete Object.prototype; // error!\n   在非严格模式中,这样的代码只会静默失败,这样可能会导致用户误以为删除操作成功了.\n\n4. `arguments`对象和函数属性\n\n在严格模式下,访问`arguments.callee`, `arguments.caller`, `anyFunction.caller`以及`anyFunction.arguments`都会抛出异常.唯一合法的使用应该是在其中命名一个函数并且重用之\n\n### 语义差异\n1. 函数调用中的this\n在普通的函数调用f()中，this的值会指向全局对象。在严格模式中，this的值会指向undefined。当函数通过call和apply调用时，如果传入的thisvalue参数是一个null和undefined除外的原始值(字符串，数字，布尔值)，则this的值会成为那个原始值对应的包装对象，如果thisvalue参数的值是undefined或null，则this的值会指向全局对象。在严格模式中，this的值就是thisvalue参数的值，没有任何类型转换。\n2. arguments对象属性不与对应的形参变量同步更新\n在非严格模式中，修改arguments对象中某个索引属性的值，和这个属性对应的形参变量的值也会同时变化，反之亦然.这会让JavaScript的代码混淆引擎让代码变得更难读和理解。在严格模式中arguments 对象会以形参变量的拷贝的形式被创建和初始化，因此 arguments 对象的改变不会影响形参。\n3. eval相关的区别\n在严格模式中，eval不会在当前的作用域内创建新的变量。另外，传入eval的字符串参数也会按照严格模式来解析。你需要全面测试来确保没有代码收到影响。另外，如果你并不是为了解决一个非常实际的解决方案中，尽量不要使用eval。\n\n## 严格中立的代码\n迁移严格代码至严格模式的一个潜在消极面是，在遗留的老版本浏览器上，由于没有实现严格模式，javascript语义可能会有所不同。在一些罕见的机会下（比如差劲的关联关系或者代码最小化），你的代码可能不能按照你书写或者测试里的模式那样运行。这里有一些让你的代码保持中立的规范：\n1. 按照严格模式书写你的代码，并且确保你的代码不会发生仅仅在严格模式下发生的错误（比如上文所说的运行时错误）。\n2. 原理语义的歧义：\n * eval: 仅仅在你知道你在干什么的情况下使用它\n * arguments: 总是通过他们的名字访问函数的参数，或者作为参数对象的拷贝来使用: `var args = Array.prototype.slice.call(arguments)`，并且这样的代码应该在你的函数第一行\n * this: 只在它指向你之前创建的对象的情况下使用 this  \n\n>摘自：[MDN-严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)\n>摘自：[MDN-向严格模式过渡](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode)\n","slug":"严格模式","published":1,"updated":"2016-02-03T03:59:13.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5eys000i703v2retavfp"},{"title":"webkit的预加载扫描器","date":"2016-01-19T12:33:09.000Z","comments":1,"_content":"在WebKit中，预加载扫描器指的是一个副解析器，当HTML主解析器被一个同步的script标签阻塞时，预加载扫描器就会启动.然后，它会马上找出接下来即将需要获取的资源(比如样式表，脚本，图片等资源)的URL，然后尽可能早的发起网络请求，而不用等到主解析器恢复运行，从而提高了整体的加载时间。那么，除了HTML文件中的依赖资源，还有样式表中的呢?幸运的是，WebKit已经有了一个叫CSS预加载扫描器的东西了。\n<!--more-->\n在WebKit实现符合HTML5标准的解析器的时候，预加载扫描器被分成了两部分。其中大部分代码分出来成为了HTML预加载扫描器，剩下的一小部分成为了独立的CSS预加载扫描器。CSS预加载扫描器的任务是扫描并尽早加载样式表(且只能是style标签中内联的样式表)中的外部资源。目前，它只能扫描到@import规则中用到的外部资源。\n\n让我们看看下面这个示例，在这个代码片段中(只为演示使用，代码并不符合最佳实践)，有一个script标签和一个style标签:\n\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <script>\n    setTimeout(function () {\n        document.title = document.title\n    }， 1000);\n    </script>\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <style>\n    @import url(\"another-style.css\");\n    body {\n        background-color: white\n    }\n    </style>\n\n当执行到那个同步的script标签时，WebKit解析器会就会启动CSS预加载扫描器.预加载扫描器会快速的找到@import后面的URL，然后下载这个another-style.css文件。\n\nCSS预加载扫描器是非常简单的，因为它不需要解析所有的CSS语法，其中还有一个专门的代码优化，就是如果发现没有@import，扫描器会尽快跳出这个样式表，这样就能在CSS文件很大的时候节约对CPU的消耗。\n\n很多人不推荐使用@import(比如Steve Souder的不要使用@import一文)。随着现在以及未来对浏览器引擎的不断改进，这条最佳实践应该时不时的被重新考量了。当然，我并不推荐在你的网站上到处乱用@import.使用一些调试工具来分析页面的网络性能，然后你就能得出一个明智的决定。\n\n**注:**特别感谢Google的Ilya Grigorik帮我审查这篇文章。\n\n引自：[紫云飞](http://www.cnblogs.com/ziyunfei/archive/2013/04/11/3014430.html?utm_source=tuicool&utm_medium=referral)\n","source":"_posts/webkit的预加载扫描器-2016-01-19.md","raw":"title: webkit的预加载扫描器\ndate: 2016-01-19 20:33:09\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n在WebKit中，预加载扫描器指的是一个副解析器，当HTML主解析器被一个同步的script标签阻塞时，预加载扫描器就会启动.然后，它会马上找出接下来即将需要获取的资源(比如样式表，脚本，图片等资源)的URL，然后尽可能早的发起网络请求，而不用等到主解析器恢复运行，从而提高了整体的加载时间。那么，除了HTML文件中的依赖资源，还有样式表中的呢?幸运的是，WebKit已经有了一个叫CSS预加载扫描器的东西了。\n<!--more-->\n在WebKit实现符合HTML5标准的解析器的时候，预加载扫描器被分成了两部分。其中大部分代码分出来成为了HTML预加载扫描器，剩下的一小部分成为了独立的CSS预加载扫描器。CSS预加载扫描器的任务是扫描并尽早加载样式表(且只能是style标签中内联的样式表)中的外部资源。目前，它只能扫描到@import规则中用到的外部资源。\n\n让我们看看下面这个示例，在这个代码片段中(只为演示使用，代码并不符合最佳实践)，有一个script标签和一个style标签:\n\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <script>\n    setTimeout(function () {\n        document.title = document.title\n    }， 1000);\n    </script>\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <style>\n    @import url(\"another-style.css\");\n    body {\n        background-color: white\n    }\n    </style>\n\n当执行到那个同步的script标签时，WebKit解析器会就会启动CSS预加载扫描器.预加载扫描器会快速的找到@import后面的URL，然后下载这个another-style.css文件。\n\nCSS预加载扫描器是非常简单的，因为它不需要解析所有的CSS语法，其中还有一个专门的代码优化，就是如果发现没有@import，扫描器会尽快跳出这个样式表，这样就能在CSS文件很大的时候节约对CPU的消耗。\n\n很多人不推荐使用@import(比如Steve Souder的不要使用@import一文)。随着现在以及未来对浏览器引擎的不断改进，这条最佳实践应该时不时的被重新考量了。当然，我并不推荐在你的网站上到处乱用@import.使用一些调试工具来分析页面的网络性能，然后你就能得出一个明智的决定。\n\n**注:**特别感谢Google的Ilya Grigorik帮我审查这篇文章。\n\n引自：[紫云飞](http://www.cnblogs.com/ziyunfei/archive/2013/04/11/3014430.html?utm_source=tuicool&utm_medium=referral)\n","slug":"webkit的预加载扫描器","published":1,"updated":"2016-01-19T13:00:03.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5ez1000m703vllb7fg9v"},{"title":"javascript:void(0);到底是什么鬼?","date":"2016-01-29T07:03:57.000Z","comments":1,"_content":"## 疑问？\n我们经常看见`<a href=\"javascript:void(0);\">超链接</a>`的`href`里填写`javascript:void(0);`，取消点击跳转，可是为啥这么搞？\n<!--more-->\n## 规范是这么说的\n> The void Operator\n> \n> The production UnaryExpression : void UnaryExpression is evaluated as follows:\n \n> * Let expr be the result of evaluating UnaryExpression.\n> * Call GetValue(expr).\n> * Return undefined.\n> NOTE: GetValue must be called even though its value is not used because it may have observable side-effects\n\n搬译一下：\n\n> void操作符\n\n> 产生式 UnaryExpression : void UnaryExpression 按如下流程解释:\n\n> * 令 expr 为解释执行UnaryExpression的结果。\n> * 调用 GetValue(expr).\n> * 返回 undefined.\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n重点在于：无论void后的表达式是什么，void操作符都会返回undefined。\n\n## 用处\n### 替换`undefined`\n\n因为undefined在javascript中不是保留字。换言之，你可以写出：\n\n    {% codeblock lang:javascript %}\n    function joke() {\n        var undefined = \"hello world\";\n        console.log(undefined); //会输出\"hello world\"\n    }\n    joke()\n    {% endcodeblock %}\n对的，你可以在一个函数上下文内以undefined做为变量名，于是在这个上下文写的代码便只能通过从全局作用域来取到undefined，如：\n    \n    {% codeblock lang:javascript %}\n    window.undefined //浏览器环境\n    GLOBAL.undefined //Node环境\n    {% endcodeblock %}\n    \n但要注意的是，即便window, GLOBAL仍然可以在函数上下文被定义，故从window/GLOBAL上取undefined并不是100%可靠的做法。如：\n\n    {% codeblock lang:javascript %}\n    function x() {\n       var undefined = 'hello world',\n           f = {},\n           window = {\n               'undefined': 'joke'\n           };\n       console.log(undefined);// hello world\n       console.log(window.undefined); //joke\n       console.log(f.a === undefined); //false\n       console.log(f.a === void 0); //true\n    }\n    x();\n    {% endcodeblock %}\n\n于是，采用void方式获取undefined便成了通用准则。如underscore.js里的isUndefined便是这么写的：\n\n    {% codeblock lang:javascript %}\n    _.isUndefined = function(obj) {\n        return obj === void 0;\n    }\n    {% endcodeblock %}\n    \n除了采用void能保证取到undefined值以外，还有其它方法吗？有的，还有一种方式是通过函数调用。如AngularJS的源码里就用这样的方式：\n    \n    {% codeblock lang:javascript %}\n    (function(window, document, undefined) {\n        //.....\n    })(window, document);\n    {% endcodeblock %}\n\n通过不传参数，确保了undefined参数的值是一个undefined。\n\n### 填充a标签href、image标签的src\n\n* `<a href=\"javascript:void(0)\">test</a>`\n* `<image src=\"javascript:void(0)\">` \n\n## GetValue 是什么鬼？\n\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n(关于js中void，既然返回永远是undefined，那么GetValue有啥用？)[https://www.zhihu.com/question/22210634]\n\n    {% codeblock lang:javascript %}\n    var happiness = 10;\n    var girl = {\n        get whenMarry() {\n            happiness--;\n            return 1/0; //Infinity\n        },\n        get happiness() {\n            return happiness;\n        }\n    };\n    \n    console.log(girl.whenMarry); //调用了whenMarry的get方法\n    console.log(girl.happiness); // 9\n    \n    void girl.whenMarry; //调用了whenMarry的get方法\n    console.log(girl.happiness); // 8\n    \n    delete girl.whenMarry; //没有调用whenMarry的get方法\n    console.log(girl.happiness); //还是8\n    {% endcodeblock %}\n    \n上述代码定义了一个大龄文艺女青年，每被问到什么时候结婚呀(whenMarry)，happiness都会减1。从执行情况可以看出，无论是普通访问girl.whenMarry，还是void girl.whenMarry都会使她的happiness--。而如果把void换成delete操作符写成delete girl.whenMarry，她的happiness就不会减了，因为delete操作符不会对girl.whenMarry求值。\n\n## 总结\nvoid(0) 有如下作用：\n\n* 通过采用void 0取undefined比采用字面上的undefined更靠谱更安全，应该优先采用void 0这种方式。\n* 填充<a>的href确保点击时不会产生页面跳转; 填充<image>的src，确保不会向服务器发出垃圾请求。\n\n转自：[谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)","source":"_posts/void-0-2016-01-29.md","raw":"title: javascript:void(0);到底是什么鬼?\ndate: 2016-01-29 15:03:57\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n## 疑问？\n我们经常看见`<a href=\"javascript:void(0);\">超链接</a>`的`href`里填写`javascript:void(0);`，取消点击跳转，可是为啥这么搞？\n<!--more-->\n## 规范是这么说的\n> The void Operator\n> \n> The production UnaryExpression : void UnaryExpression is evaluated as follows:\n \n> * Let expr be the result of evaluating UnaryExpression.\n> * Call GetValue(expr).\n> * Return undefined.\n> NOTE: GetValue must be called even though its value is not used because it may have observable side-effects\n\n搬译一下：\n\n> void操作符\n\n> 产生式 UnaryExpression : void UnaryExpression 按如下流程解释:\n\n> * 令 expr 为解释执行UnaryExpression的结果。\n> * 调用 GetValue(expr).\n> * 返回 undefined.\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n重点在于：无论void后的表达式是什么，void操作符都会返回undefined。\n\n## 用处\n### 替换`undefined`\n\n因为undefined在javascript中不是保留字。换言之，你可以写出：\n\n    {% codeblock lang:javascript %}\n    function joke() {\n        var undefined = \"hello world\";\n        console.log(undefined); //会输出\"hello world\"\n    }\n    joke()\n    {% endcodeblock %}\n对的，你可以在一个函数上下文内以undefined做为变量名，于是在这个上下文写的代码便只能通过从全局作用域来取到undefined，如：\n    \n    {% codeblock lang:javascript %}\n    window.undefined //浏览器环境\n    GLOBAL.undefined //Node环境\n    {% endcodeblock %}\n    \n但要注意的是，即便window, GLOBAL仍然可以在函数上下文被定义，故从window/GLOBAL上取undefined并不是100%可靠的做法。如：\n\n    {% codeblock lang:javascript %}\n    function x() {\n       var undefined = 'hello world',\n           f = {},\n           window = {\n               'undefined': 'joke'\n           };\n       console.log(undefined);// hello world\n       console.log(window.undefined); //joke\n       console.log(f.a === undefined); //false\n       console.log(f.a === void 0); //true\n    }\n    x();\n    {% endcodeblock %}\n\n于是，采用void方式获取undefined便成了通用准则。如underscore.js里的isUndefined便是这么写的：\n\n    {% codeblock lang:javascript %}\n    _.isUndefined = function(obj) {\n        return obj === void 0;\n    }\n    {% endcodeblock %}\n    \n除了采用void能保证取到undefined值以外，还有其它方法吗？有的，还有一种方式是通过函数调用。如AngularJS的源码里就用这样的方式：\n    \n    {% codeblock lang:javascript %}\n    (function(window, document, undefined) {\n        //.....\n    })(window, document);\n    {% endcodeblock %}\n\n通过不传参数，确保了undefined参数的值是一个undefined。\n\n### 填充a标签href、image标签的src\n\n* `<a href=\"javascript:void(0)\">test</a>`\n* `<image src=\"javascript:void(0)\">` \n\n## GetValue 是什么鬼？\n\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n(关于js中void，既然返回永远是undefined，那么GetValue有啥用？)[https://www.zhihu.com/question/22210634]\n\n    {% codeblock lang:javascript %}\n    var happiness = 10;\n    var girl = {\n        get whenMarry() {\n            happiness--;\n            return 1/0; //Infinity\n        },\n        get happiness() {\n            return happiness;\n        }\n    };\n    \n    console.log(girl.whenMarry); //调用了whenMarry的get方法\n    console.log(girl.happiness); // 9\n    \n    void girl.whenMarry; //调用了whenMarry的get方法\n    console.log(girl.happiness); // 8\n    \n    delete girl.whenMarry; //没有调用whenMarry的get方法\n    console.log(girl.happiness); //还是8\n    {% endcodeblock %}\n    \n上述代码定义了一个大龄文艺女青年，每被问到什么时候结婚呀(whenMarry)，happiness都会减1。从执行情况可以看出，无论是普通访问girl.whenMarry，还是void girl.whenMarry都会使她的happiness--。而如果把void换成delete操作符写成delete girl.whenMarry，她的happiness就不会减了，因为delete操作符不会对girl.whenMarry求值。\n\n## 总结\nvoid(0) 有如下作用：\n\n* 通过采用void 0取undefined比采用字面上的undefined更靠谱更安全，应该优先采用void 0这种方式。\n* 填充<a>的href确保点击时不会产生页面跳转; 填充<image>的src，确保不会向服务器发出垃圾请求。\n\n转自：[谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)","slug":"void-0","published":1,"updated":"2016-01-29T07:40:34.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5ez5000p703veesp2h8q"},{"title":"ECMAScrip中的对象存取器:getter和setter","date":"2016-01-21T09:34:17.000Z","comments":1,"_content":"显然这是一个无关IE（高级IE除外）的话题，尽管如此，有兴趣的同学还是一起来认识一下ECMAScript5标准中getter和setter的实现。在一个对象中，操作其中的属性或方法，通常运用最多的就是读（引用）和写了，譬如说o.get，这就是一个读的操作，而o.set = 1则是一个写的操作。事实上在除ie外最新主流浏览器的实现中，任何一个对象的键值都可以被getter和setter方法所取代，这被称之为“存取器属性”。\n<!--more-->\n毫无疑问，getter负责查询值，它不带任何参数，setter则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的return都是无效的。和普通属性不同的是，存储器属性在只声明了get或set时，对于读和写是两者不可兼得的，当它只拥有了getter方法，那么它仅仅只读，同样的，当它只有setter方法，那么您读到的永远都是undefined。如何声明对象存储器属性呢？ 最快捷的途径就是利用对象字面量的语法来写了，请看下述一段代码：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            return 'man';\n        }\n    };\n    //显然这是不允许的，因为贤心并不希望外界去改变他是男性的事实，所以对于sex只设置了只读功能\n    oo.sex = 'woman';//在严格模式下报错。\n    console.log(oo.sex); //结果依然是man\n有意思的是，这颠覆了我们以往的理解，就是在方法定义时并未用function关键字。事实上这里的get或set，你可以理解为两种不同状态下的function：包容的一面（写），安全的一面（读），当一种整体被肢解为不同的形态，意味着我们可能不再需要在表现形式上遵循传统，所以我们并没有使用冒号将键和值分开。那么，继续上面的例子。你将如何在存储器属性的基础上变得读写兼备呢，也许下面的一段会给你带来答案：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            if(this.sexx){\n                return this.sexx;\n            }else{\n                return 'man';\n            }\n        }, set sex(val){\n            this.sexx = val;\n        }\n    };\n    //噢，他如此包容，乃至于人们改变他的性别，他也接受\n    oo.sex = 'woman';\n    console.log(oo.sex); //结果woman\n\n或许你会觉得这是多此一举的，因为我们完全可以忽视get和set，直接让sex方法具备两种权限。 但之所以我们将get和set单独拿出来，是为了更加清晰地理解ECMAScript5对javascript对象键值操作中，一个更为严谨的诠释。 当然，在IE污染的中国，新型的主流技术总是显得格格不入，在实际的项目开发中，也许你永远不会用到get和set，但谁又能保证以后不会呢……\n\n摘自：[贤心博客](http://sentsin.com/web/20.html)\n","source":"_posts/ECMAScrip中的对象存取器-getter和setter-2016-01-21.md","raw":"title: 'ECMAScrip中的对象存取器:getter和setter'\ndate: 2016-01-21 17:34:17\ntags:\n- JavaScript\ncomments: true\n---\n显然这是一个无关IE（高级IE除外）的话题，尽管如此，有兴趣的同学还是一起来认识一下ECMAScript5标准中getter和setter的实现。在一个对象中，操作其中的属性或方法，通常运用最多的就是读（引用）和写了，譬如说o.get，这就是一个读的操作，而o.set = 1则是一个写的操作。事实上在除ie外最新主流浏览器的实现中，任何一个对象的键值都可以被getter和setter方法所取代，这被称之为“存取器属性”。\n<!--more-->\n毫无疑问，getter负责查询值，它不带任何参数，setter则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的return都是无效的。和普通属性不同的是，存储器属性在只声明了get或set时，对于读和写是两者不可兼得的，当它只拥有了getter方法，那么它仅仅只读，同样的，当它只有setter方法，那么您读到的永远都是undefined。如何声明对象存储器属性呢？ 最快捷的途径就是利用对象字面量的语法来写了，请看下述一段代码：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            return 'man';\n        }\n    };\n    //显然这是不允许的，因为贤心并不希望外界去改变他是男性的事实，所以对于sex只设置了只读功能\n    oo.sex = 'woman';//在严格模式下报错。\n    console.log(oo.sex); //结果依然是man\n有意思的是，这颠覆了我们以往的理解，就是在方法定义时并未用function关键字。事实上这里的get或set，你可以理解为两种不同状态下的function：包容的一面（写），安全的一面（读），当一种整体被肢解为不同的形态，意味着我们可能不再需要在表现形式上遵循传统，所以我们并没有使用冒号将键和值分开。那么，继续上面的例子。你将如何在存储器属性的基础上变得读写兼备呢，也许下面的一段会给你带来答案：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            if(this.sexx){\n                return this.sexx;\n            }else{\n                return 'man';\n            }\n        }, set sex(val){\n            this.sexx = val;\n        }\n    };\n    //噢，他如此包容，乃至于人们改变他的性别，他也接受\n    oo.sex = 'woman';\n    console.log(oo.sex); //结果woman\n\n或许你会觉得这是多此一举的，因为我们完全可以忽视get和set，直接让sex方法具备两种权限。 但之所以我们将get和set单独拿出来，是为了更加清晰地理解ECMAScript5对javascript对象键值操作中，一个更为严谨的诠释。 当然，在IE污染的中国，新型的主流技术总是显得格格不入，在实际的项目开发中，也许你永远不会用到get和set，但谁又能保证以后不会呢……\n\n摘自：[贤心博客](http://sentsin.com/web/20.html)\n","slug":"ECMAScrip中的对象存取器-getter和setter","published":1,"updated":"2016-01-21T09:37:50.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5ezb000s703voklcdhai"},{"title":"onload vs DOMContentLoaded","date":"2016-01-08T02:27:11.000Z","comments":1,"_content":"* `$(document).ready(function () { });`\n* `$(function () { });`\n\n以上两行代码的目的和效果都一样———待DOM加载完成之后，执行传入的function函数。\n\n这是我们在页面初始化时经常使用的监听方案，那么他的实际的执行关系时什么样的呢？\n在原生js中是什么样的一种表现？\n<!--more-->\n## 定义\n+ onload:\n当onload事件触发的时候，页面上的所有dom，样式表，脚本，图片，flash，iframe都已经加载完成了。\n+ DOMContentLoaded:\n当DOMContentLoaded事件触发时，仅当dom加载完成，不包括样式表，图片，flash，iframe\n\n光看定义，一目了然，哪个比较适合作为我们判断的标准：图片啊什么的，我们完全可以不用等。\n\n在某些Gecko和Webkit引擎版本的浏览器里面，包括IE8在内，会同时发起多个http的请求并行加载样式表和脚步，但是脚本会等样式表加载完成之后才会被执行，甚至样式表加载之前页面都不会渲染。opera不会，样式表未加载好就可以执行js。\n\n{% asset_img onLoadVSDomContentLoaded.png %}\n\n### 兼容方案\n#### ie8及以下兼容处理方案\nie的一般处理方案 --- `onreadystatechange` 事件。\nhtml加载过程中会有一个document.readyState状态\n五种状态：\n+ 0（未初始化）：还没有send\n+ 1 loading（载入）：正在发送请求\n+ 2 loaded（载入完成）：执行完成，已经接收到全部响应内容\n+ 3 interactive（交互）： 正在解析响应内容\n+ 4 complete（完成）： 响应内容解析完成，客户端可以用了。\n*complete事件和window.onload事件是同时的。*\n\n这就是要监听页面的readystatechange事件，当事件为interactive或者complete时就可以开始做js的事情了。\ndocument.readyState 状态\n如果我们注册 ready 函数的时间点太晚了，页面已经加载完成之后，我们才注册自己的 ready 函数，那就用不着上面的层层检查了，直接看看当前页面的 readyState 就可以了，如果已经是 complete ，那就可以直接执行我们准备注册的 ready 函数了。不过 ChrisS 报告了一个很特别的错误情况，我们需要延迟一下执行。\n>\nsetTimeout 经常被用来做网页上的定时器，允许为它指定一个毫秒数作为间隔执行的时间。当被启动的程序需要在非常短的时间内运行，我们就会给它指定一个很小的时间数，或者需要马上执行的话，我们甚至把这个毫秒数设置为0，但事实上，setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的毫秒数设置为0，被调用的程序也没有马上启动。这个最小的时间间隔是多少呢？这和浏览器及操作系统有关。在John Resig的新书《Javascript忍者的秘密》一书中提到。\n>>Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。\n\n既然规范都是这样写的，那看来使用setTimeout是没办法再把这个最小时间间隔缩短了。这样，通过设置为 1, 我们可以让程序在浏览器支持的最小时间间隔之后执行了。\n\n    if (document.readyState === \"complete\") {\n        // 延迟 1 毫秒之后，执行 ready 函数\n        setTimeout(jQuery.ready, 1);\n    }\n\n#### doScroll 检测法\n但是当页面中带有iframe时，这个readyState状态会挂起一直等待，等待页面的iframe也加载完毕之后再处理，这个过程是我们不想要得，那就有另外一种处理方案。\n>\nMSDN 关于 JScript 的一个方法有段不起眼的话，当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了！\nDiego Perini 在 2007 年的时候，报告了一种检测 IE 是否加载完成的方式，使用 doScroll 方法调用。详细的说明见这里。\n原理是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在本例中每间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。\n\n    (function doScrollCheck() {\n        if (!jQuery.isReady) {  \n            try {\n                // Use the trick by Diego Perini\n                // http://javascript.nwbox.com/IEContentLoaded/\n                top.doScroll(\"left\");\n            } catch (e) {\n                return setTimeout(doScrollCheck, 50);\n            }   \n            // and execute any waiting functions\n            jQuery.ready();\n        }\n    })();\n\n#### jQuery的实现  \n    //全局方法\n    DOMContentLoaded = function() {\n        if ( document.addEventListener ) {\n            document.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n            jQuery.ready();\n        } else if ( document.readyState === \"complete\" ) {\n            // we're here because readyState === \"complete\" in oldIE\n            // which is good enough for us to call the dom ready!\n            document.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n            jQuery.ready();\n        }\n    }\n\n    //入口 jquery实例调用\n    ready: function( fn ) {\n        // Add the callback\n        jQuery.ready.promise().done( fn );\n\n        return this;\n    }\n\n    jQuery.ready.promise = function( obj ) {\n    if ( !readyList ) {\n\n        readyList = jQuery.Deferred();\n\n        // Catch cases where $(document).ready() is called after the browser event has already occurred.\n        // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n        // 当页面加载完了，直接调用ready方法\n        if ( document.readyState === \"complete\" ) {\n            // Handle it asynchronously to allow scripts the opportunity to delay ready\n            setTimeout( jQuery.ready, 1 );\n\n        // Standards-based browsers support DOMContentLoaded\n        } else if ( document.addEventListener ) {\n            // Use the handy event callback\n            document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\n            // A fallback to window.onload, that will always work\n            window.addEventListener( \"load\", jQuery.ready, false );\n\n        // If IE event model is used\n        } else {\n            // Ensure firing before onload, maybe late but safe also for iframes\n            document.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n\n            // A fallback to window.onload, that will always work\n            window.attachEvent( \"onload\", jQuery.ready );\n\n            // If IE and not a frame\n            // continually check to see if the document is ready\n            var top = false;\n\n            try {\n                top = window.frameElement == null && document.documentElement;\n            } catch(e) {}\n\n            if ( top && top.doScroll ) {\n                (function doScrollCheck() {\n                    if ( !jQuery.isReady ) {\n\n                        try {\n                            // Use the trick by Diego Perini\n                            // http://javascript.nwbox.com/IEContentLoaded/\n                            top.doScroll(\"left\");\n                        } catch(e) {\n                            return setTimeout( doScrollCheck, 50 );\n                        }\n\n                        // and execute any waiting functions\n                        jQuery.ready();\n                    }\n                })();\n            }\n        }\n    }\n    return readyList.promise( obj );\n    };\n\n    jQuery.extend({\n        // Is the DOM ready to be used? Set to true once it occurs.\n        isReady: false,\n\n        // A counter to track how many items to wait for before\n        // the ready event fires. See #6781\n        // ready方法执行前需要等待的次数\n        readyWait: 1,\n\n        // Handle when the DOM is ready\n        // 当DOM加载完毕时开始执行ready\n        ready: function( wait ) {\n            // Abort if there are pending holds or we're already ready\n            // 判断页面是否加载完成并且ready方法已经执行\n            // 若传入的参数为true，则--readyWait；否则判断isReady，即ready是否正在执行\n            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n                return;\n            }\n\n            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n            if ( !document.body ) {\n                return setTimeout( jQuery.ready, 1 );\n            }\n\n            // Remember that the DOM is ready\n            jQuery.isReady = true; //指示ready 方法已经被执行\n\n            // If a normal DOM Ready event fired, decrement, and wait if need be\n            // 若readyWait-1后还是大于0，则返回，不执行ready。\n            if ( wait !== true && --jQuery.readyWait > 0 ) {\n                return;\n            }\n\n            // If there are functions bound, to execute\n            readyList.resolveWith( document, [ jQuery ] );\n\n            // Trigger any bound ready events\n            if ( jQuery.fn.trigger ) {\n                // 触发ready方法，然后解除绑定的ready方法。\n                jQuery( document ).trigger(\"ready\").off(\"ready\");\n            }\n        }\n    });\n根据以上代码可见，最终DOMContented事件执行的，其实是jQUery.ready()这个工具函数。\n（注意，jquery.ready()和jquery(document).raedy()不一样！！，前者是工具函数，后者是实例函数。）\n这里是通过定义一个DOMContentLoaded函数作为桥梁来执行jquery.ready()函数的，这样做的目的就是为了及时的remove掉document的DOMContentLoaded事件的引用。\n{% asset_img zongjie.png %}\n推荐好文:  [何控制jquery的ready事件](http://www.xiabingbao.com/jquery/2015/06/27/jquery-holdready/)\n","source":"_posts/DOMContentLoaded-2016-01-08.md","raw":"title: onload vs DOMContentLoaded\ndate: 2016-01-08 10:27:11\ntags:\n- jQuery\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n* `$(document).ready(function () { });`\n* `$(function () { });`\n\n以上两行代码的目的和效果都一样———待DOM加载完成之后，执行传入的function函数。\n\n这是我们在页面初始化时经常使用的监听方案，那么他的实际的执行关系时什么样的呢？\n在原生js中是什么样的一种表现？\n<!--more-->\n## 定义\n+ onload:\n当onload事件触发的时候，页面上的所有dom，样式表，脚本，图片，flash，iframe都已经加载完成了。\n+ DOMContentLoaded:\n当DOMContentLoaded事件触发时，仅当dom加载完成，不包括样式表，图片，flash，iframe\n\n光看定义，一目了然，哪个比较适合作为我们判断的标准：图片啊什么的，我们完全可以不用等。\n\n在某些Gecko和Webkit引擎版本的浏览器里面，包括IE8在内，会同时发起多个http的请求并行加载样式表和脚步，但是脚本会等样式表加载完成之后才会被执行，甚至样式表加载之前页面都不会渲染。opera不会，样式表未加载好就可以执行js。\n\n{% asset_img onLoadVSDomContentLoaded.png %}\n\n### 兼容方案\n#### ie8及以下兼容处理方案\nie的一般处理方案 --- `onreadystatechange` 事件。\nhtml加载过程中会有一个document.readyState状态\n五种状态：\n+ 0（未初始化）：还没有send\n+ 1 loading（载入）：正在发送请求\n+ 2 loaded（载入完成）：执行完成，已经接收到全部响应内容\n+ 3 interactive（交互）： 正在解析响应内容\n+ 4 complete（完成）： 响应内容解析完成，客户端可以用了。\n*complete事件和window.onload事件是同时的。*\n\n这就是要监听页面的readystatechange事件，当事件为interactive或者complete时就可以开始做js的事情了。\ndocument.readyState 状态\n如果我们注册 ready 函数的时间点太晚了，页面已经加载完成之后，我们才注册自己的 ready 函数，那就用不着上面的层层检查了，直接看看当前页面的 readyState 就可以了，如果已经是 complete ，那就可以直接执行我们准备注册的 ready 函数了。不过 ChrisS 报告了一个很特别的错误情况，我们需要延迟一下执行。\n>\nsetTimeout 经常被用来做网页上的定时器，允许为它指定一个毫秒数作为间隔执行的时间。当被启动的程序需要在非常短的时间内运行，我们就会给它指定一个很小的时间数，或者需要马上执行的话，我们甚至把这个毫秒数设置为0，但事实上，setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的毫秒数设置为0，被调用的程序也没有马上启动。这个最小的时间间隔是多少呢？这和浏览器及操作系统有关。在John Resig的新书《Javascript忍者的秘密》一书中提到。\n>>Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。\n\n既然规范都是这样写的，那看来使用setTimeout是没办法再把这个最小时间间隔缩短了。这样，通过设置为 1, 我们可以让程序在浏览器支持的最小时间间隔之后执行了。\n\n    if (document.readyState === \"complete\") {\n        // 延迟 1 毫秒之后，执行 ready 函数\n        setTimeout(jQuery.ready, 1);\n    }\n\n#### doScroll 检测法\n但是当页面中带有iframe时，这个readyState状态会挂起一直等待，等待页面的iframe也加载完毕之后再处理，这个过程是我们不想要得，那就有另外一种处理方案。\n>\nMSDN 关于 JScript 的一个方法有段不起眼的话，当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了！\nDiego Perini 在 2007 年的时候，报告了一种检测 IE 是否加载完成的方式，使用 doScroll 方法调用。详细的说明见这里。\n原理是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在本例中每间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。\n\n    (function doScrollCheck() {\n        if (!jQuery.isReady) {  \n            try {\n                // Use the trick by Diego Perini\n                // http://javascript.nwbox.com/IEContentLoaded/\n                top.doScroll(\"left\");\n            } catch (e) {\n                return setTimeout(doScrollCheck, 50);\n            }   \n            // and execute any waiting functions\n            jQuery.ready();\n        }\n    })();\n\n#### jQuery的实现  \n    //全局方法\n    DOMContentLoaded = function() {\n        if ( document.addEventListener ) {\n            document.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n            jQuery.ready();\n        } else if ( document.readyState === \"complete\" ) {\n            // we're here because readyState === \"complete\" in oldIE\n            // which is good enough for us to call the dom ready!\n            document.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n            jQuery.ready();\n        }\n    }\n\n    //入口 jquery实例调用\n    ready: function( fn ) {\n        // Add the callback\n        jQuery.ready.promise().done( fn );\n\n        return this;\n    }\n\n    jQuery.ready.promise = function( obj ) {\n    if ( !readyList ) {\n\n        readyList = jQuery.Deferred();\n\n        // Catch cases where $(document).ready() is called after the browser event has already occurred.\n        // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n        // 当页面加载完了，直接调用ready方法\n        if ( document.readyState === \"complete\" ) {\n            // Handle it asynchronously to allow scripts the opportunity to delay ready\n            setTimeout( jQuery.ready, 1 );\n\n        // Standards-based browsers support DOMContentLoaded\n        } else if ( document.addEventListener ) {\n            // Use the handy event callback\n            document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\n            // A fallback to window.onload, that will always work\n            window.addEventListener( \"load\", jQuery.ready, false );\n\n        // If IE event model is used\n        } else {\n            // Ensure firing before onload, maybe late but safe also for iframes\n            document.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n\n            // A fallback to window.onload, that will always work\n            window.attachEvent( \"onload\", jQuery.ready );\n\n            // If IE and not a frame\n            // continually check to see if the document is ready\n            var top = false;\n\n            try {\n                top = window.frameElement == null && document.documentElement;\n            } catch(e) {}\n\n            if ( top && top.doScroll ) {\n                (function doScrollCheck() {\n                    if ( !jQuery.isReady ) {\n\n                        try {\n                            // Use the trick by Diego Perini\n                            // http://javascript.nwbox.com/IEContentLoaded/\n                            top.doScroll(\"left\");\n                        } catch(e) {\n                            return setTimeout( doScrollCheck, 50 );\n                        }\n\n                        // and execute any waiting functions\n                        jQuery.ready();\n                    }\n                })();\n            }\n        }\n    }\n    return readyList.promise( obj );\n    };\n\n    jQuery.extend({\n        // Is the DOM ready to be used? Set to true once it occurs.\n        isReady: false,\n\n        // A counter to track how many items to wait for before\n        // the ready event fires. See #6781\n        // ready方法执行前需要等待的次数\n        readyWait: 1,\n\n        // Handle when the DOM is ready\n        // 当DOM加载完毕时开始执行ready\n        ready: function( wait ) {\n            // Abort if there are pending holds or we're already ready\n            // 判断页面是否加载完成并且ready方法已经执行\n            // 若传入的参数为true，则--readyWait；否则判断isReady，即ready是否正在执行\n            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n                return;\n            }\n\n            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n            if ( !document.body ) {\n                return setTimeout( jQuery.ready, 1 );\n            }\n\n            // Remember that the DOM is ready\n            jQuery.isReady = true; //指示ready 方法已经被执行\n\n            // If a normal DOM Ready event fired, decrement, and wait if need be\n            // 若readyWait-1后还是大于0，则返回，不执行ready。\n            if ( wait !== true && --jQuery.readyWait > 0 ) {\n                return;\n            }\n\n            // If there are functions bound, to execute\n            readyList.resolveWith( document, [ jQuery ] );\n\n            // Trigger any bound ready events\n            if ( jQuery.fn.trigger ) {\n                // 触发ready方法，然后解除绑定的ready方法。\n                jQuery( document ).trigger(\"ready\").off(\"ready\");\n            }\n        }\n    });\n根据以上代码可见，最终DOMContented事件执行的，其实是jQUery.ready()这个工具函数。\n（注意，jquery.ready()和jquery(document).raedy()不一样！！，前者是工具函数，后者是实例函数。）\n这里是通过定义一个DOMContentLoaded函数作为桥梁来执行jquery.ready()函数的，这样做的目的就是为了及时的remove掉document的DOMContentLoaded事件的引用。\n{% asset_img zongjie.png %}\n推荐好文:  [何控制jquery的ready事件](http://www.xiabingbao.com/jquery/2015/06/27/jquery-holdready/)\n","slug":"DOMContentLoaded","published":1,"updated":"2016-01-19T12:59:56.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5ezg000u703v9lkfqdvm"},{"title":"第三章 基本概念","date":"2016-01-20T01:38:23.000Z","comments":1,"_content":"# 语法\n## 区分大小写\nECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n<!--more-->\n## 标示符\n所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。\n规则：\n* 第一个字符必须是一个字母、下划线`_`或一个美元符号`$`\n* 其他字符可以是字母、下划线、美元符号或数字。标识符中的字母包含扩展的ASCll或Unicode字母字符(如À和Æ);\n\n## 严格模式 `\"use strict;\"`\n\n[严格模式](http://www.yangshengdonghome.com/2016/01/21/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/)\n\n\n## 语句\n\n* 一个语句由一个或多个表达式、关键字或运算符（符号）组成。通常，在一个行上书写一个语句，但可在两个行或多个行上书写一个语句。此外，在同一个行上书写两个或多个语句，用分号分隔。通常，每个新行都开始一个新语句。最好是显式终止您的语句。可使用分号 (;) 做到这一点，分号是 JavaScript 语句的终止字符。\n* 由括号 ({}) 包围的一组 JavaScript 语句称为一个块。组织在一个块中的语句通常可以视为一个语句，比如`var a = function (){};`和对象字面量(`a = {};`)，这两个结尾的也需要加分号，其他的大括号情况(for循环、ifelse判断)，可以不加分号。\n\n        {% codeblock lang:javascript %}\n        abc={}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n        abc=function(){}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n        if(a==1){}bbc=function(){}// 正常\n        for(var a = 1;a<10;a++){}bbc=function(){}//正常\n        {% endcodeblock %}\n    \n### 语句和表达式的区别\n\n    {% codeblock lang:javascript %}\n    var a = 1 + 3;\n    {% endcodeblock %}\n这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。\n`1 + 3`叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。一条语句可以包含多个表达式。\n# 关键字和保留字\n按照规则，关键字也是语言保留的，不能用作标识符。\n\n* 关键字：真正意义上的保留字。\n\n    if分支语句：if, else\n    switch分支语句：switch, case, default, break\n    循环语句：do, while, for, continue\n    异常处理语句：try, catch, finally, throw\n    获取类型：typeof, instanceof\n    布尔值：true, false, null\n    函数相关：var, void, function, return\n    其他：in, this, with, new, delete\n\n* 保留字：结合java、C++等面向对象语言的思路，将来有可能新加入的关键字。\n\n    基本数据类型：byte, char, boolean, int, short, long, float, double, <span style=\"color:green;\">enum</span>\n    继承：<span style=\"color:red;\">implements</span>, <span style=\"color:green;\">extends</span>, <span style=\"color:green;\">super</span>\n    类与接口：<span style=\"color:green;\">class</span>, <span style=\"color:red;\">interface</span>\n    用来修饰函数的关键字：abstract, native, <span style=\"color:red;\">static</span>, final, <span style=\"color:green;\">const</span>, volatile, synchronized\n    导入导出：<span style=\"color:green;\">export</span>, <span style=\"color:green;\">import</span>\n    访问权限：<span style=\"color:red;\">private</span>, <span style=\"color:red;\">protected</span>, <span style=\"color:red;\">public</span>\n    其他：goto, <span style=\"color:red;\">package</span>, throws, transient, debugger, <span style=\"color:red;\">let</span>,  <span style=\"color:red;\">yield</span>,  <span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>\n    <span style=\"color:#ddd;\">注意：红色字体为第5版严格模式下做的限制，<span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>这两个在严格模式下不能做标识符或属性名。</span>\n    <span style=\"color:#ddd;\">注意：第5版把在非严格模式下运行时的保留字减少到绿色字体这几个，但是为了最大的兼容性还是都不要使用了吧。</span>\n\n> **顺便整理下javascript语言中提供的有用的常用的变量和函数**\n> \n数据类型：Number, Boolean, String, undefined, Object, Array, Function, Date, Math, RegExp, Error\n错误类型：EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError\n编码：decodeURI, decodeURIComponent, encodeURI\n转义：escape, unescape\n类型转换：parentInt, parentFloat\n特殊值及判断：isFinite, isNaN, NaN, Infinity\n其他：arguments, eval\n<span style=\"red;\">这些都不是ECMAScript的关键字，undefined不是关键字但是null确实关键字。</span>\n最后注意：我们常用的函数alert()不属于上面的三类。\n\n# 变量\n\n## 声明变量\n\n1. 使用关键词 var，这个语法可以同时用来声明局部(function内部)和全局变量。\n2. 在非严格模式下，无论是在全局范围内还是函数内，使用直接给变量赋值`count = 3`这种语法，会产生一个全部变量count(隐式全局变量)，这种方式不推荐。\n3. <span style=\"color:red;\">无法用var声明块级局部变量</span>。\n\n        // A single declaration.\n        var count;  \n        // Multiple declarations with a single var keyword.\n        var count, amount, level;    \n        // Variable declaration and initialization in one statement.\n        var count = 0, amount = 100;\n        count = 3;//无论实在全局范围内还是函数内，使用这种语法直接给变量赋值，会产生一个全部变量\n如果未在 var 语句中初始化您的变量，它将自动采用 undefined 值，试图访问一个未初始化的变量会导致一个 ReferenceError 异常被抛出\n\n如果使用`var`重新声明一个已经存在的变量，是无效的。\n\n    {% codeblock lang:javascript %}\n    var x = 1;\n    var x;\n    x // 1\n    {% endcodeblock %}\n但是，如果第二次声明的同时还赋值了，则会覆盖掉前面的值。\n\n    {% codeblock lang:javascript %}\n    var x = 1;\n    var x = 2;\n    x // 2\n    {% endcodeblock %}\n\n使用var声明的全局变量和不使用var的区别：\n\n        {% codeblock lang:javascript %}\n        // 定义三个全局变量\n        var global_var = 1;\n        global_novar = 2; // 反面教材\n        (function () {\n            global_fromfunc = 3; // 反面教材\n        }());\n\n        // 试图删除\n        delete global_var; // false\n        delete global_novar; // true\n        delete global_fromfunc; // true\n        \n        // 测试该删除\n        typeof global_var; // \"number\"\n        typeof global_novar; // \"undefined\"\n        typeof global_fromfunc; // \"undefined\"\n        {% endcodeblock %}\n\n原因：使用var命令声明变量时（或者使用属性赋值的方式声明变量），变量的可配置性为true。\n        \n        {% codeblock lang:javascript %}\n        a2 = 1;\n\n        Object.getOwnPropertyDescriptor(this,'a2')\n        // Object {\n        //\tvalue: 1, \n        //\twritable: true, \n        //\tenumerable: true, \n        //\tconfigurable: true\n        // }\n\n        // 或者写成\n\n        this.a3 = 1;\n\n        Object.getOwnPropertyDescriptor(this,'a3')\n        // Object {\n        //\tvalue: 1, \n        //\twritable: true, \n        //\tenumerable: true, \n        //\tconfigurable: true\n        // }\n        {% endcodeblock %}\n---\n了解另外两种变量的声明方式：\n>\n    * let：声明块范围局部变量，可选初始化值。\n    * const：声明一个只读命名常量。\n\n## 数据类型\n\nECMAScript是变量松散类型语言(动态数据类型语言)，即每个变量只是一个占位符，其类型并不固定，可以随时变化，这意味着你定义变量时不必指定变量类型，而且变量类型会在脚本执行需要时自动转换。但是，<span style=\"color: red;\">数据本身和各种运算是有类型的</span>。\nECMAScript 中有5 种简单数据类型（也称为基本数据类型(primitive type)）：Undefined、Null、Boolean、Number和String。还有1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。(ES6又新增了第七种Symbol类型的值)。\nObject对象又可以分成三个子类型：\n\n- 狭义的对象（object）\n- 数组（array）\n- 函数（function）`function f() {} console.log(typeof f) //\"function\"`\n\n狭义的对象和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。\n### undefined类型\n[好好学学undefined！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6undefined%EF%BC%81/)\n\n### null类型\n\nnull类型也只有一个值：null , 表示一个变量中没有包含有效数据，null表示\"没有对象\"。`字面值null`在这里意为`空值`、`空对象`的意思，更确切的说，一个被赋值为null的变量没有保存有效的对象等，可以通过给一个变量赋值为null来清空变量中的内容(不删除变量)。\n\n主要用处：\n\n* 作为函数的参数传递，表示该函数的参数不是对象。\n* 作为对象原型链的终点（例如声明原型链的结束 Foo.prototype = null）。\n    \n    Object.getPrototypeOf(Object.prototype) // null\n\n产生null的原因只有一个，即对一个变量显式的赋值为null 。\n\n\n\n    var p = null;\n    console.log(p); //null\n    typeof p; // \"object\"\n    typeof null; // \"object\"\n另外，需要注意的是，typeof null 应该返回\"null\"，但实际上返回的是\"object\"，这是一个历史遗留问题，并没有其他原因，不要想太多，曾经有提案 typeof null === 'null'但提案被拒绝。\n> 《javascript高级程序设计3》是这么解释的:从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用typeof 操作符检测null 值时会返回\"object\"的原因。\n\n    判断null值，这个时候就不能用typeOf了，直接用if(xxx === null){}\n    console.log(typeof null) //\"Object\"\n    console.log(null instanceof Object) // false\n    var a = null,b;\n    console.log(a === null) //true\n    console.log(b === null) //false 因为 undefined !== null  三个等号为false\n    console.log(b == null) // true 两个等号为true\n    \n>undefined == null //true [为什么相等？](https://www.w3.org/html/ig/zh/wiki/ES5/expressions#.E7.AD.89.E5.80.BC.E8.BF.90.E7.AE.97.E7.AC.A6)\n\n### Boolean类型\n\nboolean类型只有两个字面值：`true`和`false` 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()。其中转换结果为false的值有(false, \"\", +0, -0, NaN, null, undefined)，其他值(包括空对象、空数组)均将转换为true。\n\n产生原因：下列运算符会返回布尔值。\n\n- 两元逻辑运算符： `&&` (And)，`||` (Or)\n- 前置逻辑运算符： `!` (Not)\n- 相等运算符：`===`，`!==`，`==`，`!=`\n- 比较运算符：`>`，`>=`，`<`，`<=`\n    \n    {% codeblock lang:javascript %}\n    typeof true; // \"boolean\"\n    \n    typeof false; // \"boolean\"\n    \n    Boolean(new Object()); //true\n    \n    Boolean(undefined); //false\n    \n    Boolean(null); //false\n    \n    Boolean(''); //false\n    \n    Boolean(0); //false\n    \n    Boolean(100); // true\n    \n    Boolean([]) // true\n     \n    Boolean({}) // true\n    {% endcodeblock %}\n    \n    \n所有对象的布尔值都是true，甚至连false对应的布尔对象也是true。\n\n```javascript\nBoolean(new Boolean(false)) // true\n```\n    \n如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，比如：\nif判断语句中自动调用Boolean()。\n    \n    {% codeblock lang:javascript %}\n    if (x = y + z){} //将值 y + z 赋给变量 x，然后检查整个表达式的结果（x 的值）是否为 0。\n    {% endcodeblock %}\n\n### Number类型\n[好好学学number！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n\n### String类型\n[好好学学String！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n\n### Object类型\n[好好学学String！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n## 类型检验\n- typeof typeof是一元运算符，后面必须跟表达式\n- instanceof\n- Object.prototype.toString","source":"_posts/3-第三章基本概念-2016-01-20.md","raw":"title: 第三章 基本概念\ndate: 2016-01-20 09:38:23\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n# 语法\n## 区分大小写\nECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n<!--more-->\n## 标示符\n所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。\n规则：\n* 第一个字符必须是一个字母、下划线`_`或一个美元符号`$`\n* 其他字符可以是字母、下划线、美元符号或数字。标识符中的字母包含扩展的ASCll或Unicode字母字符(如À和Æ);\n\n## 严格模式 `\"use strict;\"`\n\n[严格模式](http://www.yangshengdonghome.com/2016/01/21/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/)\n\n\n## 语句\n\n* 一个语句由一个或多个表达式、关键字或运算符（符号）组成。通常，在一个行上书写一个语句，但可在两个行或多个行上书写一个语句。此外，在同一个行上书写两个或多个语句，用分号分隔。通常，每个新行都开始一个新语句。最好是显式终止您的语句。可使用分号 (;) 做到这一点，分号是 JavaScript 语句的终止字符。\n* 由括号 ({}) 包围的一组 JavaScript 语句称为一个块。组织在一个块中的语句通常可以视为一个语句，比如`var a = function (){};`和对象字面量(`a = {};`)，这两个结尾的也需要加分号，其他的大括号情况(for循环、ifelse判断)，可以不加分号。\n\n        {% codeblock lang:javascript %}\n        abc={}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n        abc=function(){}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n        if(a==1){}bbc=function(){}// 正常\n        for(var a = 1;a<10;a++){}bbc=function(){}//正常\n        {% endcodeblock %}\n    \n### 语句和表达式的区别\n\n    {% codeblock lang:javascript %}\n    var a = 1 + 3;\n    {% endcodeblock %}\n这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。\n`1 + 3`叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。一条语句可以包含多个表达式。\n# 关键字和保留字\n按照规则，关键字也是语言保留的，不能用作标识符。\n\n* 关键字：真正意义上的保留字。\n\n    if分支语句：if, else\n    switch分支语句：switch, case, default, break\n    循环语句：do, while, for, continue\n    异常处理语句：try, catch, finally, throw\n    获取类型：typeof, instanceof\n    布尔值：true, false, null\n    函数相关：var, void, function, return\n    其他：in, this, with, new, delete\n\n* 保留字：结合java、C++等面向对象语言的思路，将来有可能新加入的关键字。\n\n    基本数据类型：byte, char, boolean, int, short, long, float, double, <span style=\"color:green;\">enum</span>\n    继承：<span style=\"color:red;\">implements</span>, <span style=\"color:green;\">extends</span>, <span style=\"color:green;\">super</span>\n    类与接口：<span style=\"color:green;\">class</span>, <span style=\"color:red;\">interface</span>\n    用来修饰函数的关键字：abstract, native, <span style=\"color:red;\">static</span>, final, <span style=\"color:green;\">const</span>, volatile, synchronized\n    导入导出：<span style=\"color:green;\">export</span>, <span style=\"color:green;\">import</span>\n    访问权限：<span style=\"color:red;\">private</span>, <span style=\"color:red;\">protected</span>, <span style=\"color:red;\">public</span>\n    其他：goto, <span style=\"color:red;\">package</span>, throws, transient, debugger, <span style=\"color:red;\">let</span>,  <span style=\"color:red;\">yield</span>,  <span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>\n    <span style=\"color:#ddd;\">注意：红色字体为第5版严格模式下做的限制，<span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>这两个在严格模式下不能做标识符或属性名。</span>\n    <span style=\"color:#ddd;\">注意：第5版把在非严格模式下运行时的保留字减少到绿色字体这几个，但是为了最大的兼容性还是都不要使用了吧。</span>\n\n> **顺便整理下javascript语言中提供的有用的常用的变量和函数**\n> \n数据类型：Number, Boolean, String, undefined, Object, Array, Function, Date, Math, RegExp, Error\n错误类型：EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError\n编码：decodeURI, decodeURIComponent, encodeURI\n转义：escape, unescape\n类型转换：parentInt, parentFloat\n特殊值及判断：isFinite, isNaN, NaN, Infinity\n其他：arguments, eval\n<span style=\"red;\">这些都不是ECMAScript的关键字，undefined不是关键字但是null确实关键字。</span>\n最后注意：我们常用的函数alert()不属于上面的三类。\n\n# 变量\n\n## 声明变量\n\n1. 使用关键词 var，这个语法可以同时用来声明局部(function内部)和全局变量。\n2. 在非严格模式下，无论是在全局范围内还是函数内，使用直接给变量赋值`count = 3`这种语法，会产生一个全部变量count(隐式全局变量)，这种方式不推荐。\n3. <span style=\"color:red;\">无法用var声明块级局部变量</span>。\n\n        // A single declaration.\n        var count;  \n        // Multiple declarations with a single var keyword.\n        var count, amount, level;    \n        // Variable declaration and initialization in one statement.\n        var count = 0, amount = 100;\n        count = 3;//无论实在全局范围内还是函数内，使用这种语法直接给变量赋值，会产生一个全部变量\n如果未在 var 语句中初始化您的变量，它将自动采用 undefined 值，试图访问一个未初始化的变量会导致一个 ReferenceError 异常被抛出\n\n如果使用`var`重新声明一个已经存在的变量，是无效的。\n\n    {% codeblock lang:javascript %}\n    var x = 1;\n    var x;\n    x // 1\n    {% endcodeblock %}\n但是，如果第二次声明的同时还赋值了，则会覆盖掉前面的值。\n\n    {% codeblock lang:javascript %}\n    var x = 1;\n    var x = 2;\n    x // 2\n    {% endcodeblock %}\n\n使用var声明的全局变量和不使用var的区别：\n\n        {% codeblock lang:javascript %}\n        // 定义三个全局变量\n        var global_var = 1;\n        global_novar = 2; // 反面教材\n        (function () {\n            global_fromfunc = 3; // 反面教材\n        }());\n\n        // 试图删除\n        delete global_var; // false\n        delete global_novar; // true\n        delete global_fromfunc; // true\n        \n        // 测试该删除\n        typeof global_var; // \"number\"\n        typeof global_novar; // \"undefined\"\n        typeof global_fromfunc; // \"undefined\"\n        {% endcodeblock %}\n\n原因：使用var命令声明变量时（或者使用属性赋值的方式声明变量），变量的可配置性为true。\n        \n        {% codeblock lang:javascript %}\n        a2 = 1;\n\n        Object.getOwnPropertyDescriptor(this,'a2')\n        // Object {\n        //\tvalue: 1, \n        //\twritable: true, \n        //\tenumerable: true, \n        //\tconfigurable: true\n        // }\n\n        // 或者写成\n\n        this.a3 = 1;\n\n        Object.getOwnPropertyDescriptor(this,'a3')\n        // Object {\n        //\tvalue: 1, \n        //\twritable: true, \n        //\tenumerable: true, \n        //\tconfigurable: true\n        // }\n        {% endcodeblock %}\n---\n了解另外两种变量的声明方式：\n>\n    * let：声明块范围局部变量，可选初始化值。\n    * const：声明一个只读命名常量。\n\n## 数据类型\n\nECMAScript是变量松散类型语言(动态数据类型语言)，即每个变量只是一个占位符，其类型并不固定，可以随时变化，这意味着你定义变量时不必指定变量类型，而且变量类型会在脚本执行需要时自动转换。但是，<span style=\"color: red;\">数据本身和各种运算是有类型的</span>。\nECMAScript 中有5 种简单数据类型（也称为基本数据类型(primitive type)）：Undefined、Null、Boolean、Number和String。还有1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。(ES6又新增了第七种Symbol类型的值)。\nObject对象又可以分成三个子类型：\n\n- 狭义的对象（object）\n- 数组（array）\n- 函数（function）`function f() {} console.log(typeof f) //\"function\"`\n\n狭义的对象和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。\n### undefined类型\n[好好学学undefined！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6undefined%EF%BC%81/)\n\n### null类型\n\nnull类型也只有一个值：null , 表示一个变量中没有包含有效数据，null表示\"没有对象\"。`字面值null`在这里意为`空值`、`空对象`的意思，更确切的说，一个被赋值为null的变量没有保存有效的对象等，可以通过给一个变量赋值为null来清空变量中的内容(不删除变量)。\n\n主要用处：\n\n* 作为函数的参数传递，表示该函数的参数不是对象。\n* 作为对象原型链的终点（例如声明原型链的结束 Foo.prototype = null）。\n    \n    Object.getPrototypeOf(Object.prototype) // null\n\n产生null的原因只有一个，即对一个变量显式的赋值为null 。\n\n\n\n    var p = null;\n    console.log(p); //null\n    typeof p; // \"object\"\n    typeof null; // \"object\"\n另外，需要注意的是，typeof null 应该返回\"null\"，但实际上返回的是\"object\"，这是一个历史遗留问题，并没有其他原因，不要想太多，曾经有提案 typeof null === 'null'但提案被拒绝。\n> 《javascript高级程序设计3》是这么解释的:从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用typeof 操作符检测null 值时会返回\"object\"的原因。\n\n    判断null值，这个时候就不能用typeOf了，直接用if(xxx === null){}\n    console.log(typeof null) //\"Object\"\n    console.log(null instanceof Object) // false\n    var a = null,b;\n    console.log(a === null) //true\n    console.log(b === null) //false 因为 undefined !== null  三个等号为false\n    console.log(b == null) // true 两个等号为true\n    \n>undefined == null //true [为什么相等？](https://www.w3.org/html/ig/zh/wiki/ES5/expressions#.E7.AD.89.E5.80.BC.E8.BF.90.E7.AE.97.E7.AC.A6)\n\n### Boolean类型\n\nboolean类型只有两个字面值：`true`和`false` 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()。其中转换结果为false的值有(false, \"\", +0, -0, NaN, null, undefined)，其他值(包括空对象、空数组)均将转换为true。\n\n产生原因：下列运算符会返回布尔值。\n\n- 两元逻辑运算符： `&&` (And)，`||` (Or)\n- 前置逻辑运算符： `!` (Not)\n- 相等运算符：`===`，`!==`，`==`，`!=`\n- 比较运算符：`>`，`>=`，`<`，`<=`\n    \n    {% codeblock lang:javascript %}\n    typeof true; // \"boolean\"\n    \n    typeof false; // \"boolean\"\n    \n    Boolean(new Object()); //true\n    \n    Boolean(undefined); //false\n    \n    Boolean(null); //false\n    \n    Boolean(''); //false\n    \n    Boolean(0); //false\n    \n    Boolean(100); // true\n    \n    Boolean([]) // true\n     \n    Boolean({}) // true\n    {% endcodeblock %}\n    \n    \n所有对象的布尔值都是true，甚至连false对应的布尔对象也是true。\n\n```javascript\nBoolean(new Boolean(false)) // true\n```\n    \n如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，比如：\nif判断语句中自动调用Boolean()。\n    \n    {% codeblock lang:javascript %}\n    if (x = y + z){} //将值 y + z 赋给变量 x，然后检查整个表达式的结果（x 的值）是否为 0。\n    {% endcodeblock %}\n\n### Number类型\n[好好学学number！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n\n### String类型\n[好好学学String！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n\n### Object类型\n[好好学学String！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n## 类型检验\n- typeof typeof是一元运算符，后面必须跟表达式\n- instanceof\n- Object.prototype.toString","slug":"3-第三章基本概念","published":1,"updated":"2016-02-03T10:05:11.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5ezp000y703v2cl4ksmv"},{"title":"第二章 在HTML中使用JavaScrpt","date":"2016-01-05T06:25:13.000Z","comments":1,"_content":"## script元素\n\n`<script src=\"demo.js\"></script>`尽管`<script>` 标签内没有内容，结束的 `</script>` 标签也是必需的。外部文件一般扩展名为.js，但这不是强制的，不写.js扩展名一样可以运行。\n<!--more-->\n* type 这个属性不是必须的，默认值是 “text /javascript”，表示的是编写代码使用的脚本语言的内容类型（也称为MIME 类型）。服务器在传送js文件时使用的MIME类型，通常是application/x-javascript，但在type中设置这个值可能会导致脚本被忽略，考虑到约定俗成和最大浏览器兼容性，目前type属性的值依旧还是text/javascript。\n*  async  只适用外部引入脚本。\n*  defer 只适用外部引入脚本。\n*  language 已废弃。\n*  src\n\n>1. 如果通过&lt;script&gt;&lt;/script&gt;向页面写入一段可以执行的js代码？。\n>\n        <script>\n            document.write('&lt;script&gt;alert(0)&lt;/script&gt;');//alert(0); 不执行\n            document.write('<script>alert(4)</scr'+'ipt>'); //正常弹窗\n            document.write('<script>alert(2)<\\/script>'); //正常弹窗\n            document.write('<script>alert(3)</script>'); //报错\n        </script>\n\n>2. 执行顺序：\n>无论如何包含代码，只要不存在defer 和async 属性，浏览器都会按照`<script>`元素在页面中出现的先后顺序对它们依次进行解析。换句话说，在第一个`<script>`元素包含的代码解析完成后，第二个`<script>`包含的代码才会被解析，然后才是第三个、第四个……\n\n## 标签的位置\n\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <title>Example HTML Page</title>\n        </head>\n        <body>\n            <!-- 这里放内容 -->\n            <script type=\"text/javascript\" src=\"example1.js\"></script>\n            <script type=\"text/javascript\" src=\"example2.js\"></script>\n        </body>\n    </html>\n## 延迟脚本 defer\n\ndefer这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕(`/HTML`)后再运行。因此，在`<script>`元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\nIE4、Firefox 3.5、Safari 5 和Chrome ，其他浏览器会忽略这个属性。为此，把延迟脚本放在页面底部仍然是最佳选择。\n>**defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载**\n## 异步脚本 async\n\nHTML5 为`<script>`元素定义了async 属性。指定async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\n- Firefox 3.6、Safari 5 和Chrome。\n- ie系列，async没有任何效果\n- 在chrome下，只有外联脚本，且是在body中引用的，才能生效.\n- **异步执行的表现是，在DOMContentLoaded事件之后，window.loaded事件之前，所以，这个属性处理阻塞的问题是可行的**\n\n## Defer和async的区别\n\n先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：\n`<script src=\"script.js\"></script>`\n没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。\n`<script async src=\"script.js\"></script>`\n有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n`<script defer src=\"myscript.js\"></script>`\n有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。\n\n然后从实用角度来说呢，首先把所有脚本都丢到 `</body>` 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。\n接着，我们来看一张图咯：\n\n{% asset_img deferAsync.png %}\n\n**此图告诉我们以下几个要点：**\ndefer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。\n\n### Defer async常规表现（一些高级浏览器）\n\n* herder\nheader中行内脚本执行顺序不受defer async影响，顺序执行，会阻塞DOMContentLoaded。\nheader中行内脚本中ajax请求不会对页面加载带来任何阻塞。\nheader中引用外部脚本，添加defer async后，浏览器表现情况不统一，async的可能先执行，所以引用外部脚本并不适合加在header中，也不适合添加defer async标示。\n* body\nbody中图片加载会阻塞window.loaded,不会阻塞DOMContentLoaded。\nbody中行内脚本执行顺序不受defer async影响，顺序执行，阻塞DOMContentLoaded。\nbody中行内脚本ajax请求不会阻塞页面加载。\nbody中引用外部脚本，defer async表现正常，外部脚本应该加在body中，body结束标签上面。\n* ajax\n无论是header还是body中，行内脚本执行的ajax还是外部脚本执行的ajax，都对页面加载没有影响。\n* 总结\n1. defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载。\n2. async脚本都会在loaded之前执行，它会阻塞window.loaded。\n3. DOMContentLoaded在window.loaded之前执行，阻塞DOMContentLoaded也就会阻塞window.loaded\n4. document ready在DOMContentLoaded之前执行，说明document ready是监听DOMContentLoaded完成的\n### IE\n\n1. IE支持defer属性,不支持async属性，从IE9及以上支持onload,支持DOMContentLoaded。\n2. IE6，7支持行内脚本defer属性， 从表现上来看IE6,7,8,9都支持行内脚本的defer，所以我们在ie6,7,8,9中观察到的现象是，行内的先执行async,再执行没加defer async标记的，defer的延迟执行了。\n3. 同时我们又发现IE6,7脚本中ajax影响了页面加载，影响document ready,IE8及以上版本不受影响。\n4. 到了IE8以上，表现和webkit内核浏览器基本相似了。\n\n**不是动态添加的脚本，都会阻塞页DOMContentLoaded，动态添加的脚本应该在document ready后加载，但是也会阻塞loaded**\n>不懂DOMContentLoaded的点[这里](http://www.yangshengdonghome.com/2016/01/08/DOMContentLoaded/)。\n\n## 嵌入代码与外部文件\n\n* 推荐通过`<script>`标签引入外部js文件。\n* 浏览器能够根据具体的设置缓存链接的所有外部JavaScript 文件。也就是说，如果有两个\n页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的\n速度。\n\n## 文档模式 `<!DOCTYPE *>`\n\nE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。\n1. 混杂模式（quirks mode）\n2. 标准模式（standards mode）\n3. 准标准模式（almost standards mode）\n\n如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。\n>现在所有的HTML文档都推荐使用HTML5规定的`<!DOCTYPE html>`\n\n## noscript\n\n包含在`<noscript></noscript>`元素中的内容只有在下列情况下才会显示出来：\n* 浏览器不支持脚本；\n* 浏览器支持脚本，但脚本被禁用。\n","source":"_posts/2-在HTML中使用JavaScrpt-2016-01-05.md","raw":"title: 第二章 在HTML中使用JavaScrpt\ndate: 2016-01-05 14:25:13\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n## script元素\n\n`<script src=\"demo.js\"></script>`尽管`<script>` 标签内没有内容，结束的 `</script>` 标签也是必需的。外部文件一般扩展名为.js，但这不是强制的，不写.js扩展名一样可以运行。\n<!--more-->\n* type 这个属性不是必须的，默认值是 “text /javascript”，表示的是编写代码使用的脚本语言的内容类型（也称为MIME 类型）。服务器在传送js文件时使用的MIME类型，通常是application/x-javascript，但在type中设置这个值可能会导致脚本被忽略，考虑到约定俗成和最大浏览器兼容性，目前type属性的值依旧还是text/javascript。\n*  async  只适用外部引入脚本。\n*  defer 只适用外部引入脚本。\n*  language 已废弃。\n*  src\n\n>1. 如果通过&lt;script&gt;&lt;/script&gt;向页面写入一段可以执行的js代码？。\n>\n        <script>\n            document.write('&lt;script&gt;alert(0)&lt;/script&gt;');//alert(0); 不执行\n            document.write('<script>alert(4)</scr'+'ipt>'); //正常弹窗\n            document.write('<script>alert(2)<\\/script>'); //正常弹窗\n            document.write('<script>alert(3)</script>'); //报错\n        </script>\n\n>2. 执行顺序：\n>无论如何包含代码，只要不存在defer 和async 属性，浏览器都会按照`<script>`元素在页面中出现的先后顺序对它们依次进行解析。换句话说，在第一个`<script>`元素包含的代码解析完成后，第二个`<script>`包含的代码才会被解析，然后才是第三个、第四个……\n\n## 标签的位置\n\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <title>Example HTML Page</title>\n        </head>\n        <body>\n            <!-- 这里放内容 -->\n            <script type=\"text/javascript\" src=\"example1.js\"></script>\n            <script type=\"text/javascript\" src=\"example2.js\"></script>\n        </body>\n    </html>\n## 延迟脚本 defer\n\ndefer这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕(`/HTML`)后再运行。因此，在`<script>`元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\nIE4、Firefox 3.5、Safari 5 和Chrome ，其他浏览器会忽略这个属性。为此，把延迟脚本放在页面底部仍然是最佳选择。\n>**defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载**\n## 异步脚本 async\n\nHTML5 为`<script>`元素定义了async 属性。指定async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\n- Firefox 3.6、Safari 5 和Chrome。\n- ie系列，async没有任何效果\n- 在chrome下，只有外联脚本，且是在body中引用的，才能生效.\n- **异步执行的表现是，在DOMContentLoaded事件之后，window.loaded事件之前，所以，这个属性处理阻塞的问题是可行的**\n\n## Defer和async的区别\n\n先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：\n`<script src=\"script.js\"></script>`\n没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。\n`<script async src=\"script.js\"></script>`\n有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n`<script defer src=\"myscript.js\"></script>`\n有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。\n\n然后从实用角度来说呢，首先把所有脚本都丢到 `</body>` 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。\n接着，我们来看一张图咯：\n\n{% asset_img deferAsync.png %}\n\n**此图告诉我们以下几个要点：**\ndefer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。\n\n### Defer async常规表现（一些高级浏览器）\n\n* herder\nheader中行内脚本执行顺序不受defer async影响，顺序执行，会阻塞DOMContentLoaded。\nheader中行内脚本中ajax请求不会对页面加载带来任何阻塞。\nheader中引用外部脚本，添加defer async后，浏览器表现情况不统一，async的可能先执行，所以引用外部脚本并不适合加在header中，也不适合添加defer async标示。\n* body\nbody中图片加载会阻塞window.loaded,不会阻塞DOMContentLoaded。\nbody中行内脚本执行顺序不受defer async影响，顺序执行，阻塞DOMContentLoaded。\nbody中行内脚本ajax请求不会阻塞页面加载。\nbody中引用外部脚本，defer async表现正常，外部脚本应该加在body中，body结束标签上面。\n* ajax\n无论是header还是body中，行内脚本执行的ajax还是外部脚本执行的ajax，都对页面加载没有影响。\n* 总结\n1. defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载。\n2. async脚本都会在loaded之前执行，它会阻塞window.loaded。\n3. DOMContentLoaded在window.loaded之前执行，阻塞DOMContentLoaded也就会阻塞window.loaded\n4. document ready在DOMContentLoaded之前执行，说明document ready是监听DOMContentLoaded完成的\n### IE\n\n1. IE支持defer属性,不支持async属性，从IE9及以上支持onload,支持DOMContentLoaded。\n2. IE6，7支持行内脚本defer属性， 从表现上来看IE6,7,8,9都支持行内脚本的defer，所以我们在ie6,7,8,9中观察到的现象是，行内的先执行async,再执行没加defer async标记的，defer的延迟执行了。\n3. 同时我们又发现IE6,7脚本中ajax影响了页面加载，影响document ready,IE8及以上版本不受影响。\n4. 到了IE8以上，表现和webkit内核浏览器基本相似了。\n\n**不是动态添加的脚本，都会阻塞页DOMContentLoaded，动态添加的脚本应该在document ready后加载，但是也会阻塞loaded**\n>不懂DOMContentLoaded的点[这里](http://www.yangshengdonghome.com/2016/01/08/DOMContentLoaded/)。\n\n## 嵌入代码与外部文件\n\n* 推荐通过`<script>`标签引入外部js文件。\n* 浏览器能够根据具体的设置缓存链接的所有外部JavaScript 文件。也就是说，如果有两个\n页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的\n速度。\n\n## 文档模式 `<!DOCTYPE *>`\n\nE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。\n1. 混杂模式（quirks mode）\n2. 标准模式（standards mode）\n3. 准标准模式（almost standards mode）\n\n如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。\n>现在所有的HTML文档都推荐使用HTML5规定的`<!DOCTYPE html>`\n\n## noscript\n\n包含在`<noscript></noscript>`元素中的内容只有在下列情况下才会显示出来：\n* 浏览器不支持脚本；\n* 浏览器支持脚本，但脚本被禁用。\n","slug":"2-在HTML中使用JavaScrpt","published":1,"updated":"2016-01-20T01:33:33.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5ezx0012703vpugdckxg"},{"title":"第一章 JavaScrpt简介","date":"2016-01-05T06:24:40.000Z","comments":1,"_content":"先简要说一下和JavaScript相关的一些背景术语，就不详细讨论JavaScript的历史了，想了解的朋友可以参考原书。\n<!--more-->\n+ ECMA：\n欧洲计算机制造商协会（Standard ECMA-262European Computer Manufacturers Association）\n+ TC39：\nECMA第39号技术委员会（Technical Committee#39），由来自一些关注脚本语言发展的公司的程序员组成，负责制定一种通用、跨平台、供应商中立的脚本语言。\n+ ECMAScript：\n由ECMA制定，在ECMA-262中定义的脚本语言标准。ECMAScript只是一个脚本语言标准，你尽可以在自己的环境中取实现它，这个环境，就称为ECMAScript的宿主环境，Web浏览器可以说是ECMAScript目前最重要的宿主环境了，而不同的Web浏览器，对ECMAScript标准的支持也不尽相同。除Web浏览器，Adobe ActionScript也实现了ECMAScript。一般的宿主环境，除了实现ECMAScript标准，也会有各自的扩展，以便与环境更好的交互。\n+ ES3、ES5、ES6：是指ECMAScript 的三个版本，最新版是ES6，已经有部分特性被浏览器支持。[查看各个版本被各大浏览器的支持情况](http://kangax.github.io/compat-table/es5/)。\n+ DOM\n>+  **DOM1级：**\n> DOM1 级由两个模块组成：DOM核心（DOM Core）和DOM HTML。其中，DOM 核心规定的是如何映射基于XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在DOM 核心的基础上加以扩展，添加了针对HTML 的对象和方法。\n>+  **DOM2级：**\n>DOM2 级在原来DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1 级中的DOM核心模块也经过扩展开始支持XML 命名空间。\n>+  **DOM3级：**\n>1. 引入了以统一方式加载和保存文档的方法\n>2. 新增了验证文档的方法\n>3. DOM3 级也对DOM 核心进行了扩展，开始支持XML 1.0 规范，涉及XML Infoset、XPath和XML Base。\n\n* **BOM ：**\n从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的JavaScript 扩展算作BOM的一部分。下面就是一些这样的扩展：\n>1. 弹出新浏览器窗口的功能；\n>2. 移动、缩放和关闭浏览器窗口的功能；\n>3. 提供浏览器详细信息的navigator 对象；\n>4. 提供浏览器所加载页面的详细信息的location 对象；\n>5. 提供用户显示器分辨率详细信息的screen 对象；\n>6. 对cookies 的支持；\n>7. 像XMLHttpRequest 和IE 的ActiveXObject 这样的自定义对象。\n\n\n+ LiveScript、JavaScript、JScript：\nLiveScript是JavaScript的前身，而JScript则是微软为了防止版权冲突而给自己的脚本语言起的名称。他们除了实现了ECMAScript外，还会包括针对浏览器的扩展（BOM：浏览器对象模型）和针对XML/HTML API的扩展（DOM：文档对象模型）。\n>JavaScript 是一种专为网页交互设计的脚本语言，由下列三个不同的部分组成：\n>>ECMAScript：规定了以下这些内容：语法、类型、语句、关键字、保留字、操作符、对象\n>\n>>DOM：文档对象模型（Document Object Model）\n>\n>>BOM：浏览器对象模型（Browser Object Model）","source":"_posts/1-JavaScrpt简介-2016-01-05.md","raw":"title: 第一章 JavaScrpt简介\ndate: 2016-01-05 14:24:40\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n先简要说一下和JavaScript相关的一些背景术语，就不详细讨论JavaScript的历史了，想了解的朋友可以参考原书。\n<!--more-->\n+ ECMA：\n欧洲计算机制造商协会（Standard ECMA-262European Computer Manufacturers Association）\n+ TC39：\nECMA第39号技术委员会（Technical Committee#39），由来自一些关注脚本语言发展的公司的程序员组成，负责制定一种通用、跨平台、供应商中立的脚本语言。\n+ ECMAScript：\n由ECMA制定，在ECMA-262中定义的脚本语言标准。ECMAScript只是一个脚本语言标准，你尽可以在自己的环境中取实现它，这个环境，就称为ECMAScript的宿主环境，Web浏览器可以说是ECMAScript目前最重要的宿主环境了，而不同的Web浏览器，对ECMAScript标准的支持也不尽相同。除Web浏览器，Adobe ActionScript也实现了ECMAScript。一般的宿主环境，除了实现ECMAScript标准，也会有各自的扩展，以便与环境更好的交互。\n+ ES3、ES5、ES6：是指ECMAScript 的三个版本，最新版是ES6，已经有部分特性被浏览器支持。[查看各个版本被各大浏览器的支持情况](http://kangax.github.io/compat-table/es5/)。\n+ DOM\n>+  **DOM1级：**\n> DOM1 级由两个模块组成：DOM核心（DOM Core）和DOM HTML。其中，DOM 核心规定的是如何映射基于XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在DOM 核心的基础上加以扩展，添加了针对HTML 的对象和方法。\n>+  **DOM2级：**\n>DOM2 级在原来DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1 级中的DOM核心模块也经过扩展开始支持XML 命名空间。\n>+  **DOM3级：**\n>1. 引入了以统一方式加载和保存文档的方法\n>2. 新增了验证文档的方法\n>3. DOM3 级也对DOM 核心进行了扩展，开始支持XML 1.0 规范，涉及XML Infoset、XPath和XML Base。\n\n* **BOM ：**\n从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的JavaScript 扩展算作BOM的一部分。下面就是一些这样的扩展：\n>1. 弹出新浏览器窗口的功能；\n>2. 移动、缩放和关闭浏览器窗口的功能；\n>3. 提供浏览器详细信息的navigator 对象；\n>4. 提供浏览器所加载页面的详细信息的location 对象；\n>5. 提供用户显示器分辨率详细信息的screen 对象；\n>6. 对cookies 的支持；\n>7. 像XMLHttpRequest 和IE 的ActiveXObject 这样的自定义对象。\n\n\n+ LiveScript、JavaScript、JScript：\nLiveScript是JavaScript的前身，而JScript则是微软为了防止版权冲突而给自己的脚本语言起的名称。他们除了实现了ECMAScript外，还会包括针对浏览器的扩展（BOM：浏览器对象模型）和针对XML/HTML API的扩展（DOM：文档对象模型）。\n>JavaScript 是一种专为网页交互设计的脚本语言，由下列三个不同的部分组成：\n>>ECMAScript：规定了以下这些内容：语法、类型、语句、关键字、保留字、操作符、对象\n>\n>>DOM：文档对象模型（Document Object Model）\n>\n>>BOM：浏览器对象模型（Browser Object Model）","slug":"1-JavaScrpt简介","published":1,"updated":"2016-01-22T05:57:44.000Z","layout":"post","photos":[],"link":"","_id":"cik6o5f030015703vwedtovfc"},{"title":"好好学学Object!","date":"2016-02-03T08:09:30.000Z","comments":1,"_content":"## 概述\n\n### 定义方法\n\n对象（object）是JavaScript的核心概念，也是最重要的数据类型。JavaScript的所有数据都可以被视为对象。\n简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。\n<!--more-->\n\n```javascript\nvar o = {\n  'p': 'Hello World'\n};\n```\n\n上面代码中，大括号就定义了一个对象，它被赋值给变量`o`。这个对象内部包含一个键值对（又称为“成员”），`p`是“键名”（成员的名称），字符串“Hello World”是“键值”（成员的值）。键名与键值之间用冒号分隔。如果对象内部包含多个键值对，每个键值对之间用逗号分隔。\n\n### 键名\n\n对象的所有键名都是字符串，所以加不加引号都可以。上面的代码也可以写成下面这样。\n\n```javascript\nvar o = {\n  p: 'Hello World'\n};\n```\n\n但是，如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号。\n\n```javascript\nvar o = {\n  '1p': \"Hello World\",\n  'h w': \"Hello World\",\n  'p+q': \"Hello World\"\n};\n```\n\n上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。\n\n注意，JavaScript的保留字可以不加引号当作键名。\n\n```javascript\nvar obj = {\n  for: 1,\n  class: 2\n};\n```\n\n如果键名是数字，则会默认转为对应的字符串。\n\n```javascript\nvar obj = {\n  1e2: true,\n  1e-2: true,\n  .234: true,\n  0xFF: true,\n};\n\nObj\n// {\n//   100: true,\n//   255: true,\n//   0.01: true,\n//   0.234: true\n// }\n```\n\n上面代码表示，如果键名为数值，则会先转为标准形式的数值，然后再转为字符串。\n\n### 属性\n\n对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。\n\n```javascript\nvar o = {\n  p: function(x) {\n   return 2 * x;\n  }\n};\n\no.p(1)\n// 2\n```\n\n上面的对象就有一个方法`p`，它就是一个函数。\n\n对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。\n\n```javascript\nvar o = {\n  p: 123,\n  m: function () { ... },//这个逗号不能加\n}\n```\n\n上面的代码中m属性后面的那个逗号，有或没有都不算错。但是，ECMAScript 3不允许添加逗号，所以如果要兼容老式浏览器（比如IE 8），那就不能加这个逗号。\n\n### 生成方法\n\n对象的生成方法，通常有三种方法。除了像上面那样直接使用大括号生成（`{}`），还可以用`new`命令生成一个Object对象的实例，或者使用`Object.create`方法生成。\n\n```javascript\nvar o1 = {};\nvar o2 = new Object();// 可以简写为 var o2 = new Object; 但是不推荐\nvar o3 = Object.create(null);\n```\n\n上面三行语句是等价的。一般来说，第一种采用大括号的写法比较简洁，第二种采用构造函数的写法清晰地表示了意图，第三种写法一般用在需要对象继承的场合。关于第二种写法，详见《标准库》一章的Object对象一节，第三种写法详见《面向对象编程》一章。\n\n### 读写属性\n\n**（1）读取属性**\n\n读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。\n\n```javascript\nvar o = {\n  p: 'Hello World'\n};\n\no.p // \"Hello World\"\no['p'] // \"Hello World\"\n```\n\n上面代码分别采用点运算符和方括号运算符，读取属性`p`。\n\n请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。\n\n```javascript\nvar o = {\n  0.7: \"Hello World\"\n};\n\no.['0.7'] // \"Hello World\"\no[0.7] // \"Hello World\"\n```\n\n方括号运算符内部可以使用表达式。\n\n```javascript\no['hello' + ' world']\no[3 + 3]\n```\n\n数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。\n\n```javascript\nobj.0xFF\n// SyntaxError: Unexpected token\nobj[0xFF]\n// true\n```\n\n上面代码的第一个表达式，对数值键名0xFF使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。\n\n**（2）检查变量是否声明**\n\n如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个变量是否被声明。\n\n```javascript\n// 检查a变量是否被声明\n\nif(a) {...} // 报错\n\nif(window.a) {...} // 不报错\nif(window['a']) {...} // 不报错\n```\n\n上面的后两种写法之所以不报错，是因为在浏览器环境，所有全局变量都是window对象的属性。`window.`的含义就是读取window对象的a属性，如果该属性不存在，就返回undefined，并不会报错。需要注意的是，后两种写法有漏洞，如果a属性值是一个空字符串（或其对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。\n正确的写法是使用`in`运算符，或者使用Object原型的方法`hasOwnProperty()`也就是Object原型。\n\n```javascript\nif('a' in window) {\n  ...\n}\n\nif(window.hasOwnProperty(\"a\")) {\n  ...\n}\n```\n\n**（3）写入属性**\n\n点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。\n\n```javascript\no.p = 'abc';\no['p'] = 'abc';\n```\n\n上面代码分别使用点运算符和方括号运算符，对属性p赋值。\n\nJavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。\n\n```javascript\nvar o = { p: 1 };\n\n// 等价于\n\nvar o = {};\no.p = 1;\n```\n\n**（4）查看所有属性**\n\n`Object.keys()` 方法会返回一个由给定对象的所有**可枚举自身属性的属性名组成的数组**，数组中属性名的排列顺序和使用`for-in`循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。\n支持：`IE9+`(包括IE9)。\n\n```javascript\nvar o = {\n  key1: 1,\n  key2: 2\n};\n\nObject.keys(o);\n// ['key1', 'key2']\n```\n兼容处理方案：\n```javascirpt\nif (!Object.keys) {\n    Object.keys = function(o) {\n        if (o !== Object(o)) {\n            throw new TypeError('Object.keys called on a non-object');\n        }\n        var k = [],\n            p;\n        for (p in o) {\n            if (Object.prototype.hasOwnProperty.call(o, p)) {\n                k.push(p);\n            }\n        }\n        return k;\n    }\n}\n```\n\n### 属性的删除\n\n删除一个属性，需要使用`delete`命令。\n\n```javascript\nvar o = {p: 1};\nObject.keys(o) // [\"p\"]\n\ndelete o.p // true\no.p // undefined\nObject.keys(o) // []\n```\n\n上面代码表示，一旦使用`delete`命令删除某个属性，再读取该属性就会返回`undefined`，而且`Object.keys`方法返回的该对象的所有属性中，也将不再包括该属性。\n\n<span style=\"color: red;\">麻烦的是，如果删除一个不存在的属性，delete不报错，而且返回true。</span>\n\n```javascript\nvar o = {};\ndelete o.p // true\n```\n\n上面代码表示，delete命令只能用来保证某个属性的值为undefined，而无法保证该属性是否真的存在。\n\n只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。\n\n```javascript\n\nvar o = Object.defineProperty({}, \"p\", {\n        value: 123,\n        configurable: false\n});\n\no.p // 123\ndelete o.p // false\n\n```\n\n上面代码之中，o对象的p属性是不能删除的，所以delete命令返回false（关于Object.defineProperty方法的介绍，请看《标准库》一章的Object对象章节）。\n\n另外，需要注意的是，delete命令只能删除对象本身的属性，不能删除继承的属性（关于继承参见《面向对象编程》一节）。delete命令也不能删除var命令声明的变量，只能用来删除属性。\n\n### 对象的引用\n\n如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。\n\n```javascript\nvar o1 = {};\nvar o2 = o1;\n\no1.a = 1;\no2.a // 1\n\no2.b = 2;\no1.b // 2\n```\n\n上面代码中，`o1`和`o2`指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。\n\n此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。\n\n```javascript\nvar o1 = {};\nvar o2 = o1;\n\no1 = 1;\no2 // {}\n```\n\n上面代码中，`o1`和`o2`指向同一个对象，然后`o1`的值变为1，这时不会对`o2`产生影响，`o2`还是指向原来的那个对象。\n\n但是，这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。\n\n```javascript\nvar x = 1;\nvar y = x;\n\nx = 2;\ny // 1\n```\n\n上面的代码中，当`x`的值发生变化后，`y`的值并不变，这就表示`y`和`x`并不是指向同一个内存地址。\n\n### `in`运算符\n\n1. in操作符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。\n\n```javascript\nvar o = { p: 1 };\n'p' in o // true\n```\n\n2. 在JavaScript语言中，所有全局变量都是顶层对象（浏览器的顶层对象就是`window`对象）的属性，因此可以用`in`运算符判断，一个全局变量是否存在。\n\n```javascript\n// 假设变量x未定义\n\n// 写法一：报错\nif (x) { return 1; }\n\n// 写法二：不正确\nif (window.x) { return 1; }\n\n// 写法三：正确\nif ('x' in window) { return 1; }\nif ( x in window) { return 1; } // 注意x要用引号包括起来，是字符串\n```\n\n上面三种写法之中，如果`x`不存在，第一种写法会报错；如果`x`的值对应布尔值`false`（比如`x`等于空字符串），第二种写法无法得到正确结果；只有第三种写法，才能正确判断变量`x`是否存在。\n\n<span style=\"color: red;\">`in`运算符的一个问题是，它不能区分对象继承的属性。</span>\n\n```javascript\nvar o = new Object();\no.hasOwnProperty('toString') // false\n\n'toString' in o // true\n```\n\n上面代码中，`toString`方法不是对象`o`自身的属性，而是继承的属性，`hasOwnProperty`方法可以说明这一点。但是，`in`运算符不能区分，对继承的属性也返回`true`。\n3. in的右边必须是一个对象\n```javascript\nvar color1 = new String(\"green\");\n\"length\" in color1 // return true\nvar color2 = \"coral\";\n\"length\" in color2 // Uncaught TypeError: Cannot use 'in' operator to search for 'length' in coral(…)\n```\n4. 检验数组指定角标是否越界。\n```javascript\nvar trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");\n0 in trees        // returns true\n3 in trees        // returns true\n6 in trees        // returns false\n\"bay\" in trees    // returns false (you must specify the index number, not the value at that index)\n\"length\" in trees // returns true (length is an Array property)\n```\n5. 如果你使用`delete`操作符删除了一个属性或者把一个属性值设为`undefined`，再次用in检查时，会返回false，如：\n```javascript\nvar mycar = {make: \"Honda\", model: \"Accord\", year: 1998};\nmycar.make = undefined;\n\"make\" in mycar;  // return true\ndelete mycar.Accord;\n\"Accord\" in mycar;  // return false\n \n\nvar trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");\ntrees[3] = undefined;\n3 in trees; // return true\ndelete trees[2];\n2 in trees; // return false\n```\n6. 如果一个属性是从原型链上继承来的，in 运算符也会返回 true。\n```javascript\n\"toString\" in {}; // 返回true\n```\n### for...in循环\nfor...in 循环不遍历不可枚举属性。使用内建构造器例如 Array 和 Object 创建的对象拥有从 Object.prototype 和 String.prototype 继承的不可枚举属性，例如 String 的 indexOf()  方法或者 Object 的 toString 方法。循环将迭代对象的所有可枚举属性，包括从它的构造函数的 prototype 继承而来的（包括被覆盖的内建属性）。\n** 删除，添加或者修改属性 **\nfor...in 循环以任意序迭代一个对象的属性。通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。\n\n** Array 迭代和 for...in **\n数组索引仅是可枚举的整数名，其他方面和别的普通对象属性没有什么区别。for...in 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的。因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。 因此当迭代那些访问次序重要的 arrays 时用整数索引去进行 for 循环 (或者使用 Array.prototype.forEach() 或 for...of 循环) 。\n\n** 仅迭代自身的属性 **\n如果你只要考虑对象本身的属性，而不是它的原型，那么使用 `getOwnPropertyNames()`(自身的可枚举和不可枚举属性都能获得) 或执行  `hasOwnProperty()` 来确定某属性是否是对象本身的属性 (也能使用`propertyIsEnumerable`)。另外，如果你知道外部不存在任何的干扰代码，你可以扩展内置原型与检查方法。\n```javascript\nvar o = {a: 1, b: 2, c: 3};\n\nfor (i in o){\n  console.log(o[i]);\n}\n// 1\n// 2\n// 3\n```\n\n下面是一个使用`for...in`循环，进行数组赋值的例子。\n\n```javascript\nvar props = [], i = 0;\n\nfor (props[i++] in {x: 1, y: 2});//循环执行的时候会给每一个变量(`props[i++]`)赋`{x: 1, y: 2}`的属性值。\n\nprops // ['x', 'y']\n```\n\n注意，`for...in`循环遍历的是对象所有可enumberable的属性(属性特性[[enumberable]]为true)，其中不仅包括定义在对象本身的属性，还包括对象继承的属性。\n\n```javascript\n// name 是 Person 本身的属性\nfunction Person(name) {\n  this.name = name;\n}\n\n// describe是Person.prototype的属性\nPerson.prototype.describe = function () {\n  return 'Name: '+this.name;\n};\n\nvar person = new Person('Jane');\n\n// for...in循环会遍历实例自身的属性（name），\n// 以及继承的属性（describe）\nfor (var key in person) {\n  console.log(key);\n}\n// name\n// describe\n```\n\n上面代码中，`name`是对象本身的属性，`describe`是对象继承的属性，`for...in`循环的遍历会包括这两者。\n\n如果只想遍历对象本身的属性，可以使用hasOwnProperty方法，在循环内部做一个判断。\n\n```javascript\nfor (var key in person) {\n  if (person.hasOwnProperty(key)) {\n    console.log(key);\n  }\n}\n// name\n```\n\n为了避免这一点，可以新建一个继承`null`的对象。由于`null`没有任何属性，所以新对象也就不会有继承的属性了。\n\n## with语句\n\nwith语句的格式如下：\n\n```javascript\n\nwith (object)\n  statement\n\n```\n\n它的作用是操作同一个对象的多个属性时，提供一些书写的方便。\n\n```javascript\n\n// 例一\nwith (o) {\n  p1 = 1;\n  p2 = 2;\n}\n\n// 等同于\n\no.p1 = 1;\no.p2 = 2;\n\n// 例二\nwith (document.links[0]){\n  console.log(href);\n  console.log(title);\n  console.log(style);\n}\n\n// 等同于\n\nconsole.log(document.links[0].href);\nconsole.log(document.links[0].title);\nconsole.log(document.links[0].style);\n\n```\n\n注意，with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。\n\n```javascript\n\nvar o = {};\n\nwith (o){\n  x = \"abc\";\n}\n\no.x\n// undefined\n\nx\n// \"abc\"\n\n```\n\n上面代码中，对象o没有属性x，所以with区块内部对x的操作，等于创造了一个全局变量x。正确的写法应该是，先定义对象o的属性x，然后在with区块内操作它。\n\n```javascript\n\nvar o = {};\n\no.x = 1;\n\nwith (o){\n  x = 2;\n}\n\no.x\n// 2\n\n```\n\n这是with语句的一个很大的弊病，就是绑定对象不明确。\n\n```javascript\n\nwith (o) {\n  console.log(x);\n}\n\n```\n\n单纯从上面的代码块，根本无法判断x到底是全局变量，还是o对象的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。\n\n```javascript\n\nwith(o1.o2.o3) {\n  console.log(p1 + p2);\n}\n\n// 可以写成\n\nvar temp = o1.o2.o3;\nconsole.log(temp.p1 + temp.p2);\n\n```\n\nwith语句少数有用场合之一，就是替换模板变量。\n\n```javascript\nvar str = 'Hello <%= name %>!';\n```\n\n上面代码是一个模板字符串，为了替换其中的变量name，可以先将其分解成三部分`'Hello ', name, '!'`，然后进行模板变量替换。\n\n```javascript\n\nvar o = {\n  name: 'Alice'\n};\n\nvar p = [];\nvar tmpl = '';\n\nwith(o){\n  p.push('Hello ', name, '!');\n};\n\np.join('') // \"Hello Alice!\"\n```\n\n上面代码中，with区块内部，模板变量name可以被对象o的属性替换，而p依然是全局变量。事实上，这就是很多模板引擎的实现原理。\n\n## Object 简介\n\nJavaScript原生提供一个Object对象（注意起首的O是大写），所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。\nObject 的每个实例也就是Object原型 prototype 具有下列属性和方法：\n```javascript\nvar o = new Object; // 有效，但不推荐省略圆括号\n```\n* `constructor`：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（`constructor`）就是Object()。\n* `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(\"name\")）。\n* `isPrototypeOf(object)`：用于检查传入的对象是否是传入对象的原型（第5 章将讨论原型）。\n* `propertyIsEnumerable(propertyName)`：用于检查给定的属性是否能够使用for-in 语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。\n* `toLocaleString()`：返回对象的字符串表示，该字符串与执行环境的地区对应。\n* `toString()`：返回对象的字符串表示。\n* `valueOf()`：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。\n* `__defineGetter__()`\n* `__defineSetter__()`\n* `__lookupGetter__()`\n* `__lookupSetter__()`\n* `get __proto__()` //不可被显示调用(`.`出来)\n* `set __proto__()` //不可被显示调用(`.`出来)\n\n还有一些其他方法据各个浏览器厂商的实现来定，比如firefox还有`toSource()`、`watch()`、 `unwatch()`，这些内容不做过多介绍，毕竟不是标准。后面将会对这些方法做详细介绍。\n> [阮一峰](http://javascript.ruanyifeng.com/)","source":"_posts/好好学学Object-2016-02-03.md","raw":"title: 好好学学Object!\ndate: 2016-02-03 16:09:30\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n## 概述\n\n### 定义方法\n\n对象（object）是JavaScript的核心概念，也是最重要的数据类型。JavaScript的所有数据都可以被视为对象。\n简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。\n<!--more-->\n\n```javascript\nvar o = {\n  'p': 'Hello World'\n};\n```\n\n上面代码中，大括号就定义了一个对象，它被赋值给变量`o`。这个对象内部包含一个键值对（又称为“成员”），`p`是“键名”（成员的名称），字符串“Hello World”是“键值”（成员的值）。键名与键值之间用冒号分隔。如果对象内部包含多个键值对，每个键值对之间用逗号分隔。\n\n### 键名\n\n对象的所有键名都是字符串，所以加不加引号都可以。上面的代码也可以写成下面这样。\n\n```javascript\nvar o = {\n  p: 'Hello World'\n};\n```\n\n但是，如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号。\n\n```javascript\nvar o = {\n  '1p': \"Hello World\",\n  'h w': \"Hello World\",\n  'p+q': \"Hello World\"\n};\n```\n\n上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。\n\n注意，JavaScript的保留字可以不加引号当作键名。\n\n```javascript\nvar obj = {\n  for: 1,\n  class: 2\n};\n```\n\n如果键名是数字，则会默认转为对应的字符串。\n\n```javascript\nvar obj = {\n  1e2: true,\n  1e-2: true,\n  .234: true,\n  0xFF: true,\n};\n\nObj\n// {\n//   100: true,\n//   255: true,\n//   0.01: true,\n//   0.234: true\n// }\n```\n\n上面代码表示，如果键名为数值，则会先转为标准形式的数值，然后再转为字符串。\n\n### 属性\n\n对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。\n\n```javascript\nvar o = {\n  p: function(x) {\n   return 2 * x;\n  }\n};\n\no.p(1)\n// 2\n```\n\n上面的对象就有一个方法`p`，它就是一个函数。\n\n对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。\n\n```javascript\nvar o = {\n  p: 123,\n  m: function () { ... },//这个逗号不能加\n}\n```\n\n上面的代码中m属性后面的那个逗号，有或没有都不算错。但是，ECMAScript 3不允许添加逗号，所以如果要兼容老式浏览器（比如IE 8），那就不能加这个逗号。\n\n### 生成方法\n\n对象的生成方法，通常有三种方法。除了像上面那样直接使用大括号生成（`{}`），还可以用`new`命令生成一个Object对象的实例，或者使用`Object.create`方法生成。\n\n```javascript\nvar o1 = {};\nvar o2 = new Object();// 可以简写为 var o2 = new Object; 但是不推荐\nvar o3 = Object.create(null);\n```\n\n上面三行语句是等价的。一般来说，第一种采用大括号的写法比较简洁，第二种采用构造函数的写法清晰地表示了意图，第三种写法一般用在需要对象继承的场合。关于第二种写法，详见《标准库》一章的Object对象一节，第三种写法详见《面向对象编程》一章。\n\n### 读写属性\n\n**（1）读取属性**\n\n读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。\n\n```javascript\nvar o = {\n  p: 'Hello World'\n};\n\no.p // \"Hello World\"\no['p'] // \"Hello World\"\n```\n\n上面代码分别采用点运算符和方括号运算符，读取属性`p`。\n\n请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。\n\n```javascript\nvar o = {\n  0.7: \"Hello World\"\n};\n\no.['0.7'] // \"Hello World\"\no[0.7] // \"Hello World\"\n```\n\n方括号运算符内部可以使用表达式。\n\n```javascript\no['hello' + ' world']\no[3 + 3]\n```\n\n数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。\n\n```javascript\nobj.0xFF\n// SyntaxError: Unexpected token\nobj[0xFF]\n// true\n```\n\n上面代码的第一个表达式，对数值键名0xFF使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。\n\n**（2）检查变量是否声明**\n\n如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个变量是否被声明。\n\n```javascript\n// 检查a变量是否被声明\n\nif(a) {...} // 报错\n\nif(window.a) {...} // 不报错\nif(window['a']) {...} // 不报错\n```\n\n上面的后两种写法之所以不报错，是因为在浏览器环境，所有全局变量都是window对象的属性。`window.`的含义就是读取window对象的a属性，如果该属性不存在，就返回undefined，并不会报错。需要注意的是，后两种写法有漏洞，如果a属性值是一个空字符串（或其对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。\n正确的写法是使用`in`运算符，或者使用Object原型的方法`hasOwnProperty()`也就是Object原型。\n\n```javascript\nif('a' in window) {\n  ...\n}\n\nif(window.hasOwnProperty(\"a\")) {\n  ...\n}\n```\n\n**（3）写入属性**\n\n点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。\n\n```javascript\no.p = 'abc';\no['p'] = 'abc';\n```\n\n上面代码分别使用点运算符和方括号运算符，对属性p赋值。\n\nJavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。\n\n```javascript\nvar o = { p: 1 };\n\n// 等价于\n\nvar o = {};\no.p = 1;\n```\n\n**（4）查看所有属性**\n\n`Object.keys()` 方法会返回一个由给定对象的所有**可枚举自身属性的属性名组成的数组**，数组中属性名的排列顺序和使用`for-in`循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。\n支持：`IE9+`(包括IE9)。\n\n```javascript\nvar o = {\n  key1: 1,\n  key2: 2\n};\n\nObject.keys(o);\n// ['key1', 'key2']\n```\n兼容处理方案：\n```javascirpt\nif (!Object.keys) {\n    Object.keys = function(o) {\n        if (o !== Object(o)) {\n            throw new TypeError('Object.keys called on a non-object');\n        }\n        var k = [],\n            p;\n        for (p in o) {\n            if (Object.prototype.hasOwnProperty.call(o, p)) {\n                k.push(p);\n            }\n        }\n        return k;\n    }\n}\n```\n\n### 属性的删除\n\n删除一个属性，需要使用`delete`命令。\n\n```javascript\nvar o = {p: 1};\nObject.keys(o) // [\"p\"]\n\ndelete o.p // true\no.p // undefined\nObject.keys(o) // []\n```\n\n上面代码表示，一旦使用`delete`命令删除某个属性，再读取该属性就会返回`undefined`，而且`Object.keys`方法返回的该对象的所有属性中，也将不再包括该属性。\n\n<span style=\"color: red;\">麻烦的是，如果删除一个不存在的属性，delete不报错，而且返回true。</span>\n\n```javascript\nvar o = {};\ndelete o.p // true\n```\n\n上面代码表示，delete命令只能用来保证某个属性的值为undefined，而无法保证该属性是否真的存在。\n\n只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。\n\n```javascript\n\nvar o = Object.defineProperty({}, \"p\", {\n        value: 123,\n        configurable: false\n});\n\no.p // 123\ndelete o.p // false\n\n```\n\n上面代码之中，o对象的p属性是不能删除的，所以delete命令返回false（关于Object.defineProperty方法的介绍，请看《标准库》一章的Object对象章节）。\n\n另外，需要注意的是，delete命令只能删除对象本身的属性，不能删除继承的属性（关于继承参见《面向对象编程》一节）。delete命令也不能删除var命令声明的变量，只能用来删除属性。\n\n### 对象的引用\n\n如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。\n\n```javascript\nvar o1 = {};\nvar o2 = o1;\n\no1.a = 1;\no2.a // 1\n\no2.b = 2;\no1.b // 2\n```\n\n上面代码中，`o1`和`o2`指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。\n\n此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。\n\n```javascript\nvar o1 = {};\nvar o2 = o1;\n\no1 = 1;\no2 // {}\n```\n\n上面代码中，`o1`和`o2`指向同一个对象，然后`o1`的值变为1，这时不会对`o2`产生影响，`o2`还是指向原来的那个对象。\n\n但是，这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。\n\n```javascript\nvar x = 1;\nvar y = x;\n\nx = 2;\ny // 1\n```\n\n上面的代码中，当`x`的值发生变化后，`y`的值并不变，这就表示`y`和`x`并不是指向同一个内存地址。\n\n### `in`运算符\n\n1. in操作符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。\n\n```javascript\nvar o = { p: 1 };\n'p' in o // true\n```\n\n2. 在JavaScript语言中，所有全局变量都是顶层对象（浏览器的顶层对象就是`window`对象）的属性，因此可以用`in`运算符判断，一个全局变量是否存在。\n\n```javascript\n// 假设变量x未定义\n\n// 写法一：报错\nif (x) { return 1; }\n\n// 写法二：不正确\nif (window.x) { return 1; }\n\n// 写法三：正确\nif ('x' in window) { return 1; }\nif ( x in window) { return 1; } // 注意x要用引号包括起来，是字符串\n```\n\n上面三种写法之中，如果`x`不存在，第一种写法会报错；如果`x`的值对应布尔值`false`（比如`x`等于空字符串），第二种写法无法得到正确结果；只有第三种写法，才能正确判断变量`x`是否存在。\n\n<span style=\"color: red;\">`in`运算符的一个问题是，它不能区分对象继承的属性。</span>\n\n```javascript\nvar o = new Object();\no.hasOwnProperty('toString') // false\n\n'toString' in o // true\n```\n\n上面代码中，`toString`方法不是对象`o`自身的属性，而是继承的属性，`hasOwnProperty`方法可以说明这一点。但是，`in`运算符不能区分，对继承的属性也返回`true`。\n3. in的右边必须是一个对象\n```javascript\nvar color1 = new String(\"green\");\n\"length\" in color1 // return true\nvar color2 = \"coral\";\n\"length\" in color2 // Uncaught TypeError: Cannot use 'in' operator to search for 'length' in coral(…)\n```\n4. 检验数组指定角标是否越界。\n```javascript\nvar trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");\n0 in trees        // returns true\n3 in trees        // returns true\n6 in trees        // returns false\n\"bay\" in trees    // returns false (you must specify the index number, not the value at that index)\n\"length\" in trees // returns true (length is an Array property)\n```\n5. 如果你使用`delete`操作符删除了一个属性或者把一个属性值设为`undefined`，再次用in检查时，会返回false，如：\n```javascript\nvar mycar = {make: \"Honda\", model: \"Accord\", year: 1998};\nmycar.make = undefined;\n\"make\" in mycar;  // return true\ndelete mycar.Accord;\n\"Accord\" in mycar;  // return false\n \n\nvar trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");\ntrees[3] = undefined;\n3 in trees; // return true\ndelete trees[2];\n2 in trees; // return false\n```\n6. 如果一个属性是从原型链上继承来的，in 运算符也会返回 true。\n```javascript\n\"toString\" in {}; // 返回true\n```\n### for...in循环\nfor...in 循环不遍历不可枚举属性。使用内建构造器例如 Array 和 Object 创建的对象拥有从 Object.prototype 和 String.prototype 继承的不可枚举属性，例如 String 的 indexOf()  方法或者 Object 的 toString 方法。循环将迭代对象的所有可枚举属性，包括从它的构造函数的 prototype 继承而来的（包括被覆盖的内建属性）。\n** 删除，添加或者修改属性 **\nfor...in 循环以任意序迭代一个对象的属性。通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。\n\n** Array 迭代和 for...in **\n数组索引仅是可枚举的整数名，其他方面和别的普通对象属性没有什么区别。for...in 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的。因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。 因此当迭代那些访问次序重要的 arrays 时用整数索引去进行 for 循环 (或者使用 Array.prototype.forEach() 或 for...of 循环) 。\n\n** 仅迭代自身的属性 **\n如果你只要考虑对象本身的属性，而不是它的原型，那么使用 `getOwnPropertyNames()`(自身的可枚举和不可枚举属性都能获得) 或执行  `hasOwnProperty()` 来确定某属性是否是对象本身的属性 (也能使用`propertyIsEnumerable`)。另外，如果你知道外部不存在任何的干扰代码，你可以扩展内置原型与检查方法。\n```javascript\nvar o = {a: 1, b: 2, c: 3};\n\nfor (i in o){\n  console.log(o[i]);\n}\n// 1\n// 2\n// 3\n```\n\n下面是一个使用`for...in`循环，进行数组赋值的例子。\n\n```javascript\nvar props = [], i = 0;\n\nfor (props[i++] in {x: 1, y: 2});//循环执行的时候会给每一个变量(`props[i++]`)赋`{x: 1, y: 2}`的属性值。\n\nprops // ['x', 'y']\n```\n\n注意，`for...in`循环遍历的是对象所有可enumberable的属性(属性特性[[enumberable]]为true)，其中不仅包括定义在对象本身的属性，还包括对象继承的属性。\n\n```javascript\n// name 是 Person 本身的属性\nfunction Person(name) {\n  this.name = name;\n}\n\n// describe是Person.prototype的属性\nPerson.prototype.describe = function () {\n  return 'Name: '+this.name;\n};\n\nvar person = new Person('Jane');\n\n// for...in循环会遍历实例自身的属性（name），\n// 以及继承的属性（describe）\nfor (var key in person) {\n  console.log(key);\n}\n// name\n// describe\n```\n\n上面代码中，`name`是对象本身的属性，`describe`是对象继承的属性，`for...in`循环的遍历会包括这两者。\n\n如果只想遍历对象本身的属性，可以使用hasOwnProperty方法，在循环内部做一个判断。\n\n```javascript\nfor (var key in person) {\n  if (person.hasOwnProperty(key)) {\n    console.log(key);\n  }\n}\n// name\n```\n\n为了避免这一点，可以新建一个继承`null`的对象。由于`null`没有任何属性，所以新对象也就不会有继承的属性了。\n\n## with语句\n\nwith语句的格式如下：\n\n```javascript\n\nwith (object)\n  statement\n\n```\n\n它的作用是操作同一个对象的多个属性时，提供一些书写的方便。\n\n```javascript\n\n// 例一\nwith (o) {\n  p1 = 1;\n  p2 = 2;\n}\n\n// 等同于\n\no.p1 = 1;\no.p2 = 2;\n\n// 例二\nwith (document.links[0]){\n  console.log(href);\n  console.log(title);\n  console.log(style);\n}\n\n// 等同于\n\nconsole.log(document.links[0].href);\nconsole.log(document.links[0].title);\nconsole.log(document.links[0].style);\n\n```\n\n注意，with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。\n\n```javascript\n\nvar o = {};\n\nwith (o){\n  x = \"abc\";\n}\n\no.x\n// undefined\n\nx\n// \"abc\"\n\n```\n\n上面代码中，对象o没有属性x，所以with区块内部对x的操作，等于创造了一个全局变量x。正确的写法应该是，先定义对象o的属性x，然后在with区块内操作它。\n\n```javascript\n\nvar o = {};\n\no.x = 1;\n\nwith (o){\n  x = 2;\n}\n\no.x\n// 2\n\n```\n\n这是with语句的一个很大的弊病，就是绑定对象不明确。\n\n```javascript\n\nwith (o) {\n  console.log(x);\n}\n\n```\n\n单纯从上面的代码块，根本无法判断x到底是全局变量，还是o对象的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。\n\n```javascript\n\nwith(o1.o2.o3) {\n  console.log(p1 + p2);\n}\n\n// 可以写成\n\nvar temp = o1.o2.o3;\nconsole.log(temp.p1 + temp.p2);\n\n```\n\nwith语句少数有用场合之一，就是替换模板变量。\n\n```javascript\nvar str = 'Hello <%= name %>!';\n```\n\n上面代码是一个模板字符串，为了替换其中的变量name，可以先将其分解成三部分`'Hello ', name, '!'`，然后进行模板变量替换。\n\n```javascript\n\nvar o = {\n  name: 'Alice'\n};\n\nvar p = [];\nvar tmpl = '';\n\nwith(o){\n  p.push('Hello ', name, '!');\n};\n\np.join('') // \"Hello Alice!\"\n```\n\n上面代码中，with区块内部，模板变量name可以被对象o的属性替换，而p依然是全局变量。事实上，这就是很多模板引擎的实现原理。\n\n## Object 简介\n\nJavaScript原生提供一个Object对象（注意起首的O是大写），所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。\nObject 的每个实例也就是Object原型 prototype 具有下列属性和方法：\n```javascript\nvar o = new Object; // 有效，但不推荐省略圆括号\n```\n* `constructor`：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（`constructor`）就是Object()。\n* `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(\"name\")）。\n* `isPrototypeOf(object)`：用于检查传入的对象是否是传入对象的原型（第5 章将讨论原型）。\n* `propertyIsEnumerable(propertyName)`：用于检查给定的属性是否能够使用for-in 语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。\n* `toLocaleString()`：返回对象的字符串表示，该字符串与执行环境的地区对应。\n* `toString()`：返回对象的字符串表示。\n* `valueOf()`：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。\n* `__defineGetter__()`\n* `__defineSetter__()`\n* `__lookupGetter__()`\n* `__lookupSetter__()`\n* `get __proto__()` //不可被显示调用(`.`出来)\n* `set __proto__()` //不可被显示调用(`.`出来)\n\n还有一些其他方法据各个浏览器厂商的实现来定，比如firefox还有`toSource()`、`watch()`、 `unwatch()`，这些内容不做过多介绍，毕竟不是标准。后面将会对这些方法做详细介绍。\n> [阮一峰](http://javascript.ruanyifeng.com/)","slug":"好好学学Object","published":1,"updated":"2016-02-04T09:35:33.000Z","_id":"cik6o7io40000503vpbmcs0a3","layout":"post","photos":[],"link":""}],"PostAsset":[{"_id":"source/_posts/好好学学number-2016-01-29/number.png","post":"cik6o5exx000c703vahn838t7","slug":"number.png","modified":1},{"_id":"source/_posts/好好学学number-2016-01-29/number2.png","post":"cik6o5exx000c703vahn838t7","slug":"number2.png","modified":1},{"_id":"source/_posts/严格模式-2016-01-21/stracit.png","post":"cik6o5eys000i703v2retavfp","slug":"stracit.png","modified":1},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/onLoadVSDomContentLoaded.png","post":"cik6o5ezg000u703v9lkfqdvm","slug":"onLoadVSDomContentLoaded.png","modified":1},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/zongjie.png","post":"cik6o5ezg000u703v9lkfqdvm","slug":"zongjie.png","modified":1},{"_id":"source/_posts/2-在HTML中使用JavaScrpt-2016-01-05/deferAsync.png","post":"cik6o5ezx0012703vpugdckxg","slug":"deferAsync.png","modified":1}],"PostCategory":[{"post_id":"cik6o5exg0002703vwh5xz5cn","category_id":"cik6o5exl0003703v50uzz643","_id":"cik6o5exp0006703vi2uzppf5"},{"post_id":"cik6o5exr0007703vfobfeacl","category_id":"cik6o5exl0003703v50uzz643","_id":"cik6o5ext0008703v18d5dfmg"},{"post_id":"cik6o5exx000c703vahn838t7","category_id":"cik6o5exl0003703v50uzz643","_id":"cik6o5exy000d703v48sxl9sr"},{"post_id":"cik6o5eyf000f703vkugxa669","category_id":"cik6o5exl0003703v50uzz643","_id":"cik6o5eyg000g703vjlbgmels"},{"post_id":"cik6o5eys000i703v2retavfp","category_id":"cik6o5exl0003703v50uzz643","_id":"cik6o5eyt000j703v6lojn2f1"},{"post_id":"cik6o5ez1000m703vllb7fg9v","category_id":"cik6o5exl0003703v50uzz643","_id":"cik6o5ez2000n703v47jy1sl6"},{"post_id":"cik6o5ez5000p703veesp2h8q","category_id":"cik6o5exl0003703v50uzz643","_id":"cik6o5ez6000q703vjckot6jv"},{"post_id":"cik6o5ezg000u703v9lkfqdvm","category_id":"cik6o5exl0003703v50uzz643","_id":"cik6o5ezh000v703vjxlpytl1"},{"post_id":"cik6o5ezp000y703v2cl4ksmv","category_id":"cik6o5ezq000z703vta55p519","_id":"cik6o5ezs0011703vjt60f62m"},{"post_id":"cik6o5ezx0012703vpugdckxg","category_id":"cik6o5ezq000z703vta55p519","_id":"cik6o5ezy0013703v5lzf61gt"},{"post_id":"cik6o5f030015703vwedtovfc","category_id":"cik6o5ezq000z703vta55p519","_id":"cik6o5f040016703v9mvptdj4"},{"post_id":"cik6o7io40000503vpbmcs0a3","category_id":"cik6o5ezq000z703vta55p519","_id":"cik82ilwp0000mw3vn9o4vz8j"}],"PostTag":[{"post_id":"cik6o5exg0002703vwh5xz5cn","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5exo0005703vlci3xmid"},{"post_id":"cik6o5exr0007703vfobfeacl","tag_id":"cik6o5ext0009703v1qoq2i3z","_id":"cik6o5exu000a703vhy1udxl3"},{"post_id":"cik6o5exr0007703vfobfeacl","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5exv000b703v52em7n8q"},{"post_id":"cik6o5exx000c703vahn838t7","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5exy000e703v2w7qnrqx"},{"post_id":"cik6o5eyf000f703vkugxa669","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5eyh000h703vwfgcie41"},{"post_id":"cik6o5eys000i703v2retavfp","tag_id":"cik6o5ext0009703v1qoq2i3z","_id":"cik6o5eyu000k703vn622im1v"},{"post_id":"cik6o5eys000i703v2retavfp","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5eyu000l703vdcs4dpmm"},{"post_id":"cik6o5ez1000m703vllb7fg9v","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5ez3000o703vrjn79b78"},{"post_id":"cik6o5ez5000p703veesp2h8q","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5ez7000r703vsv3aas3f"},{"post_id":"cik6o5ezb000s703voklcdhai","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5ezd000t703vie4vu3lm"},{"post_id":"cik6o5ezg000u703v9lkfqdvm","tag_id":"cik6o5ext0009703v1qoq2i3z","_id":"cik6o5ezi000w703vrpfnkyvg"},{"post_id":"cik6o5ezg000u703v9lkfqdvm","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5ezi000x703vrpe8c35x"},{"post_id":"cik6o5ezp000y703v2cl4ksmv","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5ezr0010703v9i2ieuh3"},{"post_id":"cik6o5ezx0012703vpugdckxg","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5ezy0014703v262gmtz3"},{"post_id":"cik6o5f030015703vwedtovfc","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o5f050017703v5g61u357"},{"post_id":"cik6o7io40000503vpbmcs0a3","tag_id":"cik6o5exm0004703vryydgs8v","_id":"cik6o7io90002503v8nnarhy2"}],"Tag":[{"name":"JavaScript","_id":"cik6o5exm0004703vryydgs8v"},{"name":"jQuery","_id":"cik6o5ext0009703v1qoq2i3z"}]}}