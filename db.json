{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":0},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":0},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":0},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":0},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":0},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":0},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":0},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":0},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":0},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":0},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":0},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":0},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":0},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":0},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":0},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"source/CNAME","path":"CNAME","modified":0}],"Cache":[{"_id":"source/404.html","shasum":"9ae5313c4ee64f8060cd08bad8a6a8270e0bd02c","modified":1452479190000},{"_id":"source/CNAME","shasum":"5bea78925f82297f017d461af01317b7a493d489","modified":1452478547000},{"_id":"source/_posts/1-JavaScrpt简介-2016-01-05.md","shasum":"9521e1c2ac8f8aa0eccd17436d6ba58f2d7444c2","modified":1464748430000},{"_id":"source/_posts/2-在HTML中使用JavaScrpt-2016-01-05/deferAsync.png","shasum":"405aba297cb925c030bc11878e291edc350b3645","modified":1452171438000},{"_id":"source/_posts/2-在HTML中使用JavaScrpt-2016-01-05.md","shasum":"d77e07306640d0f9e47badadc248b289b5c4c4be","modified":1464762496000},{"_id":"source/_posts/3-第三章基本概念-2016-01-20.md","shasum":"6a9c2079c4615f48075cd8779e923e52ab44cead","modified":1465396421000},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/zongjie.png","shasum":"75b021d03703a62dffca85d21065daa074d2edc4","modified":1452226722000},{"_id":"source/_posts/ECMAScrip中的对象存取器-getter和setter-2016-01-21.md","shasum":"53477985cd52e20b2a72c148a3cd7dc49fb96423","modified":1453369070000},{"_id":"source/_posts/DOMContentLoaded-2016-01-08.md","shasum":"2a5ee0b40a0dfd790fd425e0142a5bffe65c21dc","modified":1464762310000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image1.jpg","shasum":"2b16d4501fb5d96aa74bce522bf6619d271da92e","modified":1456108013000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image11.png","shasum":"5b867713120981fef57c0e51401e3523bb624e13","modified":1456111149000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image12.png","shasum":"c37c65adbceeb24bcc04f6aee94ad9c3257f07d3","modified":1456111158000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image10.png","shasum":"38c20cf85e288d828a624ca4fd788fbb41039a38","modified":1456110979000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image14.png","shasum":"effec54c0893d59927ebac1f013f9bf014d9824f","modified":1456111618000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image2.jpg","shasum":"4646bac94ab4efc141bcfc59fdb51d9cf066d53f","modified":1456108328000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image3.jpg","shasum":"3477936fdd2cfa5015c19d59c3748d719f0ca7aa","modified":1456108521000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image13.png","shasum":"84ccfcdeac04e66582513c359e214d1a3dc8b6fd","modified":1456111583000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image5.png","shasum":"9395a1e25f7e8c1e5bc05b2a89e594ad05deb220","modified":1456110040000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image6.png","shasum":"effec54c0893d59927ebac1f013f9bf014d9824f","modified":1456110308000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image4.jpg","shasum":"4646bac94ab4efc141bcfc59fdb51d9cf066d53f","modified":1456109175000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image7.png","shasum":"52f3f014bf0872c3d005b8fcf4773d0874bf716c","modified":1456110827000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image8.png","shasum":"b93b45193c3ab0bf72788a61bb6c25ecd7cab2b0","modified":1456110952000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image9.png","shasum":"9cccf45e61ce8b329c14f97ae3579ddf5a282544","modified":1456110968000},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22.md","shasum":"d6c5bff06ffb94bc54ff00b075228029cd0a06ef","modified":1456112112000},{"_id":"source/_posts/numberInJavaScript-2016-06-19/10.png","shasum":"28c156f84f848b99836643da8c012569a5fe60b8","modified":1466341422000},{"_id":"source/_posts/numberInJavaScript-2016-06-19/123.png","shasum":"a2bedb9531ae71ecb62babb3353024ca1a235965","modified":1466337849000},{"_id":"source/_posts/numberInJavaScript-2016-06-19/11.png","shasum":"4d846b73a61ab526358e65b60e6cbd36a6315e81","modified":1466341543000},{"_id":"source/_posts/numberInJavaScript-2016-06-19/32.png","shasum":"f3f668acfda2b4d3a13904e306bbbf37250106ae","modified":1465540260000},{"_id":"source/_posts/numberInJavaScript-2016-06-19/456.jpg","shasum":"a288a59a9909a28c4315a3b1f0c5e78ff7d2c71f","modified":1466337862000},{"_id":"source/_posts/numberInJavaScript-2016-06-19/64.png","shasum":"3be28f0630aaeca21f91282fe55a9d9e8b73335c","modified":1465540266000},{"_id":"source/_posts/numberInJavaScript-2016-06-19/789.jpg","shasum":"a288a59a9909a28c4315a3b1f0c5e78ff7d2c71f","modified":1466337870000},{"_id":"source/_posts/void-0-2016-01-29.md","shasum":"1e741ccc4b7fd2bb5df3f38c5520707167644e9e","modified":1454053234000},{"_id":"source/_posts/numberInJavaScript-2016-06-19.md","shasum":"480fe3d710580dffd878e4e8eebdd242d7684736","modified":1466344353000},{"_id":"source/_posts/严格模式-2016-01-21/stracit.png","shasum":"79f6c9b89a2d7551182e34520bd2b55d84d279dc","modified":1454471627000},{"_id":"source/_posts/好好学学String-2016-02-02.md","shasum":"843d01d0c0198acda3e6de551e1436db87462e72","modified":1454487014000},{"_id":"source/_posts/严格模式-2016-01-21.md","shasum":"d4ac42fab875f539396abd6aa01ed54f1fed4bad","modified":1465310917000},{"_id":"source/_posts/好好学学Object-2016-02-03.md","shasum":"f0401d67ce0f90167b137526385ebc8d54024102","modified":1465618687000},{"_id":"source/_posts/webkit的预加载扫描器-2016-01-19.md","shasum":"c8b9ebe46cdb0553b9cba8e0a1accc4499da7911","modified":1453208403000},{"_id":"source/_posts/好好学学number-2016-01-29.md","shasum":"28aadeb414a40f3b44be93b8d707d42721415bbe","modified":1465621061000},{"_id":"source/_posts/如何学习javascript-转帖-2016-01-27.md","shasum":"86d88de583c4d5b64794f5feb02d861820a8a022","modified":1453862572000},{"_id":"source/_posts/类型检验-2016-02-19.md","shasum":"4479d37a543ba10a50d4e38a84e3e3e73db28463","modified":1465622802000},{"_id":"source/_posts/类型检验-2016-02-19/type.jpg","shasum":"2b4ee2768ce5350fc369e0e78ae5631804cdaf62","modified":1455854375000},{"_id":"source/_posts/类型转换-2016-02-18.md","shasum":"e672d58fe9ead2e0c65a3dd0207e34fa71f8a543","modified":1465626489000},{"_id":"source/_posts/运算符-2016-02-25.md","shasum":"150888bf7f4183798cb153f1257fcf2df67c7332","modified":1465631311000},{"_id":"source/baidu_verify_i0wnrfk2ui.html","shasum":"48d9c82953f45c582fba83160d71d4df0ec7103f","modified":1452572516000},{"_id":"source/_posts/好好学学undefined！-2016-01-29.md","shasum":"c304d31e6e9a40b76029b7aeed201c3f6dab78ee","modified":1454392617000},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/onLoadVSDomContentLoaded.png","shasum":"597586264b44d04e58387eb02379818a338627b1","modified":1452220118000},{"_id":"source/_posts/好好学学number-2016-01-29/number.png","shasum":"6d0564a349b5e99daa5b5588314b3a4ce45f7fd1","modified":1453980343000},{"_id":"source/_posts/好好学学number-2016-01-29/number2.png","shasum":"2735883e61ae234615de6234b9280f12a4e4ba47","modified":1454043023000},{"_id":"themes/jacman/LICENSE","shasum":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1450859342000},{"_id":"themes/jacman/README.md","shasum":"79be8a49927c8666f1804d7ccd08af8d3268062a","modified":1450859342000},{"_id":"themes/jacman/README_zh.md","shasum":"0854e4c96f53005f3a47e21af3f8aee361719ce4","modified":1450859342000},{"_id":"themes/jacman/_config.yml","shasum":"ec3e1c2147b1223cf10a14ba768a931a2e13f31d","modified":1452228411000},{"_id":"themes/jacman/languages/default.yml","shasum":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1450859342000},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1450859342000},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"f0772c9de0431384d4e852358ee425a1cdf3ea6d","modified":1453707593000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"32db7e7c8171530d29c3878f387c4438d6057508","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"c4f527fff0070fbe65919053a16224412317f40d","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","shasum":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1450859342000},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1450859342000},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1450859342000},{"_id":"themes/jacman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1450859342000},{"_id":"themes/jacman/layout/layout.ejs","shasum":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1450859342000},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","shasum":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1450859342000},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"f016180726019927b9a835ed01e04d153f27a149","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1450859342000},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1450859342000},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"1136600932b97534b88465bf05ef313630b2de3d","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1450859342000},{"_id":"themes/jacman/source/css/style.styl","shasum":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","shasum":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1450859342000},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1450859342000},{"_id":"themes/jacman/source/img/author.jpg","shasum":"2a292e681b4c6c975eec9c8c356d99647a465542","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1450859342000},{"_id":"themes/jacman/source/img/favicon.ico","shasum":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1450859342000},{"_id":"themes/jacman/source/img/jacman.jpg","shasum":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1450859342000},{"_id":"themes/jacman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1450859342000},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1450859342000},{"_id":"themes/jacman/source/img/logo.svg","shasum":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1450859342000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1450859342000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","shasum":"57c3987166a26415a71292162690e82c21e315ad","modified":1450859342000},{"_id":"themes/jacman/source/js/totop.js","shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1450859342000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1450859342000},{"_id":"themes/jacman/source/img/logo.png","shasum":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1450859342000},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1450859342000},{"_id":"public/2016/02/19/类型检验/type.jpg","modified":1466344434314,"shasum":"2b4ee2768ce5350fc369e0e78ae5631804cdaf62"},{"_id":"public/2016/01/29/好好学学number/number.png","modified":1466344434320,"shasum":"6d0564a349b5e99daa5b5588314b3a4ce45f7fd1"},{"_id":"public/2016/01/29/好好学学number/number2.png","modified":1466344434326,"shasum":"2735883e61ae234615de6234b9280f12a4e4ba47"},{"_id":"public/2016/01/21/严格模式/stracit.png","modified":1466344434330,"shasum":"79f6c9b89a2d7551182e34520bd2b55d84d279dc"},{"_id":"public/2016/06/19/numberInJavaScript/10.png","modified":1466344434334,"shasum":"28c156f84f848b99836643da8c012569a5fe60b8"},{"_id":"public/2016/06/19/numberInJavaScript/11.png","modified":1466344434338,"shasum":"4d846b73a61ab526358e65b60e6cbd36a6315e81"},{"_id":"public/2016/06/19/numberInJavaScript/123.png","modified":1466344434343,"shasum":"a2bedb9531ae71ecb62babb3353024ca1a235965"},{"_id":"public/2016/06/19/numberInJavaScript/32.png","modified":1466344434346,"shasum":"f3f668acfda2b4d3a13904e306bbbf37250106ae"},{"_id":"public/2016/06/19/numberInJavaScript/456.jpg","modified":1466344434349,"shasum":"a288a59a9909a28c4315a3b1f0c5e78ff7d2c71f"},{"_id":"public/2016/06/19/numberInJavaScript/64.png","modified":1466344434354,"shasum":"3be28f0630aaeca21f91282fe55a9d9e8b73335c"},{"_id":"public/2016/06/19/numberInJavaScript/789.jpg","modified":1466344434359,"shasum":"a288a59a9909a28c4315a3b1f0c5e78ff7d2c71f"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image1.jpg","modified":1466344434362,"shasum":"2b16d4501fb5d96aa74bce522bf6619d271da92e"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image10.png","modified":1466344434374,"shasum":"38c20cf85e288d828a624ca4fd788fbb41039a38"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image11.png","modified":1466344434377,"shasum":"5b867713120981fef57c0e51401e3523bb624e13"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image12.png","modified":1466344434380,"shasum":"c37c65adbceeb24bcc04f6aee94ad9c3257f07d3"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image13.png","modified":1466344434384,"shasum":"84ccfcdeac04e66582513c359e214d1a3dc8b6fd"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image14.png","modified":1466344434387,"shasum":"effec54c0893d59927ebac1f013f9bf014d9824f"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image2.jpg","modified":1466344434390,"shasum":"4646bac94ab4efc141bcfc59fdb51d9cf066d53f"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image3.jpg","modified":1466344434401,"shasum":"3477936fdd2cfa5015c19d59c3748d719f0ca7aa"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image4.jpg","modified":1466344434405,"shasum":"4646bac94ab4efc141bcfc59fdb51d9cf066d53f"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image5.png","modified":1466344434413,"shasum":"9395a1e25f7e8c1e5bc05b2a89e594ad05deb220"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image6.png","modified":1466344434422,"shasum":"effec54c0893d59927ebac1f013f9bf014d9824f"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image7.png","modified":1466344434432,"shasum":"52f3f014bf0872c3d005b8fcf4773d0874bf716c"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image8.png","modified":1466344434439,"shasum":"b93b45193c3ab0bf72788a61bb6c25ecd7cab2b0"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/image9.png","modified":1466344434445,"shasum":"9cccf45e61ce8b329c14f97ae3579ddf5a282544"},{"_id":"public/2016/01/08/DOMContentLoaded/onLoadVSDomContentLoaded.png","modified":1466344434452,"shasum":"597586264b44d04e58387eb02379818a338627b1"},{"_id":"public/2016/01/08/DOMContentLoaded/zongjie.png","modified":1466344434463,"shasum":"75b021d03703a62dffca85d21065daa074d2edc4"},{"_id":"public/2016/01/05/2-在HTML中使用JavaScrpt/deferAsync.png","modified":1466344434469,"shasum":"405aba297cb925c030bc11878e291edc350b3645"},{"_id":"public/404.html","modified":1466344434551,"shasum":"8e315c917455c88906c4e1e835e16dbdee6d75f7"},{"_id":"public/baidu_verify_i0wnrfk2ui.html","modified":1466344434558,"shasum":"b3f41baff9e890ecfccc0a8d360fd0919a39b450"},{"_id":"public/2016/06/19/numberInJavaScript/index.html","modified":1466344434617,"shasum":"62e424b846721194fb17f6efdb3b5603d8cbcab1"},{"_id":"public/2016/02/25/运算符/index.html","modified":1466344434751,"shasum":"43a53e7bb338708ae02f26075275302a326c46f6"},{"_id":"public/2016/02/22/js中函数参数都是按值传递的/index.html","modified":1466344434772,"shasum":"bb4984a47a70144726cc3b0b85aac47f008dfcb0"},{"_id":"public/2016/02/19/类型检验/index.html","modified":1466344434820,"shasum":"cde47e8c1507dcb3157a2c2bdf926e374b1bafe2"},{"_id":"public/2016/02/18/类型转换/index.html","modified":1466344434849,"shasum":"723b11198f11c183559141520640084bae79b944"},{"_id":"public/2016/02/03/好好学学Object/index.html","modified":1466344434897,"shasum":"64db5bc172b4d6623978e0ba60d347ea67897ec6"},{"_id":"public/2016/02/02/好好学学String/index.html","modified":1466344434927,"shasum":"e33e66dce6703c06752e3224a2b08f4f2c044f65"},{"_id":"public/2016/01/29/void-0/index.html","modified":1466344434945,"shasum":"549a3fa0097bfc624befdf7bdbabc0f6d993c094"},{"_id":"public/2016/01/29/好好学学number/index.html","modified":1466344435007,"shasum":"058e581f9f691cd4e5507841356db7da39e4fa05"},{"_id":"public/2016/01/29/好好学学undefined！/index.html","modified":1466344435023,"shasum":"dcbcda4718b3f8fe61050d7fcadf761673e07378"},{"_id":"public/2016/01/27/如何学习javascript-转帖/index.html","modified":1466344435035,"shasum":"36f3ec04c6b2496a114e9c9f3f5686f1cf7510d1"},{"_id":"public/2016/01/21/ECMAScrip中的对象存取器-getter和setter/index.html","modified":1466344435058,"shasum":"fbbdb6fe076223e9b739096731c0a3f4912b2333"},{"_id":"public/2016/01/21/严格模式/index.html","modified":1466344435084,"shasum":"79e8d7ef72de2967ed346802fa0840680c1a43fd"},{"_id":"public/2016/01/20/3-第三章基本概念/index.html","modified":1466344435108,"shasum":"3472867320c8f8611262825e30c96affe9d65f56"},{"_id":"public/2016/01/19/webkit的预加载扫描器/index.html","modified":1466344435122,"shasum":"1d6c74c7bc1be2e573f68a676c186ab5df4d25c8"},{"_id":"public/2016/01/08/DOMContentLoaded/index.html","modified":1466344435152,"shasum":"704560c8aa07209955b1456769bc6e625516536e"},{"_id":"public/2016/01/05/2-在HTML中使用JavaScrpt/index.html","modified":1466344435170,"shasum":"a4324cdd7350571b66868d4eb0019517dbf17c16"},{"_id":"public/2016/01/05/1-JavaScrpt简介/index.html","modified":1466344435185,"shasum":"bff5da633a52f0f8a500baf3cd727d0f6c808bcb"},{"_id":"public/archives/index.html","modified":1466344435200,"shasum":"7054d0433b7b705dd86370c0769445d9c35fce88"},{"_id":"public/archives/page/2/index.html","modified":1466344435210,"shasum":"ed06fcb18307cc5250a00bd95bafe53cd2953d0d"},{"_id":"public/archives/2016/index.html","modified":1466344435219,"shasum":"9ce68b353e25154c133b42eb2c07ae8adaf6acc6"},{"_id":"public/archives/2016/page/2/index.html","modified":1466344435234,"shasum":"686ba83900336d62a85bc4f69753b3e46bbf9ae4"},{"_id":"public/archives/2016/01/index.html","modified":1466344435257,"shasum":"a84f0b5da96eed7590ed91df7cf1c4a27f1fd924"},{"_id":"public/archives/2016/01/page/2/index.html","modified":1466344435267,"shasum":"d1912139416e48bbc850ad95c42698c940dd1673"},{"_id":"public/archives/2016/02/index.html","modified":1466344435280,"shasum":"79d31140d290c2c7ece7a367cb5db69373419499"},{"_id":"public/archives/2016/06/index.html","modified":1466344435294,"shasum":"f3f2b51ca9fa4ea7b2de625594e89eb99150e789"},{"_id":"public/categories/《JS高程3-笔记》/index.html","modified":1466344435310,"shasum":"3f63e883e5c3e3c530b03c13ceeda8794a2ae0fa"},{"_id":"public/categories/JavaScript/index.html","modified":1466344435322,"shasum":"e9b318520f4427dbe5fcc19f37ea5f5eec31f06e"},{"_id":"public/index.html","modified":1466344435354,"shasum":"954aa31648982170ecdedf3db0acab4f90a11f1e"},{"_id":"public/page/2/index.html","modified":1466344435386,"shasum":"0545f1154c8e541daa026a34c32d68885d85607f"},{"_id":"public/tags/JavaScript/index.html","modified":1466344435405,"shasum":"f76067977a60f7d6e6014401ac0cfb671712fc8b"},{"_id":"public/tags/JavaScript/page/2/index.html","modified":1466344435429,"shasum":"4f089a5e504f8b2eccae8d31d842f31479d722c4"},{"_id":"public/tags/jQuery/index.html","modified":1466344435441,"shasum":"5912a2f39dab4b282c8144ccab206138c81fea9d"}],"Category":[{"name":"《JS高程3-笔记》","_id":"cipmnl7pz0003543v66n7towi"},{"name":"JavaScript","_id":"cipmnl7qh000e543vnkbu9caa"}],"Data":[],"Page":[{"layout":"default","_content":"<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"www.yangshengdonghome.com\" homePageName=\"前端之路\"></script>","source":"404.html","raw":"---\nlayout: default\n---\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"www.yangshengdonghome.com\" homePageName=\"前端之路\"></script>","date":"2016-01-11T01:58:24.000Z","updated":"2016-01-11T02:26:30.000Z","path":"404.html","title":"","comments":1,"_id":"cipmnl7p70000543vte6a1e0t"},{"_content":"i0wnrfk2ui","source":"baidu_verify_i0wnrfk2ui.html","raw":"i0wnrfk2ui","date":"2016-01-12T04:22:37.000Z","updated":"2016-01-12T04:21:56.000Z","path":"baidu_verify_i0wnrfk2ui.html","title":"","comments":1,"layout":"page","_id":"cipmnl7pr0001543vjbkzig4j"}],"Post":[{"title":"运算符","date":"2016-02-25T06:19:16.000Z","comments":1,"_content":"运算符是处理数据的基本方法，用来从现有数据得到新的数据。JavaScript与其他编程语言一样，提供了多种运算符。\n<!--more-->\n## 算术运算符\n\nJavaScript提供9个算术运算符。\n\n- **加法运算符**（Addition）：`x + y`\n- **减法运算符**（Subtraction）： `x - y`\n- **乘法运算符**（Multiplication）： `x * y`\n- **除法运算符**（Division）：`x / y`\n- **余数运算符**（Remainder）：`x % y`\n- **自增运算符**（Increment）：`++x` 或者 `x++`\n- **自减运算符**（Decrement）：`--x` 或者 `x--`\n- **数值运算符**（Convert to number）： `+x`\n- **负数值运算符**（Negate）：`-x`\n\n减法、乘法、除法运算法比较单纯，就是执行相应的数学运算。下面介绍其他几个算术运算符。\n\n### 加法运算符\n\n加法运算符（`+`）需要注意的地方是，它除了用于数值的相加，还能用于字符串的连接。\n\n```javascript\n1 + 1 // 2\n'1' + '1' // \"11\"\n'1.1' + '1.1' // \"1.11.1\"\n```\n\n上面代码中，如果两个运算子都是数值，加号运算符就执行数值的加法运算；如果两个运算子都是字符串，加号运算符就执行字符串的连接运算，变成字符串连接运算符。这种由于参数不同，而改变自身行为的现象，叫做“重载”（overload）。\n\n如果两个运算子之中，一个是字符串，另一个是数值，加法运算符执行字符串连接运算。\n\n```javascript\n1 + '1' // \"11\"\n```\n\n上面代码表示，两个运算子之中有一个是字符串，另一个运算子就会被自动转为字符串。\n\n```javascript\n'3' + 4 + 5 // \"345\"\n3 + 4 + '5' // \"75\"\n```\n\n上面代码中，由于加法运算符遇到字符串，会发生重载，导致运算结果的不同。\n\n由于这个特性，下面的写法有时用于将一个值转为字符串。\n\n```javascript\nx + ''\n```\n\n上面代码表示，一个值加上空字符串，会使得该值转为字符串形式。\n\n布尔值和复合类型的值，也可以使用加法运算符，但是会导致数据类型的自动转换，关于这方面的详细讨论，参见[《数据类型转换》](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n\n**除加法运算符以外的其他算术运算符，都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。**\n\n```javascript\n1 - '1' // 0\n+'3' // 3\n-true // -1\n```\n\n上面代码表示，减法运算符将字符串“1”自动转为数值1，数值运算符（+）将字符串“3”转为数值3，求负运算符（-）将布尔值true转为-1。\n\n由于加法运算符与其他算术运算符的这种差异，会导致一些意想不到的结果，计算时要小心。\n\n```javascript\nvar now = new Date();\ntypeof (now + 1) // \"string\"\ntypeof (now - 1) // \"number\"\n```\n\n上面代码中，`now`是一个Date对象的实例。加法运算时，`now`转为字符串，加一个数字，得到还是字符串；减法运算时，now转为数值，减一个数字，得到的是数字。\n<span style=\"color:red;\">Date对象比较特殊在和一个任意类型的数据相加的时候，会优先调用toString()方法，其他对象都是优先valueOf()</span>\n\n### 余数运算符\n\n余数运算符（`%`）返回前一个运算子被后一个运算子除，所得的余数。\n\n```javascript\n12 % 5 // 2\n```\n\n需要注意的是，运算结果的正负号由第一个运算子的正负号决定。\n\n```javascript\n-1 % 2 // -1\n1 % -2 // 1\n```\n\n为了得到正确的负数的余数值，需要先使用绝对值函数。\n\n```javascript\n// 错误的写法\nfunction isOdd(n) {\n  return n % 2 === 1;\n}\nisOdd(-5) // false\nisOdd(-4) // false\n\n// 正确的写法\nfunction isOdd(n) {\n  return Math.abs(n % 2) === 1;\n}\nisOdd(-5) // true\nisOdd(-4) // false\n```\n\n余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。\n\n```javascript\n6.5 % 2.1\n// 0.19999999999999973\n```\n\n### 自增和自减运算符\n\n自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。\n\n```javascript\nvar x = 1;\n++x // 2\nx // 2\n\n--x // 1\nx // 1\n```\n\n上面代码的变量x自增后，返回2，再进行自减，返回1。这两种情况都会使得，原始变量`x`的值发生改变。\n\n自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。\n\n```javascript\nvar x = 1;\nvar y = 1;\n\nx++ // 1\n++y // 2\n```\n\n上面代码中，`x`是先返回当前值，然后自增，所以得到1；`y`是先自增，然后返回新的值，所以得到2。\n\n### 数值运算符，负数值运算符\n\n数值运算符（`+`）同样使用加号，但是加法运算符是二元运算符（需要两个操作数），它是一元运算符（只需要一个操作数）。\n\n数值运算符的作用在于可以将任何值转为数值（与`Number`函数的作用相同）。\n\n```javascript\n+true // 1\n+[] // 0\n+{} // NaN\n```\n\n上面代码表示，非数值类型的值经过数值运算符以后，都变成了数值（最后一行`NaN`也是数值）。具体的类型转换规则，参见[《数据类型转换》](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n\n求负运算符（`-`），也同样具有将一个值转为数值的功能，所以下面的写法等同于数值运算符。\n\n```javascript\nvar x = 1;\n-x // -1\n-(-x) // 1\n\nvar y = \"111\";\n-y // -111\n```\n\n上面代码最后一行的圆括号不可少，否则会变成递减运算符。从中可以看出，数值运算符和负数值运算符，不会改变原始变量的值。\n\n## 赋值运算符\n\n赋值运算符（Assignment Operators）用于给变量赋值。\n\n### 何为\"左值\"?\n形如`A=B`的表达式称为赋值表达式。其中A和B又分别可以是表达式。B可以是任意表达式，但是A必须是一个左值。所谓左值，就是可以被赋值的表达式，在ES规范中是用内部类型引用(Reference)描述的。例如：\n  * 表达式`foo.bar`可以作为一个左值，表示对`foo`这个对象中`bar`这个名称的引用；\n  * 变量`email`可以作为一个左值，表示对当前执行环境中的环境记录项`envRec`中`email`这个名称的引用；\n  * 同样地，函数名`func`可以做左值，然而函数调用表达式`func(a, b)`不可以。\n\n那么JS引擎是怎样计算一般的赋值表达式 A = B的呢？简单地说，按如下步骤：\n  1. 计算表达式A，得到一个引用refA；\n  2. 计算表达式B，得到一个值valueB；\n  3. 将valueB赋给refA指向的名称绑定；\n  4. 返回valueB。\n\n### 结合性\n赋值表达式是右结合的。这意味着：\n\n    A1 = A2 = A3 = A4\n等价于\n\n    A1 = (A2 = (A3 = A4))\n### 连等的解析\n好了，有了上面两部分的知识。下面来看一下JS引擎是怎样运算连等赋值表达式的。\n\n    Exp1 = Exp2 = Exp3 = Exp4\n首先根据右结合性，可以转换成\n\n    Exp1 = (Exp2 = (Exp3 = Exp4))\n\n然后，我们已经知道对于单个赋值运算，JS引擎总是先计算左边的操作数，再计算右边的操作数。所以接下来的步骤就是：\n\n  1. 计算Exp1，得到Ref1\n  2. 计算Exp2，得到Ref2\n  3. 计算Exp3，得到Ref3\n  4. 计算Exp4，得到Value4。\n\n现在变成了这样的：\n\n    Ref1 = (Ref2 = (Ref3 = Value4))\n\n接下来的步骤是：\n\n 1. 将Value4赋给Exp3；\n 2. 将Value4赋给Exp2；\n 3. 将Value4赋给Exp1；\n 4. 返回表达式最终的结果Value4。\n\n总结一下就是：\n> 先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。\n\n最常见的赋值运算符，当然就是等号（`=`），表达式`x = y`表示将`y`的值赋给`x`。除此之外，JavaScript还提供其他11个赋值运算符。\n\n```javascript\nx += y // 等同于 x = x + y\nx -= y // 等同于 x = x - y\nx *= y // 等同于 x = x * y\nx /= y // 等同于 x = x / y\nx %= y // 等同于 x = x % y\nx >>= y // 等同于 x = x >> y\nx <<= y // 等同于 x = x << y\nx >>>= y // 等同于 x = x >>> y\nx &= y // 等同于 x = x & y\nx |= y // 等同于 x = x | y\nx ^= y // 等同于 x = x ^ y\n```\n\n上面11个赋值运算符，都是先进行某种运算，然后将得到值返回给左边的变量。\n\n### 小问题\n\n```javascript\nvar a = {n: 1};\nvar b = a;\na.x = a = {n: 2};\nalert(a.x); // --> undefined\nalert(b.x); // --> {n: 2}\n```\n首先前两个var语句执行完后，a和b都指向同一个对象`{n: 1}`(为方便描述，下面称为对象`N1`)。然后来看\n\n    a.x = a = {n: 2};\n根据前面的知识，首先依次计算表达式`a.x`和`a`，得到两个引用。其中`a.x`表示对象`N1`中的`x`，而`a`相当于`envRec.a`，即当前环境记录项中的`a`。所以此时可以写出如下的形式：\n\n    [[N1]].x = [[encRec]].a = {n: 2};//其中，[[]]表示引用指向的对象。\n接下来，将`{n: 2}`赋值给`[[encRec]].a`，即将`{n: 2}`绑定到当前上下文中的名称`a`。\n接下来，将同一个`{n: 2}`赋值给`[[N1]].x`，即将`{n: 2}`绑定到`N1`中的名称`x`。\n由于`b`仍然指向`N1`，所以此时有\n\n    b <=> N1 <=> {n: 1, x: {n: 2}}\n而a被重新赋值了，所以\n\n    a <=> {n: 2}\n并且\n\n    a === b.x\n\n如果你明白了上面所有的内容，应该会明白`a.x = a = {n:2};`与`b.x = a = {n:2};`是完全等价的。因为在解析`a.x`或`b.x`的那个时间点。`a`和`b`这两个名称指向同一个对象，就像C++中同一个对象可以有多个引用一样。而在这个时间点之后，不论是`a.x`还是`b.x`，其实早就不存在了，它已经变成了那个`内存中的对象.x`了。\n\n## 比较运算符\n\n比较运算符比较两个值，然后返回一个布尔值，表示是否满足比较条件。JavaScript提供了8个比较运算符。\n\n- `==` 相等\n- `===` 严格相等\n- `!=` 不相等\n- `!==` 严格不相等\n- `<` 小于\n- `<=` 小于或等于\n- `\\>` 大于\n- `\\>=` 大于或等于\n\n其中，比较两个值是否相等的运算符有两个：一个是相等运算符（`==`），另一个是严格相等运算符（`===`）。\n\n相等运算符（`==`）比较两个值是否相等，严格相等运算符（`===`）比较它们是否为“同一个值”。两者的一个重要区别是，如果两个值不是同一类型，严格相等运算符（`===`）直接返回false，而相等运算符（`==`）会将它们转化成同一个类型，再用严格相等运算符进行比较。\n\n### 严格相等运算符\n\n严格相等运算符的运算规则如下。\n\n**（1）不同类型的值**\n\n如果两个值的类型不同，直接返回`false`。\n\n```javascript\n1 === \"1\" // false\ntrue === \"true\" // false\n```\n\n上面代码比较数值的`1`与字符串的“1”、布尔值的`true`与字符串“true”，因为类型不同，结果都是`false`。\n\n**（2）同一类的原始类型值**\n\n同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。\n\n```javascript\n1 === 0x1 // true\n```\n\n上面代码比较十进制的1与十六进制的1，因为类型和值都相同，返回`true`。\n\n需要注意的是，`NaN`与任何值都不相等（包括自身）。另外，正0等于负0。\n\n```javascript\nNaN === NaN  // false\n+0 === -0 // true\n```\n\n**（3）同一类的复合类型值**\n\n两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。\n\n```javascript\n({}) === {} // false\n[] === [] // false\n(function (){}) === function (){} // false\n```\n\n上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是它们的内存地址是否一样，而上面代码中空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是`false`。另外，之所以要把第一个空对象放在括号内，是为了避免JavaScript引擎把这一行解释成代码块，从而报错；把第一个空函数放在括号内，是为了避免这一行被解释成函数的定义。\n\n如果两个变量指向同一个复合类型的数据，则它们相等。\n\n```javascript\nvar v1 = {};\nvar v2 = v1;\nv1 === v2 // true\n```\n\n**（4）undefined和null**\n\n`undefined`和`null`与自身严格相等。\n\n```javascript\nundefined === undefined // true\nnull === null // true\n```\n\n由于变量声明后默认值是`undefined`，因此两个只声明未赋值的变量是相等的。\n\n```javascript\nvar v1;\nvar v2;\nv1 === v2 // true\n```\n\n**（5）严格不相等运算符**\n\n严格相等运算符有一个对应的“严格不相等运算符”（`!==`），两者的运算结果正好相反。\n\n```javascript\n1 !== '1' // true\n```\n\n### 相等运算符\n\n相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。\n\n在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下：\n\n**（1）原始类型的值**\n\n原始类型的数据会转换成数值类型再进行比较。\n\n```javascript\n1 == true // true\n0 == false // true\n\n\"true\" == true // false\n\n'' == 0 // true\n\n'' == false  // true\n'1' == true  // true\n\n'2' == true // false\n2 == true // false\n2 == false // false\n\n'\\n  123  \\t' == 123 // true\n// 因为字符串转为数字时，省略前置和后置的空格\n```\n\n上面代码将字符串和布尔值都转为数值，然后再进行比较。字符串与布尔值的类型转换规则，参见[类型转换](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n\n**（2）对象与原始类型值比较**\n\n对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。\n\n```javascript\n[1] == 1 // true\n[1] == '1' // true\n[1] == true // true\n```\n\n上面代码将只含有数值1的数组与原始类型的值进行比较，数组`[1]`会被自动转换成数值`1`，因此结果都是`true`。数组的类型转换规则，参见[类型转换](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n\n**（3）undefined和null**\n\nundefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。\n\n```javascript\n\nfalse == null // false\n0 == null // false\n\nundefined == null // true\n\n```\n\n**（4）相等运算符的缺点**\n\n相等运算符隐藏的类型转换，会带来一些违反直觉的结果。\n\n```javascript\n\n'' == '0'           // false\n0 == ''             // true\n0 == '0'            // true\n\nfalse == 'false'    // false\nfalse == '0'        // true\n\nfalse == undefined  // false\nfalse == null       // false\nnull == undefined   // true\n\n' \\t\\r\\n ' == 0     // true\n\n```\n\n上面这些表达式都很容易出错，因此不要使用相等运算符（==），最好只使用严格相等运算符（===）。\n\n**（5）不相等运算符**\n\n相等运算符有一个对应的“不相等运算符”（!=），两者的运算结果正好相反。\n\n```javascript\n\n1 != \"1\" // false\n\n```\n**（6）详细比较过程**\n摘录[ES5标准](https://www.w3.org/html/ig/zh/wiki/ES5/expressions#.E7.AD.89.E4.BA.8E.E8.BF.90.E7.AE.97.E7.AC.A6.EF.BC.88.3D.3D.EF.BC.89)：以 x 和 y 为值进行 x == y 比较会产生的结果可为 true 或 false。比较的执行步骤如下：\n1. 若 Type(x) 与 Type(y) 相同， 则\n 1. 若 Type(x) 为 Undefined， 返回 true。\n 2. 若 Type(x)为 Null， 返回 true。\n 3. 若 Type(x)为 Number，则\n 4. 若 x 为 NaN，返回 false。\n 5. 若 y 为 NaN，返回 false。\n 6. 若 x 与 y 为相等数值，返回 true。\n 7. 若 x 为 +0 且 y 为 −0，返回 true。\n 8. 若 x 为 −0 且 y 为 +0，返回 true。\n 9. 返回 false。\n2. 若 Type(x) 为 String，则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true。否则，返回 false。\n3. 若 Type(x) 为 Boolean，当 x 和 y 为同为 true 或者同为 false 时返回 true。否则，返回 false。\n4. 当 x 和 y 为引用同一对象时返回 true。否则，返回 false。\n5. 若 x 为 null 且 y 为 undefined，返回 true。\n6. 若 x 为 undefined 且 y 为 null，返回 true。\n7. 若 Type(x) 为 Number 且 Type(y) 为 String，返回 x == ToNumber(y) 的结果。\n8. 若 Type(x) 为 String 且 Type(y) 为 Number，返回比较 ToNumber(x) == y 的结果。\n9. 若 Type(x) 为 Boolean，返回比较 ToNumber(x) == y 的结果。\n10. 若 Type(y) 为 Boolean，返回比较 x == ToNumber(y) 的结果。\n11. 若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果。\n12. 若 Type(x) 为 Object 且 Type(y) 为 String 或 Number，返回比较 ToPrimitive(x) == y 的结果。\n13. 返回 false。\n注：等于运算符不总是可传递。举例来说，两个代表相同 String 值但是不同的 String 对象会分别与 String 值 ==，但是两个对象间不相等。比如下例:\n\n```javascript\nvar a = 2; var b = 2;\nvar a1 = new Number(2); var b1 = new Number(2);\nconsole.log(a == a1) //true\nconsole.log(b == b1) //true\nconsole.log(a == b)  //true\nconsole.log(a1 == b1) //false\nvar a = \"123\"; var b = \"123\";\nvar a1 = new String(\"123\"); var b1 = new String(\"123\");\nconsole.log(a == a1) //true\nconsole.log(b == b1) //true\nconsole.log(a == b) //true\nconsole.log(a1 == b1) //false\n```\n注：<span style=\"color: red;\">不能将null 和undefined 转换成其他任何值，**可以见得： `null`、`undefined`只和`null`、`undefined`相等，和`false`和0比都是`false`。**</span>\n```javascript\nundefined == 0; //false\nnull == 0; //false\nfalse == null; //false\nfalse == undefined; //flase\n```\n### 小问题\n```javascript\nvar a;         // undefined\n!a             // true\na == false     // false\n\na = null;\n!a             // true\na == false     // false\n```\n上面的代码中，为什么!a中a能转换成false， 而a == false 中a就不能转换成false呢？\n\n## 布尔运算符\n\n布尔运算符用于将表达式转为布尔值。\n\n### 取反运算符（!）\n\n取反运算符形式上是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true。\n\n```javascript\n\n!true // false\n!false // true\n\n```\n\n对于非布尔值的数据，取反运算符会自动将其转为布尔值。规则是，以下六个值取反后为`true`，其他值取反后都为`false`。\n\n- undefined\n- null\n- false\n- 0（包括+0和-0）\n- NaN\n- 空字符串（\"\"）\n\n这意味着，取反运算符有转换数据类型的作用。\n\n```javascript\n!undefined // true\n!null // true\n!0 // true\n!NaN // true\n!\"\" // true\n\n!54 // false\n!'hello' // false\n![] // false\n!{} // false\n```\n\n上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。\n\n如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，<span style=\"color:red;\">与Boolean函数的作用相同</span>。这是一种常用的类型转换的写法。\n\n```javascript\n\n!!x\n\n// 等同于\n\nBoolean(x)\n\n```\n\n上面代码中，不管x是什么类型的值，经过两次取反运算后，变成了与Boolean函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。\n\n取反运算符的这种将任意数据自动转为布尔值的功能，对下面三种布尔运算符（且运算符、或运算符、三元条件运算符）都成立。\n\n### 且运算符（&&）\n\n且运算符的运算规则是：如果第一个运算子的布尔值为`true`，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为`false`，则直接返回第一个运算子的值，且不再对第二个运算子求值。\n\n```javascript\n\n\"t\" && \"\" // \"\"\n\"t\" && \"f\" // \"f\"\n\"t\" && (1+2) // 3\n\"\" && \"f\" // \"\"\n\"\" && \"\" // \"\"\n\nvar x = 1;\n(1-1) && (x+=1) // 0\nx // 1\n\n```\n\n上面代码的最后一部分表示，由于且运算符的第一个运算子的布尔值为`false`，则直接返回它的值`0`，而不再对第二个运算子求值，所以变量`x`的值没变。\n\n这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段`if`结构的代码，就可以用且运算符改写。\n\n```javascript\n\nif (i !== 0 ){\n\tdoSomething();\n}\n\n// 等价于\n\ni && doSomething();\n\n```\n\n上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。\n\n且运算符可以多个连用，这时返回第一个布尔值为`false`的表达式的值。\n\n```javascript\n\ntrue && 'foo' && '' && 4 && 'foo' && true // ''\n\n```\n\n上面代码中第一个布尔值为false的表达式为第三个表达式，所以得到一个空字符串。\n\n### 或运算符（||）\n\n或运算符的运算规则是：如果第一个运算子的布尔值为`true`，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为`false`，则返回第二个运算子的值。\n\n```javascript\n\n\"t\" || \"\" // \"t\"\n\"t\" || \"f\" // \"t\"\n\"\" || \"f\" // \"f\"\n\"\" || \"\" // \"\"\n\n```\n\n短路规则对这个运算符也适用。\n\n或运算符可以多个连用，这时返回第一个布尔值为`true`的表达式的值。\n\n```javascript\n\nfalse || 0 || '' || 4 || 'foo' || true // 4\n\n```\n\n上面代码中第一个布尔值为`true`的表达式是第四个表达式，所以得到数值4。\n\n或运算符常用于为一个变量设置默认值。\n\n```javascript\n\nfunction saveText(text) {\n    text = text || '';     // ...\n}\n\n// 或者写成\n\nsaveText(this.text || '')\n\n```\n\n上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。\n\n### 三元条件运算符（ ? :）\n\n三元条件运算符用问号（？）和冒号（：），分隔三个表达式。如果第一个表达式的布尔值为`true`，则返回第二个表达式的值，否则返回第三个表达式的值。\n\n```javascript\n\n\"t\" ? true : false // true\n\n0 ? true : false // false\n\n```\n\n上面代码的“t”和0的布尔值分别为`true`和`false`，所以分别返回第二个和第三个表达式的值。\n\n通常来说，三元条件表达式与`if...else`语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，`if...else`是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用`if..else`。\n\n```javascript\n\nvar check = true ? console.log('T') : console.log('F');\n\nconsole.log(true ? 'T' : 'F');\n\n```\n\n上面代码是赋值语句和`console.log`方法的例子，它们都需要使用表达式，这时三元条件表达式就能满足需要。如果要用`if...else`语句，就必须改变整个代码写法了。\n\n## 位运算符\n\n### 简介\nECMAScript 中的所有数值都以IEEE-754 64 位格式存储，但位操作符并不直接操作64 位的值。而是先将64 位的值转换成32 位的整数，然后执行操作，最后再将结果转换回64 位，位运算符用于直接对二进制位进行计算，一共有7个。\n如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值（自动完成），然后再应用位操作。\n\n- **或运算**（or）：符号为|，表示两个二进制位中有一个为1，则结果为1，否则为0。\n\n- **与运算**（and）：符号为&，表示两个二进制位都为1，则结果为1，否则为0。\n\n- **否运算**（not）：符号为～，表示将一个二进制位变成相反值。\n\n- **异或运算**（xor）：符号为&#710;，表示两个二进制位中有且仅有一个为1时，结果为1，否则为0。\n\n- **左移运算**（left shift）：符号为<<，详见下文解释。\n\n- **右移运算**（right shift）：符号为>>，详见下文解释。\n\n- **带符号位的右移运算**（zero filled right shift）：符号为>>>，详见下文解释。\n\n这些位运算符直接处理每一个比特位，所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会带来过度的复杂性。\n\n有一点需要特别注意，位运算符只对整数起作用，**如果一个运算子不是整数，会自动将小数部分舍去后再运行。另外，虽然在JavaScript内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。**\n\n在ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程：64 位的数值被转换成32位数值，然后执行位操作，最后再将32 位的结果转换回64 位数值。这样，表面上看起来就好像是在操作32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效应，**即在对特殊的NaN 和Infinity 值应用位操作时，这两个值都会被当成0 来处理**。\n\n```javascript\ni = i|0;\n```\n\n上面这行代码的意思，就是将`i`转为32位整数。\n\n### “或运算”与“与运算”\n\n这两种运算比较容易理解，就是逐位比较两个运算子。\n“或运算”的规则是，如果两个二进制位之中至少有一个位为1，则返回1，否则返回0。\n“与运算”的规则是，如果两个二进制位之中至少有一个位为0，则返回0，否则返回1。\n\n```javascript\n0 | 3 // 3\n0 & 3 // 0\n```\n\n上面两个表达式，0和3的二进制形式分别是00和11，所以进行“或运算”会得到11（即3），进行”与运算“会得到00（即0）。\n\n**位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。**所以，将一个小数与0进行或运算，等同于对该数去除小数部分，即取整数位。\n\n```javascript\n2.9 | 0\n// 2\n\n-2.9 | 0\n// -2\n\n```\n\n需要注意的是，这种取整方法不适用超过32位整数最大值2147483647的数。\n\n```javascript\n2147483649.4 | 0;\n// -2147483647\n\n```\n\n### 否运算\n\n“否运算”将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。\n\n```javascript\n~ 3 // -4\n```\n\n上面表达式对`3`进行`“否运算”`，得到`-4`。之所以会有这样的结果，是因为位运算时，JavaScirpt内部将所有的运算子都转为32位的二进制整数再进行运算。`3`在JavaScript内部是`00000000000000000000000000000011`，否运算以后得到`11111111111111111111111111111100`，由于第一位是`1`，所以这个数是一个负数。JavaScript内部采用`2`的补码形式表示负数，即需要将这个数减去`1`，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去`1`等于`11111111111111111111111111111011`，再取一次反得到`00000000000000000000000000000100`，再加上负号就是`-4`。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于`-1`。\n\n```javascript\n~ -3 // 2\n```\n\n上面表达式可以这样算，`-3`的取反值等于`-1`减去`-3`，结果为`2`。\n\n对一个整数连续两次“否运算”，得到它自身。\n\n```javascript\n~~3 // 3\n```\n\n<span style=\"color:red;\">所有的位运算都只对整数有效</span>。否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，**对一个小数连续进行两次否运算，能达到取整效果。**\n\n```javascript\n~~2.9 // 2\n~~47.11 // 47\n~~1.9999 // 1\n~~3 // 3\n~~-2.9 // -2\n```\n\n使用否运算取整，是所有取整方法中最快的一种。\n\n对字符串进行否运算，JavaScript引擎会先调用Number函数，将字符串转为数值。\n\n```javascript\n// 以下例子相当于~Number('011')\n~'011'  // -12\n~'42 cats' // -1\n~'0xcafebabe' // 889275713\n~'deadbeef' // -1\n\n// 以下例子相当于~~Number('011')\n~~'011';        // 11\n~~'42 cats';    // 0\n~~'0xcafebabe'; // -889275714\n~~'deadbeef';   // 0\n```\n\nNumber函数将字符串转为数值的规则，参见[类型转换](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n<span style=\"color:red;\">否运算对特殊数值的处理是：超出32位的整数将会被截去超出的位数，NaN和Infinity转为0。</span>\n\n对于其他类型的参数，否运算也是先用`Number`转为数值，然后再进行处理。\n\n```javascript\n~~[] // 0\n~~NaN // 0\n~~null // 0\n```\n\n### 异或运算\n\n“异或运算”在两个二进制位不同时返回1，相同时返回0。\n\n```javascript\n0^3 // 3\n```\n\n上面表达式中，0的二进制形式是`00`，`3`的二进制形式是`11`，它们每一个二进制位都不同，所以得到`11（即3）`。\n\n“异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，`a^=b`, `b^=a`, `a^=b`，可以互换它们的值（详见[维基百科](http://en.wikipedia.org/wiki/XOR_swap_algorithm)）。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。\n\n```javascript\nvar a = 10;\nvar b = 99;\n\na^=b, b^=a, a^=b;\n\na // 99\nb // 10\n\n```\n\n这是互换两个变量的值的最快方法。\n\n异或运算也可以用来取整。\n\n```javascript\n12.9^0 // 12\n\n```\n\n### 左移运算符（<<）\n\n左移运算符表示将一个数的二进制形式向前移动，尾部补0。\n\n```javascript\n4 << 1\n// 8\n// 因为4的二进制形式为100，左移一位为1000（即十进制的8）\n\n-4 << 1\n// -8\n\n```\n\n上面代码中，`-4`左移一位之所以得到`-8`，是因为-4的二进制形式是`11111111111111111111111111111100`，左移一位后得到`11111111111111111111111111111000`，该数转为十进制（减去`1`后取反，再加上负号）即为`-8`。\n\n如果左移`0`位，就相当于取整，对于正数和负数都有效。\n\n```javascript\n13.5 << 0\n// 13\n\n-13.5 << 0\n// -13\n\n```\n\n左移运算符用于二进制数值非常方便。\n\n```javascript\n\nvar color = {r: 186, g: 218, b: 85};\n\n// RGB to HEX\nvar rgb2hex = function(r, g, b) {\n    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).substr(1);\n}\n\nrgb2hex(color.r,color.g,color.b)\n// \"#bada55\"\n\n```\n\n上面代码使用左移运算符，将颜色的RGB值转为HEX值。\n\n### 右移运算符（>>）\n\n右移运算符表示将一个数的二进制形式向右移动，头部补上最左位的值，即正数补0，负数补1。\n\n```javascript\n4 >> 1\n// 2\n/*\n// 因为4的二进制形式为00000000000000000000000000000100，\n// 右移一位得到00000000000000000000000000000010，\n// 即为十进制的2\n*/\n\n-4 >> 1\n// -2\n/*\n// 因为-4的二进制形式为11111111111111111111111111111100，\n// 右移一位，头部补1，得到11111111111111111111111111111110,\n// 即为十进制的-2\n*/\n```\n\n右移运算可以模拟2的整除运算。\n\n```javascript\n5 >> 1\n// 相当于 5 / 2 = 2\n\n21 >> 2\n// 相当于 21 / 4 = 5\n\n21 >> 3\n// 相当于 21 / 8 = 2\n\n21 >> 4\n// 相当于 21 / 16 = 1\n```\n\n### 小数取整的方法\n* 通过`Math`中自带的方法\n  * `Math.floor()`、`Math.round()`、`Math.ceil()`、`parseInt()`(这个会舍弃小数点`.`)\n* 位运算 所有位运算会把`NaN`、`Infinity`、`null`、`undefined` 当作0来处理\n  * `-4.1 << 0 // 4` 左移`0`位\n  * `12.9^0 // 12`\n  * `~~2.9 // 2`\n  * `-2.9 | 0 // 2`\n\n### 带符号位的右移运算符（>>>）\n\n该运算符表示将一个数的二进制形式向右移动，不管正数或负数，头部一律补`0`。所以，该运算总是得到正值，这就是它的名称`“带符号位的右移”`的涵义。对于正数，该运算的结果与右移运算符（>>）完全一致，区别主要在于负数。\n\n```javascript\n4 >>> 1\n// 2\n\n-4 >>> 1\n// 2147483646\n/*\n// 因为-4的二进制形式为11111111111111111111111111111100，\n// 带符号位的右移一位，得到01111111111111111111111111111110，\n// 即为十进制的2147483646。\n*/\n```\n\n### 开关作用\n\n位运算符可以用作设置对象属性的开关。\n假定某个对象有四个开关，每个开关都是一个变量，取值为2的整数次幂。\n```javascript\nvar FLAG_A = 1; // 0001\nvar FLAG_B = 2; // 0010\nvar FLAG_C = 4; // 0100\nvar FLAG_D = 8; // 1000\n\n```\n\n上面代码设置A、B、C、D四个开关，每个开关分别占有1个二进制位。\n现在假设需要打开ABD三个开关，我们可以构造一个掩码变量。\n```javascript\nvar mask = FLAG_A | FLAG_B | FLAG_D; // 0001 | 0010 | 1000 => 1011\n\n```\n\n上面代码对ABD三个变量进行“或运算”，得到掩码值为二进制的`1011`。\n有了掩码，就可以用“与运算”检验当前设置是否与开关设置一致。\n\n```javascript\nif (flags & FLAG_C) { // 0101 & 0100 => 0100 => true\n   // ...\n}\n\n```\n\n上面代码表示，如果当前设置与掩码一致，则返回`true`，否则返回`false`。\n`“或运算”`可以将当前设置改成开关设置。\n\n```javascript\nflags |= mask; \n\n```\n\n“与运算”可以将当前设置中凡是与开关设置不一样的项，全部关闭。\n\n```javascript\nflags &= mask; \n\n```\n\n“异或运算”可以切换（toggle）当前设置。\n\n```javascript\nflags = flags ^ mask; \n\n```\n\n“否运算”可以翻转当前设置。\n\n```javascript\nflags = ~flags;\n\n```\n\n## 其他运算符\n\n### 圆括号运算符\n\n在JavaScript中，圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。\n\n把表达式放在圆括号之中，将返回表达式的值。\n\n```javascript\n(1) // 1\n('a') // a\n(1+2) // 3\n\n```\n\n把对象放在圆括号之中，则会返回对象的值，即对象本身。\n\n```javascript\nvar o = {p:1};\n\n(o)\n// Object {p: 1}\n\n```\n\n将函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数，即对函数求值。\n\n```javascript\nfunction f(){return 1;}\n\n(f) // function f(){return 1;}\nf() // 1\n\n```\n\n上面的代码先定义了一个函数，然后依次将函数放在圆括号之中、将圆括号跟在函数后面，得到的结果是不一样的。\n\n由于圆括号的作用是求值，如果将语句放在圆括号之中，就会报错，因为语句没有返回值。\n\n```javascript\n(var a =1)\n// SyntaxError: Unexpected token var\n\n```\n\n### void运算符\n\n`void`运算符的作用是执行一个表达式，然后不返回任何值，或者说返回`undefined`。\n\n```javascript\nvoid 0 // undefined\nvoid(0) // undefined\n```\n\n上面是`void`运算符的两种写法，都正确。建议采用后一种形式，即总是使用括号。因为`void`运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，`void 4 + 7`实际上等同于`(void 4) + 7`。\n\n下面是`void`运算符的一个例子。\n\n```javascript\nvar x = 3;\nvoid (x = 5) //undefined\nx // 5\n```\n\n这个运算符主要是用于书签工具（bookmarklet），以及用于在超级链接中插入代码，目的是返回`undefined`可以防止网页跳转。\n\n```javascript\n<a href=\"javascript:void window.open('http://example.com/')\">\n  点击打开新窗口\n</a>\n```\n\n上面代码用于在网页中创建一个链接，点击后会打开一个新窗口。如果没有`void`，点击后就会在当前窗口打开链接。\n\n下面是常见的网页中触发鼠标点击事件的写法。\n\n```javascript\n<a href=\"http://example.com\" onclick=\"f();\">文字</a>\n```\n\n上面代码有一个问题，函数`f`必须返回`false`，或者说`onclick`事件必须返回`false`，否则会引起浏览器跳转到`example.com`。\n\n```javascript\nfunction f() {\n  // some code\n  return false;\n}\n```\n\n或者写成\n\n```javascript\n<a href=\"http://example.com\" onclick=\"f();return false;\">文字</a>\n```\n\n`void`运算符可以取代上面两种写法。\n\n```javascript\n<a href=\"javascript:void(f())\">文字</a>\n```\n\n下面的代码会提交表单，但是不会产生页面跳转。\n\n```javascript\n<a href=\"javascript:void(document.form.submit())\">\n文字</a>\n```\n\n### 逗号运算符\n\n逗号运算符用于对两个表达式求值，并返回后一个表达式的值。\n\n```javascript\n\n\"a\", \"b\" // \"b\"\n\nvar x = 0;\nvar y = (x++, 10);\nx // 1\ny // 10\n\n```\n\n## 运算顺序\n\n**（1）运算符的优先级**\n\nJavaScript各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。\n\n```javascript\n4 + 5 * 6 // 34\n```\n\n上面的代码中，乘法运算符（`*`）的优先性高于加法运算符（`+`），所以先执行乘法，再执行加法，相当于下面这样。\n\n```javascript\n4 + (5 * 6) // 34\n```\n\n如果多个运算符混写在一起，常常会导致令人困惑的代码。\n\n```javascript\nvar x = 1;\nvar arr = [];\n\nvar y = arr.length <= 0 || arr[0] === undefined ? x : arr[0];\n```\n\n上面代码中，变量`y`的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。\n\n根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（<=)、严格相等（===）、或（||）、三元（?:）、等号（=）。因此上面的表达式，实际的运算顺序如下。\n\n```javascript\nvar y = ((arr.length <= 0) || (arr[0] === undefined)) ? x : arr[0];\n```\n\n记住所有运算符的优先级，几乎是不可能的，也是没有必要的。\n\n**（2）圆括号的作用**\n\n圆括号可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的运算符会第一个运算。\n\n```javascript\n(4 + 5) * 6 // 54\n```\n\n上面代码中，由于使用了圆括号，加法会先于乘法执行。\n\n由于运算符的优先级别十分繁杂，且都是来自硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。\n\n**（3）左结合与右结合**\n\n对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的“左结合”（left-to-right associativity），即从左边开始计算。\n\n```javascript\nx + y + z\n```\n\n上面代码先计算最左边的`x`与`y`的和，然后再计算与`z`的和。\n\n但是少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的“右结合”（right-to-left associativity）。其中，最主要的是赋值运算符（`=`）和三元条件运算符（`?:`）。\n\n```javascript\nw = x = y = z;\nq = a ? b : c ? d : e ? f : g;\n```\n\n上面代码的运算结果，相当于下面的样子。\n\n```javascript\nw = (x = (y = z));\nq = a ? b : (c ? d : (e ? f : g));\n``` \n## 全部运算符优先级 汇总表\n下面的表将所有运算符按照优先级的不同从高到低排列。\n<table style=\"width:100%;margin-top:-8145px;\">\n  <tr>\n   <th>优先级</th>\n   <th>运算类型</th>\n   <th>关联性</th>\n   <th>运算符</th>\n  </tr>\n  <tr>\n   <td>19</td>\n   <td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Grouping\" title=\"圆括号运算符( ) 用来控制表达式中的运算优先级.\"><code>圆括号</code></a></td>\n   <td>n/a</td>\n   <td><code>( … )</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"3\">18</td>\n   <td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#点符号表示法\" title=\"属性访问器提供了两种方式用于访问一个对象的属性，它们分别是点符号和括号。\"><code>成员访问</code></a></td>\n   <td>从左到右</td>\n   <td><code>… . …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#括号表示法\" title=\"属性访问器提供了两种方式用于访问一个对象的属性，它们分别是点符号和括号。\"><code>需计算的成员访问</code></a></td>\n   <td>从左到右</td>\n   <td><code>… [ … ]</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\" title=\"new运算符的作用是创建一个对象实例。这个对象可以是用户自定义的，也可以是一些系统自带的带构造函数的对象。\"><code>new</code></a> (带参数列表)</td>\n   <td>n/a</td>\n   <td><code>new … ( … )</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"2\">17</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions\" title=\"JavaScript/Reference/Operators/Special_Operators/function_call\">函数调用</a></td>\n   <td>从左到右</td>\n   <td><code>… ( <var>… </var>)</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\" title=\"JavaScript/Reference/Operators/Special_Operators/new_Operator\">new</a> (无参数列表)</td>\n   <td>从右到左</td>\n   <td><code>new …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"2\">16</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">后置递增</a>(运算符在后)</td>\n   <td>n/a</td>\n   <td><code>… ++</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Decrement\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">后置递减</a>(运算符在后)</td>\n   <td>n/a</td>\n   <td><code>… --</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"9\">15</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_NOT\">逻辑非</a></td>\n   <td>从右到左</td>\n   <td><code>! …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位非</a></td>\n   <td>从右到左</td>\n   <td><code>~ …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">一元加法</a></td>\n   <td>从右到左</td>\n   <td><code>+ …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_negation\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">一元减法</a></td>\n   <td>从右到左</td>\n   <td><code>- …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">前置递增</a></td>\n   <td>从右到左</td>\n   <td><code>++ …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Decrement\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">前置递减</a></td>\n   <td>从右到左</td>\n   <td><code>-- …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\" title=\"JavaScript/Reference/Operators/Special_Operators/typeof_Operator\">typeof</a></td>\n   <td>从右到左</td>\n   <td><code>typeof …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void\" title=\"JavaScript/Reference/Operators/Special_Operators/void_Operator\">void</a></td>\n   <td>从右到左</td>\n   <td><code>void …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete\" title=\"JavaScript/Reference/Operators/Special_Operators/delete_Operator\">delete</a></td>\n   <td>从右到左</td>\n   <td><code>delete …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"3\">14</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Multiplication\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">乘法</a></td>\n   <td>从左到右</td>\n   <td><code>… * …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Division\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">除法</a></td>\n   <td>从左到右</td>\n   <td><code>… / …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">取模</a></td>\n   <td>从左到右</td>\n   <td><code>… % …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"2\">13</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Addition\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">加法</a></td>\n   <td>从左到右</td>\n   <td><code>… + …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Subtraction\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">减法</a></td>\n   <td>从左到右</td>\n   <td><code>… - …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"3\">12</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位左移</a></td>\n   <td>从左到右</td>\n   <td><code>… &lt;&lt; …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位右移</a></td>\n   <td>从左到右</td>\n   <td><code>… &gt;&gt; …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">无符号右移</a></td>\n   <td>从左到右</td>\n   <td><code>… &gt;&gt;&gt; …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"6\">11</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than_operator\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">小于</a></td>\n   <td>从左到右</td>\n   <td><code>… &lt; …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than__or_equal_operator\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">小于等于</a></td>\n   <td>从左到右</td>\n   <td><code>… &lt;= …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Greater_than_operator\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">大于</a></td>\n   <td>从左到右</td>\n   <td><code>… &gt; …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Greater_than_or_equal_operator\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">大于等于</a></td>\n   <td>从左到右</td>\n   <td><code>… &gt;= …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in\" title=\"JavaScript/Reference/Operators/Special_Operators/in_Operator\">in</a></td>\n   <td>从左到右</td>\n   <td><code>… in …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\" title=\"JavaScript/Reference/Operators/Special_Operators/instanceof_Operator\">instanceof</a></td>\n   <td>从左到右</td>\n   <td><code>… instanceof …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"4\">10</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">等号</a></td>\n   <td>从左到右</td>\n   <td><code>… == …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">非等号</a></td>\n   <td>从左到右</td>\n   <td><code>… != …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">全等号</a></td>\n   <td>从左到右</td>\n   <td><code>… === …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Nonidentity\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">非全等号</a></td>\n   <td>从左到右</td>\n   <td><code>… !== …</code></td>\n  </tr>\n  <tr>\n   <td>9</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_AND\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位与</a></td>\n   <td>从左到右</td>\n   <td><code>… &amp; …</code></td>\n  </tr>\n  <tr>\n   <td>8</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_XOR\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位异或</a></td>\n   <td>从左到右</td>\n   <td><code>… ^ …</code></td>\n  </tr>\n  <tr>\n   <td>7</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_OR\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位或</a></td>\n   <td>从左到右</td>\n   <td><code>… | …</code></td>\n  </tr>\n  <tr>\n   <td>6</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_AND\" title=\"JavaScript/Reference/Operators/Logical_Operators\">逻辑与</a></td>\n   <td>从左到右</td>\n   <td><code>… &amp;&amp; …</code></td>\n  </tr>\n  <tr>\n   <td>5</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_OR\" title=\"JavaScript/Reference/Operators/Logical_Operators\">逻辑或</a></td>\n   <td>从左到右</td>\n   <td><code>… || …</code></td>\n  </tr>\n  <tr>\n   <td>4</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\" title=\"JavaScript/Reference/Operators/Special_Operators/Conditional_Operator\">条件运算符</a></td>\n   <td>从右到左</td>\n   <td><code>… ? … : …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"12\">3</td>\n   <td rowspan=\"12\"><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators\" title=\"JavaScript/Reference/Operators/Assignment_Operators\">赋值</a></td>\n   <td rowspan=\"12\">从右到左</td>\n   <td><code>… = …</code></td>\n  </tr>\n  <tr>\n   <td><code>… += …</code></td>\n  </tr>\n  <tr>\n   <td><code>… -= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… *= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… /= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… %= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… &lt;&lt;= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… &gt;&gt;= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… &gt;&gt;&gt;= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… &amp;= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… ^= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… |= …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"2\" colspan=\"1\">2</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield\" title=\"JavaScript/Reference/Operators/yield\">yield</a></td>\n   <td>从右到左</td>\n   <td><code>yield …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*\" title=\"JavaScript/Reference/Operators/yield\">yield*</a></td>\n   <td>从右到左</td>\n   <td>yield* …</td>\n  </tr>\n  <tr>\n   <td>1</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" title=\"JavaScript/Reference/Operators/Spread_operator\">Spread</a></td>\n   <td>n/a</td>\n   <td><code>...</code> …</td>\n  </tr>\n  <tr>\n   <td>0</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator\" title=\"JavaScript/Reference/Operators/Comma_Operator\">逗号</a></td>\n   <td>从左到右</td>\n   <td><code>… , …</code></td>\n  </tr>\n\n</table>","source":"_posts/运算符-2016-02-25.md","raw":"title: 运算符\ndate: 2016-02-25 14:19:16\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n运算符是处理数据的基本方法，用来从现有数据得到新的数据。JavaScript与其他编程语言一样，提供了多种运算符。\n<!--more-->\n## 算术运算符\n\nJavaScript提供9个算术运算符。\n\n- **加法运算符**（Addition）：`x + y`\n- **减法运算符**（Subtraction）： `x - y`\n- **乘法运算符**（Multiplication）： `x * y`\n- **除法运算符**（Division）：`x / y`\n- **余数运算符**（Remainder）：`x % y`\n- **自增运算符**（Increment）：`++x` 或者 `x++`\n- **自减运算符**（Decrement）：`--x` 或者 `x--`\n- **数值运算符**（Convert to number）： `+x`\n- **负数值运算符**（Negate）：`-x`\n\n减法、乘法、除法运算法比较单纯，就是执行相应的数学运算。下面介绍其他几个算术运算符。\n\n### 加法运算符\n\n加法运算符（`+`）需要注意的地方是，它除了用于数值的相加，还能用于字符串的连接。\n\n```javascript\n1 + 1 // 2\n'1' + '1' // \"11\"\n'1.1' + '1.1' // \"1.11.1\"\n```\n\n上面代码中，如果两个运算子都是数值，加号运算符就执行数值的加法运算；如果两个运算子都是字符串，加号运算符就执行字符串的连接运算，变成字符串连接运算符。这种由于参数不同，而改变自身行为的现象，叫做“重载”（overload）。\n\n如果两个运算子之中，一个是字符串，另一个是数值，加法运算符执行字符串连接运算。\n\n```javascript\n1 + '1' // \"11\"\n```\n\n上面代码表示，两个运算子之中有一个是字符串，另一个运算子就会被自动转为字符串。\n\n```javascript\n'3' + 4 + 5 // \"345\"\n3 + 4 + '5' // \"75\"\n```\n\n上面代码中，由于加法运算符遇到字符串，会发生重载，导致运算结果的不同。\n\n由于这个特性，下面的写法有时用于将一个值转为字符串。\n\n```javascript\nx + ''\n```\n\n上面代码表示，一个值加上空字符串，会使得该值转为字符串形式。\n\n布尔值和复合类型的值，也可以使用加法运算符，但是会导致数据类型的自动转换，关于这方面的详细讨论，参见[《数据类型转换》](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n\n**除加法运算符以外的其他算术运算符，都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。**\n\n```javascript\n1 - '1' // 0\n+'3' // 3\n-true // -1\n```\n\n上面代码表示，减法运算符将字符串“1”自动转为数值1，数值运算符（+）将字符串“3”转为数值3，求负运算符（-）将布尔值true转为-1。\n\n由于加法运算符与其他算术运算符的这种差异，会导致一些意想不到的结果，计算时要小心。\n\n```javascript\nvar now = new Date();\ntypeof (now + 1) // \"string\"\ntypeof (now - 1) // \"number\"\n```\n\n上面代码中，`now`是一个Date对象的实例。加法运算时，`now`转为字符串，加一个数字，得到还是字符串；减法运算时，now转为数值，减一个数字，得到的是数字。\n<span style=\"color:red;\">Date对象比较特殊在和一个任意类型的数据相加的时候，会优先调用toString()方法，其他对象都是优先valueOf()</span>\n\n### 余数运算符\n\n余数运算符（`%`）返回前一个运算子被后一个运算子除，所得的余数。\n\n```javascript\n12 % 5 // 2\n```\n\n需要注意的是，运算结果的正负号由第一个运算子的正负号决定。\n\n```javascript\n-1 % 2 // -1\n1 % -2 // 1\n```\n\n为了得到正确的负数的余数值，需要先使用绝对值函数。\n\n```javascript\n// 错误的写法\nfunction isOdd(n) {\n  return n % 2 === 1;\n}\nisOdd(-5) // false\nisOdd(-4) // false\n\n// 正确的写法\nfunction isOdd(n) {\n  return Math.abs(n % 2) === 1;\n}\nisOdd(-5) // true\nisOdd(-4) // false\n```\n\n余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。\n\n```javascript\n6.5 % 2.1\n// 0.19999999999999973\n```\n\n### 自增和自减运算符\n\n自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。\n\n```javascript\nvar x = 1;\n++x // 2\nx // 2\n\n--x // 1\nx // 1\n```\n\n上面代码的变量x自增后，返回2，再进行自减，返回1。这两种情况都会使得，原始变量`x`的值发生改变。\n\n自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。\n\n```javascript\nvar x = 1;\nvar y = 1;\n\nx++ // 1\n++y // 2\n```\n\n上面代码中，`x`是先返回当前值，然后自增，所以得到1；`y`是先自增，然后返回新的值，所以得到2。\n\n### 数值运算符，负数值运算符\n\n数值运算符（`+`）同样使用加号，但是加法运算符是二元运算符（需要两个操作数），它是一元运算符（只需要一个操作数）。\n\n数值运算符的作用在于可以将任何值转为数值（与`Number`函数的作用相同）。\n\n```javascript\n+true // 1\n+[] // 0\n+{} // NaN\n```\n\n上面代码表示，非数值类型的值经过数值运算符以后，都变成了数值（最后一行`NaN`也是数值）。具体的类型转换规则，参见[《数据类型转换》](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n\n求负运算符（`-`），也同样具有将一个值转为数值的功能，所以下面的写法等同于数值运算符。\n\n```javascript\nvar x = 1;\n-x // -1\n-(-x) // 1\n\nvar y = \"111\";\n-y // -111\n```\n\n上面代码最后一行的圆括号不可少，否则会变成递减运算符。从中可以看出，数值运算符和负数值运算符，不会改变原始变量的值。\n\n## 赋值运算符\n\n赋值运算符（Assignment Operators）用于给变量赋值。\n\n### 何为\"左值\"?\n形如`A=B`的表达式称为赋值表达式。其中A和B又分别可以是表达式。B可以是任意表达式，但是A必须是一个左值。所谓左值，就是可以被赋值的表达式，在ES规范中是用内部类型引用(Reference)描述的。例如：\n  * 表达式`foo.bar`可以作为一个左值，表示对`foo`这个对象中`bar`这个名称的引用；\n  * 变量`email`可以作为一个左值，表示对当前执行环境中的环境记录项`envRec`中`email`这个名称的引用；\n  * 同样地，函数名`func`可以做左值，然而函数调用表达式`func(a, b)`不可以。\n\n那么JS引擎是怎样计算一般的赋值表达式 A = B的呢？简单地说，按如下步骤：\n  1. 计算表达式A，得到一个引用refA；\n  2. 计算表达式B，得到一个值valueB；\n  3. 将valueB赋给refA指向的名称绑定；\n  4. 返回valueB。\n\n### 结合性\n赋值表达式是右结合的。这意味着：\n\n    A1 = A2 = A3 = A4\n等价于\n\n    A1 = (A2 = (A3 = A4))\n### 连等的解析\n好了，有了上面两部分的知识。下面来看一下JS引擎是怎样运算连等赋值表达式的。\n\n    Exp1 = Exp2 = Exp3 = Exp4\n首先根据右结合性，可以转换成\n\n    Exp1 = (Exp2 = (Exp3 = Exp4))\n\n然后，我们已经知道对于单个赋值运算，JS引擎总是先计算左边的操作数，再计算右边的操作数。所以接下来的步骤就是：\n\n  1. 计算Exp1，得到Ref1\n  2. 计算Exp2，得到Ref2\n  3. 计算Exp3，得到Ref3\n  4. 计算Exp4，得到Value4。\n\n现在变成了这样的：\n\n    Ref1 = (Ref2 = (Ref3 = Value4))\n\n接下来的步骤是：\n\n 1. 将Value4赋给Exp3；\n 2. 将Value4赋给Exp2；\n 3. 将Value4赋给Exp1；\n 4. 返回表达式最终的结果Value4。\n\n总结一下就是：\n> 先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。\n\n最常见的赋值运算符，当然就是等号（`=`），表达式`x = y`表示将`y`的值赋给`x`。除此之外，JavaScript还提供其他11个赋值运算符。\n\n```javascript\nx += y // 等同于 x = x + y\nx -= y // 等同于 x = x - y\nx *= y // 等同于 x = x * y\nx /= y // 等同于 x = x / y\nx %= y // 等同于 x = x % y\nx >>= y // 等同于 x = x >> y\nx <<= y // 等同于 x = x << y\nx >>>= y // 等同于 x = x >>> y\nx &= y // 等同于 x = x & y\nx |= y // 等同于 x = x | y\nx ^= y // 等同于 x = x ^ y\n```\n\n上面11个赋值运算符，都是先进行某种运算，然后将得到值返回给左边的变量。\n\n### 小问题\n\n```javascript\nvar a = {n: 1};\nvar b = a;\na.x = a = {n: 2};\nalert(a.x); // --> undefined\nalert(b.x); // --> {n: 2}\n```\n首先前两个var语句执行完后，a和b都指向同一个对象`{n: 1}`(为方便描述，下面称为对象`N1`)。然后来看\n\n    a.x = a = {n: 2};\n根据前面的知识，首先依次计算表达式`a.x`和`a`，得到两个引用。其中`a.x`表示对象`N1`中的`x`，而`a`相当于`envRec.a`，即当前环境记录项中的`a`。所以此时可以写出如下的形式：\n\n    [[N1]].x = [[encRec]].a = {n: 2};//其中，[[]]表示引用指向的对象。\n接下来，将`{n: 2}`赋值给`[[encRec]].a`，即将`{n: 2}`绑定到当前上下文中的名称`a`。\n接下来，将同一个`{n: 2}`赋值给`[[N1]].x`，即将`{n: 2}`绑定到`N1`中的名称`x`。\n由于`b`仍然指向`N1`，所以此时有\n\n    b <=> N1 <=> {n: 1, x: {n: 2}}\n而a被重新赋值了，所以\n\n    a <=> {n: 2}\n并且\n\n    a === b.x\n\n如果你明白了上面所有的内容，应该会明白`a.x = a = {n:2};`与`b.x = a = {n:2};`是完全等价的。因为在解析`a.x`或`b.x`的那个时间点。`a`和`b`这两个名称指向同一个对象，就像C++中同一个对象可以有多个引用一样。而在这个时间点之后，不论是`a.x`还是`b.x`，其实早就不存在了，它已经变成了那个`内存中的对象.x`了。\n\n## 比较运算符\n\n比较运算符比较两个值，然后返回一个布尔值，表示是否满足比较条件。JavaScript提供了8个比较运算符。\n\n- `==` 相等\n- `===` 严格相等\n- `!=` 不相等\n- `!==` 严格不相等\n- `<` 小于\n- `<=` 小于或等于\n- `\\>` 大于\n- `\\>=` 大于或等于\n\n其中，比较两个值是否相等的运算符有两个：一个是相等运算符（`==`），另一个是严格相等运算符（`===`）。\n\n相等运算符（`==`）比较两个值是否相等，严格相等运算符（`===`）比较它们是否为“同一个值”。两者的一个重要区别是，如果两个值不是同一类型，严格相等运算符（`===`）直接返回false，而相等运算符（`==`）会将它们转化成同一个类型，再用严格相等运算符进行比较。\n\n### 严格相等运算符\n\n严格相等运算符的运算规则如下。\n\n**（1）不同类型的值**\n\n如果两个值的类型不同，直接返回`false`。\n\n```javascript\n1 === \"1\" // false\ntrue === \"true\" // false\n```\n\n上面代码比较数值的`1`与字符串的“1”、布尔值的`true`与字符串“true”，因为类型不同，结果都是`false`。\n\n**（2）同一类的原始类型值**\n\n同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。\n\n```javascript\n1 === 0x1 // true\n```\n\n上面代码比较十进制的1与十六进制的1，因为类型和值都相同，返回`true`。\n\n需要注意的是，`NaN`与任何值都不相等（包括自身）。另外，正0等于负0。\n\n```javascript\nNaN === NaN  // false\n+0 === -0 // true\n```\n\n**（3）同一类的复合类型值**\n\n两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。\n\n```javascript\n({}) === {} // false\n[] === [] // false\n(function (){}) === function (){} // false\n```\n\n上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是它们的内存地址是否一样，而上面代码中空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是`false`。另外，之所以要把第一个空对象放在括号内，是为了避免JavaScript引擎把这一行解释成代码块，从而报错；把第一个空函数放在括号内，是为了避免这一行被解释成函数的定义。\n\n如果两个变量指向同一个复合类型的数据，则它们相等。\n\n```javascript\nvar v1 = {};\nvar v2 = v1;\nv1 === v2 // true\n```\n\n**（4）undefined和null**\n\n`undefined`和`null`与自身严格相等。\n\n```javascript\nundefined === undefined // true\nnull === null // true\n```\n\n由于变量声明后默认值是`undefined`，因此两个只声明未赋值的变量是相等的。\n\n```javascript\nvar v1;\nvar v2;\nv1 === v2 // true\n```\n\n**（5）严格不相等运算符**\n\n严格相等运算符有一个对应的“严格不相等运算符”（`!==`），两者的运算结果正好相反。\n\n```javascript\n1 !== '1' // true\n```\n\n### 相等运算符\n\n相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。\n\n在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下：\n\n**（1）原始类型的值**\n\n原始类型的数据会转换成数值类型再进行比较。\n\n```javascript\n1 == true // true\n0 == false // true\n\n\"true\" == true // false\n\n'' == 0 // true\n\n'' == false  // true\n'1' == true  // true\n\n'2' == true // false\n2 == true // false\n2 == false // false\n\n'\\n  123  \\t' == 123 // true\n// 因为字符串转为数字时，省略前置和后置的空格\n```\n\n上面代码将字符串和布尔值都转为数值，然后再进行比较。字符串与布尔值的类型转换规则，参见[类型转换](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n\n**（2）对象与原始类型值比较**\n\n对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。\n\n```javascript\n[1] == 1 // true\n[1] == '1' // true\n[1] == true // true\n```\n\n上面代码将只含有数值1的数组与原始类型的值进行比较，数组`[1]`会被自动转换成数值`1`，因此结果都是`true`。数组的类型转换规则，参见[类型转换](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n\n**（3）undefined和null**\n\nundefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。\n\n```javascript\n\nfalse == null // false\n0 == null // false\n\nundefined == null // true\n\n```\n\n**（4）相等运算符的缺点**\n\n相等运算符隐藏的类型转换，会带来一些违反直觉的结果。\n\n```javascript\n\n'' == '0'           // false\n0 == ''             // true\n0 == '0'            // true\n\nfalse == 'false'    // false\nfalse == '0'        // true\n\nfalse == undefined  // false\nfalse == null       // false\nnull == undefined   // true\n\n' \\t\\r\\n ' == 0     // true\n\n```\n\n上面这些表达式都很容易出错，因此不要使用相等运算符（==），最好只使用严格相等运算符（===）。\n\n**（5）不相等运算符**\n\n相等运算符有一个对应的“不相等运算符”（!=），两者的运算结果正好相反。\n\n```javascript\n\n1 != \"1\" // false\n\n```\n**（6）详细比较过程**\n摘录[ES5标准](https://www.w3.org/html/ig/zh/wiki/ES5/expressions#.E7.AD.89.E4.BA.8E.E8.BF.90.E7.AE.97.E7.AC.A6.EF.BC.88.3D.3D.EF.BC.89)：以 x 和 y 为值进行 x == y 比较会产生的结果可为 true 或 false。比较的执行步骤如下：\n1. 若 Type(x) 与 Type(y) 相同， 则\n 1. 若 Type(x) 为 Undefined， 返回 true。\n 2. 若 Type(x)为 Null， 返回 true。\n 3. 若 Type(x)为 Number，则\n 4. 若 x 为 NaN，返回 false。\n 5. 若 y 为 NaN，返回 false。\n 6. 若 x 与 y 为相等数值，返回 true。\n 7. 若 x 为 +0 且 y 为 −0，返回 true。\n 8. 若 x 为 −0 且 y 为 +0，返回 true。\n 9. 返回 false。\n2. 若 Type(x) 为 String，则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true。否则，返回 false。\n3. 若 Type(x) 为 Boolean，当 x 和 y 为同为 true 或者同为 false 时返回 true。否则，返回 false。\n4. 当 x 和 y 为引用同一对象时返回 true。否则，返回 false。\n5. 若 x 为 null 且 y 为 undefined，返回 true。\n6. 若 x 为 undefined 且 y 为 null，返回 true。\n7. 若 Type(x) 为 Number 且 Type(y) 为 String，返回 x == ToNumber(y) 的结果。\n8. 若 Type(x) 为 String 且 Type(y) 为 Number，返回比较 ToNumber(x) == y 的结果。\n9. 若 Type(x) 为 Boolean，返回比较 ToNumber(x) == y 的结果。\n10. 若 Type(y) 为 Boolean，返回比较 x == ToNumber(y) 的结果。\n11. 若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果。\n12. 若 Type(x) 为 Object 且 Type(y) 为 String 或 Number，返回比较 ToPrimitive(x) == y 的结果。\n13. 返回 false。\n注：等于运算符不总是可传递。举例来说，两个代表相同 String 值但是不同的 String 对象会分别与 String 值 ==，但是两个对象间不相等。比如下例:\n\n```javascript\nvar a = 2; var b = 2;\nvar a1 = new Number(2); var b1 = new Number(2);\nconsole.log(a == a1) //true\nconsole.log(b == b1) //true\nconsole.log(a == b)  //true\nconsole.log(a1 == b1) //false\nvar a = \"123\"; var b = \"123\";\nvar a1 = new String(\"123\"); var b1 = new String(\"123\");\nconsole.log(a == a1) //true\nconsole.log(b == b1) //true\nconsole.log(a == b) //true\nconsole.log(a1 == b1) //false\n```\n注：<span style=\"color: red;\">不能将null 和undefined 转换成其他任何值，**可以见得： `null`、`undefined`只和`null`、`undefined`相等，和`false`和0比都是`false`。**</span>\n```javascript\nundefined == 0; //false\nnull == 0; //false\nfalse == null; //false\nfalse == undefined; //flase\n```\n### 小问题\n```javascript\nvar a;         // undefined\n!a             // true\na == false     // false\n\na = null;\n!a             // true\na == false     // false\n```\n上面的代码中，为什么!a中a能转换成false， 而a == false 中a就不能转换成false呢？\n\n## 布尔运算符\n\n布尔运算符用于将表达式转为布尔值。\n\n### 取反运算符（!）\n\n取反运算符形式上是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true。\n\n```javascript\n\n!true // false\n!false // true\n\n```\n\n对于非布尔值的数据，取反运算符会自动将其转为布尔值。规则是，以下六个值取反后为`true`，其他值取反后都为`false`。\n\n- undefined\n- null\n- false\n- 0（包括+0和-0）\n- NaN\n- 空字符串（\"\"）\n\n这意味着，取反运算符有转换数据类型的作用。\n\n```javascript\n!undefined // true\n!null // true\n!0 // true\n!NaN // true\n!\"\" // true\n\n!54 // false\n!'hello' // false\n![] // false\n!{} // false\n```\n\n上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。\n\n如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，<span style=\"color:red;\">与Boolean函数的作用相同</span>。这是一种常用的类型转换的写法。\n\n```javascript\n\n!!x\n\n// 等同于\n\nBoolean(x)\n\n```\n\n上面代码中，不管x是什么类型的值，经过两次取反运算后，变成了与Boolean函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。\n\n取反运算符的这种将任意数据自动转为布尔值的功能，对下面三种布尔运算符（且运算符、或运算符、三元条件运算符）都成立。\n\n### 且运算符（&&）\n\n且运算符的运算规则是：如果第一个运算子的布尔值为`true`，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为`false`，则直接返回第一个运算子的值，且不再对第二个运算子求值。\n\n```javascript\n\n\"t\" && \"\" // \"\"\n\"t\" && \"f\" // \"f\"\n\"t\" && (1+2) // 3\n\"\" && \"f\" // \"\"\n\"\" && \"\" // \"\"\n\nvar x = 1;\n(1-1) && (x+=1) // 0\nx // 1\n\n```\n\n上面代码的最后一部分表示，由于且运算符的第一个运算子的布尔值为`false`，则直接返回它的值`0`，而不再对第二个运算子求值，所以变量`x`的值没变。\n\n这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段`if`结构的代码，就可以用且运算符改写。\n\n```javascript\n\nif (i !== 0 ){\n\tdoSomething();\n}\n\n// 等价于\n\ni && doSomething();\n\n```\n\n上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。\n\n且运算符可以多个连用，这时返回第一个布尔值为`false`的表达式的值。\n\n```javascript\n\ntrue && 'foo' && '' && 4 && 'foo' && true // ''\n\n```\n\n上面代码中第一个布尔值为false的表达式为第三个表达式，所以得到一个空字符串。\n\n### 或运算符（||）\n\n或运算符的运算规则是：如果第一个运算子的布尔值为`true`，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为`false`，则返回第二个运算子的值。\n\n```javascript\n\n\"t\" || \"\" // \"t\"\n\"t\" || \"f\" // \"t\"\n\"\" || \"f\" // \"f\"\n\"\" || \"\" // \"\"\n\n```\n\n短路规则对这个运算符也适用。\n\n或运算符可以多个连用，这时返回第一个布尔值为`true`的表达式的值。\n\n```javascript\n\nfalse || 0 || '' || 4 || 'foo' || true // 4\n\n```\n\n上面代码中第一个布尔值为`true`的表达式是第四个表达式，所以得到数值4。\n\n或运算符常用于为一个变量设置默认值。\n\n```javascript\n\nfunction saveText(text) {\n    text = text || '';     // ...\n}\n\n// 或者写成\n\nsaveText(this.text || '')\n\n```\n\n上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。\n\n### 三元条件运算符（ ? :）\n\n三元条件运算符用问号（？）和冒号（：），分隔三个表达式。如果第一个表达式的布尔值为`true`，则返回第二个表达式的值，否则返回第三个表达式的值。\n\n```javascript\n\n\"t\" ? true : false // true\n\n0 ? true : false // false\n\n```\n\n上面代码的“t”和0的布尔值分别为`true`和`false`，所以分别返回第二个和第三个表达式的值。\n\n通常来说，三元条件表达式与`if...else`语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，`if...else`是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用`if..else`。\n\n```javascript\n\nvar check = true ? console.log('T') : console.log('F');\n\nconsole.log(true ? 'T' : 'F');\n\n```\n\n上面代码是赋值语句和`console.log`方法的例子，它们都需要使用表达式，这时三元条件表达式就能满足需要。如果要用`if...else`语句，就必须改变整个代码写法了。\n\n## 位运算符\n\n### 简介\nECMAScript 中的所有数值都以IEEE-754 64 位格式存储，但位操作符并不直接操作64 位的值。而是先将64 位的值转换成32 位的整数，然后执行操作，最后再将结果转换回64 位，位运算符用于直接对二进制位进行计算，一共有7个。\n如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值（自动完成），然后再应用位操作。\n\n- **或运算**（or）：符号为|，表示两个二进制位中有一个为1，则结果为1，否则为0。\n\n- **与运算**（and）：符号为&，表示两个二进制位都为1，则结果为1，否则为0。\n\n- **否运算**（not）：符号为～，表示将一个二进制位变成相反值。\n\n- **异或运算**（xor）：符号为&#710;，表示两个二进制位中有且仅有一个为1时，结果为1，否则为0。\n\n- **左移运算**（left shift）：符号为<<，详见下文解释。\n\n- **右移运算**（right shift）：符号为>>，详见下文解释。\n\n- **带符号位的右移运算**（zero filled right shift）：符号为>>>，详见下文解释。\n\n这些位运算符直接处理每一个比特位，所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会带来过度的复杂性。\n\n有一点需要特别注意，位运算符只对整数起作用，**如果一个运算子不是整数，会自动将小数部分舍去后再运行。另外，虽然在JavaScript内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。**\n\n在ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程：64 位的数值被转换成32位数值，然后执行位操作，最后再将32 位的结果转换回64 位数值。这样，表面上看起来就好像是在操作32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效应，**即在对特殊的NaN 和Infinity 值应用位操作时，这两个值都会被当成0 来处理**。\n\n```javascript\ni = i|0;\n```\n\n上面这行代码的意思，就是将`i`转为32位整数。\n\n### “或运算”与“与运算”\n\n这两种运算比较容易理解，就是逐位比较两个运算子。\n“或运算”的规则是，如果两个二进制位之中至少有一个位为1，则返回1，否则返回0。\n“与运算”的规则是，如果两个二进制位之中至少有一个位为0，则返回0，否则返回1。\n\n```javascript\n0 | 3 // 3\n0 & 3 // 0\n```\n\n上面两个表达式，0和3的二进制形式分别是00和11，所以进行“或运算”会得到11（即3），进行”与运算“会得到00（即0）。\n\n**位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。**所以，将一个小数与0进行或运算，等同于对该数去除小数部分，即取整数位。\n\n```javascript\n2.9 | 0\n// 2\n\n-2.9 | 0\n// -2\n\n```\n\n需要注意的是，这种取整方法不适用超过32位整数最大值2147483647的数。\n\n```javascript\n2147483649.4 | 0;\n// -2147483647\n\n```\n\n### 否运算\n\n“否运算”将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。\n\n```javascript\n~ 3 // -4\n```\n\n上面表达式对`3`进行`“否运算”`，得到`-4`。之所以会有这样的结果，是因为位运算时，JavaScirpt内部将所有的运算子都转为32位的二进制整数再进行运算。`3`在JavaScript内部是`00000000000000000000000000000011`，否运算以后得到`11111111111111111111111111111100`，由于第一位是`1`，所以这个数是一个负数。JavaScript内部采用`2`的补码形式表示负数，即需要将这个数减去`1`，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去`1`等于`11111111111111111111111111111011`，再取一次反得到`00000000000000000000000000000100`，再加上负号就是`-4`。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于`-1`。\n\n```javascript\n~ -3 // 2\n```\n\n上面表达式可以这样算，`-3`的取反值等于`-1`减去`-3`，结果为`2`。\n\n对一个整数连续两次“否运算”，得到它自身。\n\n```javascript\n~~3 // 3\n```\n\n<span style=\"color:red;\">所有的位运算都只对整数有效</span>。否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，**对一个小数连续进行两次否运算，能达到取整效果。**\n\n```javascript\n~~2.9 // 2\n~~47.11 // 47\n~~1.9999 // 1\n~~3 // 3\n~~-2.9 // -2\n```\n\n使用否运算取整，是所有取整方法中最快的一种。\n\n对字符串进行否运算，JavaScript引擎会先调用Number函数，将字符串转为数值。\n\n```javascript\n// 以下例子相当于~Number('011')\n~'011'  // -12\n~'42 cats' // -1\n~'0xcafebabe' // 889275713\n~'deadbeef' // -1\n\n// 以下例子相当于~~Number('011')\n~~'011';        // 11\n~~'42 cats';    // 0\n~~'0xcafebabe'; // -889275714\n~~'deadbeef';   // 0\n```\n\nNumber函数将字符串转为数值的规则，参见[类型转换](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)一节。\n<span style=\"color:red;\">否运算对特殊数值的处理是：超出32位的整数将会被截去超出的位数，NaN和Infinity转为0。</span>\n\n对于其他类型的参数，否运算也是先用`Number`转为数值，然后再进行处理。\n\n```javascript\n~~[] // 0\n~~NaN // 0\n~~null // 0\n```\n\n### 异或运算\n\n“异或运算”在两个二进制位不同时返回1，相同时返回0。\n\n```javascript\n0^3 // 3\n```\n\n上面表达式中，0的二进制形式是`00`，`3`的二进制形式是`11`，它们每一个二进制位都不同，所以得到`11（即3）`。\n\n“异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，`a^=b`, `b^=a`, `a^=b`，可以互换它们的值（详见[维基百科](http://en.wikipedia.org/wiki/XOR_swap_algorithm)）。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。\n\n```javascript\nvar a = 10;\nvar b = 99;\n\na^=b, b^=a, a^=b;\n\na // 99\nb // 10\n\n```\n\n这是互换两个变量的值的最快方法。\n\n异或运算也可以用来取整。\n\n```javascript\n12.9^0 // 12\n\n```\n\n### 左移运算符（<<）\n\n左移运算符表示将一个数的二进制形式向前移动，尾部补0。\n\n```javascript\n4 << 1\n// 8\n// 因为4的二进制形式为100，左移一位为1000（即十进制的8）\n\n-4 << 1\n// -8\n\n```\n\n上面代码中，`-4`左移一位之所以得到`-8`，是因为-4的二进制形式是`11111111111111111111111111111100`，左移一位后得到`11111111111111111111111111111000`，该数转为十进制（减去`1`后取反，再加上负号）即为`-8`。\n\n如果左移`0`位，就相当于取整，对于正数和负数都有效。\n\n```javascript\n13.5 << 0\n// 13\n\n-13.5 << 0\n// -13\n\n```\n\n左移运算符用于二进制数值非常方便。\n\n```javascript\n\nvar color = {r: 186, g: 218, b: 85};\n\n// RGB to HEX\nvar rgb2hex = function(r, g, b) {\n    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).substr(1);\n}\n\nrgb2hex(color.r,color.g,color.b)\n// \"#bada55\"\n\n```\n\n上面代码使用左移运算符，将颜色的RGB值转为HEX值。\n\n### 右移运算符（>>）\n\n右移运算符表示将一个数的二进制形式向右移动，头部补上最左位的值，即正数补0，负数补1。\n\n```javascript\n4 >> 1\n// 2\n/*\n// 因为4的二进制形式为00000000000000000000000000000100，\n// 右移一位得到00000000000000000000000000000010，\n// 即为十进制的2\n*/\n\n-4 >> 1\n// -2\n/*\n// 因为-4的二进制形式为11111111111111111111111111111100，\n// 右移一位，头部补1，得到11111111111111111111111111111110,\n// 即为十进制的-2\n*/\n```\n\n右移运算可以模拟2的整除运算。\n\n```javascript\n5 >> 1\n// 相当于 5 / 2 = 2\n\n21 >> 2\n// 相当于 21 / 4 = 5\n\n21 >> 3\n// 相当于 21 / 8 = 2\n\n21 >> 4\n// 相当于 21 / 16 = 1\n```\n\n### 小数取整的方法\n* 通过`Math`中自带的方法\n  * `Math.floor()`、`Math.round()`、`Math.ceil()`、`parseInt()`(这个会舍弃小数点`.`)\n* 位运算 所有位运算会把`NaN`、`Infinity`、`null`、`undefined` 当作0来处理\n  * `-4.1 << 0 // 4` 左移`0`位\n  * `12.9^0 // 12`\n  * `~~2.9 // 2`\n  * `-2.9 | 0 // 2`\n\n### 带符号位的右移运算符（>>>）\n\n该运算符表示将一个数的二进制形式向右移动，不管正数或负数，头部一律补`0`。所以，该运算总是得到正值，这就是它的名称`“带符号位的右移”`的涵义。对于正数，该运算的结果与右移运算符（>>）完全一致，区别主要在于负数。\n\n```javascript\n4 >>> 1\n// 2\n\n-4 >>> 1\n// 2147483646\n/*\n// 因为-4的二进制形式为11111111111111111111111111111100，\n// 带符号位的右移一位，得到01111111111111111111111111111110，\n// 即为十进制的2147483646。\n*/\n```\n\n### 开关作用\n\n位运算符可以用作设置对象属性的开关。\n假定某个对象有四个开关，每个开关都是一个变量，取值为2的整数次幂。\n```javascript\nvar FLAG_A = 1; // 0001\nvar FLAG_B = 2; // 0010\nvar FLAG_C = 4; // 0100\nvar FLAG_D = 8; // 1000\n\n```\n\n上面代码设置A、B、C、D四个开关，每个开关分别占有1个二进制位。\n现在假设需要打开ABD三个开关，我们可以构造一个掩码变量。\n```javascript\nvar mask = FLAG_A | FLAG_B | FLAG_D; // 0001 | 0010 | 1000 => 1011\n\n```\n\n上面代码对ABD三个变量进行“或运算”，得到掩码值为二进制的`1011`。\n有了掩码，就可以用“与运算”检验当前设置是否与开关设置一致。\n\n```javascript\nif (flags & FLAG_C) { // 0101 & 0100 => 0100 => true\n   // ...\n}\n\n```\n\n上面代码表示，如果当前设置与掩码一致，则返回`true`，否则返回`false`。\n`“或运算”`可以将当前设置改成开关设置。\n\n```javascript\nflags |= mask; \n\n```\n\n“与运算”可以将当前设置中凡是与开关设置不一样的项，全部关闭。\n\n```javascript\nflags &= mask; \n\n```\n\n“异或运算”可以切换（toggle）当前设置。\n\n```javascript\nflags = flags ^ mask; \n\n```\n\n“否运算”可以翻转当前设置。\n\n```javascript\nflags = ~flags;\n\n```\n\n## 其他运算符\n\n### 圆括号运算符\n\n在JavaScript中，圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。\n\n把表达式放在圆括号之中，将返回表达式的值。\n\n```javascript\n(1) // 1\n('a') // a\n(1+2) // 3\n\n```\n\n把对象放在圆括号之中，则会返回对象的值，即对象本身。\n\n```javascript\nvar o = {p:1};\n\n(o)\n// Object {p: 1}\n\n```\n\n将函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数，即对函数求值。\n\n```javascript\nfunction f(){return 1;}\n\n(f) // function f(){return 1;}\nf() // 1\n\n```\n\n上面的代码先定义了一个函数，然后依次将函数放在圆括号之中、将圆括号跟在函数后面，得到的结果是不一样的。\n\n由于圆括号的作用是求值，如果将语句放在圆括号之中，就会报错，因为语句没有返回值。\n\n```javascript\n(var a =1)\n// SyntaxError: Unexpected token var\n\n```\n\n### void运算符\n\n`void`运算符的作用是执行一个表达式，然后不返回任何值，或者说返回`undefined`。\n\n```javascript\nvoid 0 // undefined\nvoid(0) // undefined\n```\n\n上面是`void`运算符的两种写法，都正确。建议采用后一种形式，即总是使用括号。因为`void`运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，`void 4 + 7`实际上等同于`(void 4) + 7`。\n\n下面是`void`运算符的一个例子。\n\n```javascript\nvar x = 3;\nvoid (x = 5) //undefined\nx // 5\n```\n\n这个运算符主要是用于书签工具（bookmarklet），以及用于在超级链接中插入代码，目的是返回`undefined`可以防止网页跳转。\n\n```javascript\n<a href=\"javascript:void window.open('http://example.com/')\">\n  点击打开新窗口\n</a>\n```\n\n上面代码用于在网页中创建一个链接，点击后会打开一个新窗口。如果没有`void`，点击后就会在当前窗口打开链接。\n\n下面是常见的网页中触发鼠标点击事件的写法。\n\n```javascript\n<a href=\"http://example.com\" onclick=\"f();\">文字</a>\n```\n\n上面代码有一个问题，函数`f`必须返回`false`，或者说`onclick`事件必须返回`false`，否则会引起浏览器跳转到`example.com`。\n\n```javascript\nfunction f() {\n  // some code\n  return false;\n}\n```\n\n或者写成\n\n```javascript\n<a href=\"http://example.com\" onclick=\"f();return false;\">文字</a>\n```\n\n`void`运算符可以取代上面两种写法。\n\n```javascript\n<a href=\"javascript:void(f())\">文字</a>\n```\n\n下面的代码会提交表单，但是不会产生页面跳转。\n\n```javascript\n<a href=\"javascript:void(document.form.submit())\">\n文字</a>\n```\n\n### 逗号运算符\n\n逗号运算符用于对两个表达式求值，并返回后一个表达式的值。\n\n```javascript\n\n\"a\", \"b\" // \"b\"\n\nvar x = 0;\nvar y = (x++, 10);\nx // 1\ny // 10\n\n```\n\n## 运算顺序\n\n**（1）运算符的优先级**\n\nJavaScript各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。\n\n```javascript\n4 + 5 * 6 // 34\n```\n\n上面的代码中，乘法运算符（`*`）的优先性高于加法运算符（`+`），所以先执行乘法，再执行加法，相当于下面这样。\n\n```javascript\n4 + (5 * 6) // 34\n```\n\n如果多个运算符混写在一起，常常会导致令人困惑的代码。\n\n```javascript\nvar x = 1;\nvar arr = [];\n\nvar y = arr.length <= 0 || arr[0] === undefined ? x : arr[0];\n```\n\n上面代码中，变量`y`的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。\n\n根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（<=)、严格相等（===）、或（||）、三元（?:）、等号（=）。因此上面的表达式，实际的运算顺序如下。\n\n```javascript\nvar y = ((arr.length <= 0) || (arr[0] === undefined)) ? x : arr[0];\n```\n\n记住所有运算符的优先级，几乎是不可能的，也是没有必要的。\n\n**（2）圆括号的作用**\n\n圆括号可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的运算符会第一个运算。\n\n```javascript\n(4 + 5) * 6 // 54\n```\n\n上面代码中，由于使用了圆括号，加法会先于乘法执行。\n\n由于运算符的优先级别十分繁杂，且都是来自硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。\n\n**（3）左结合与右结合**\n\n对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的“左结合”（left-to-right associativity），即从左边开始计算。\n\n```javascript\nx + y + z\n```\n\n上面代码先计算最左边的`x`与`y`的和，然后再计算与`z`的和。\n\n但是少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的“右结合”（right-to-left associativity）。其中，最主要的是赋值运算符（`=`）和三元条件运算符（`?:`）。\n\n```javascript\nw = x = y = z;\nq = a ? b : c ? d : e ? f : g;\n```\n\n上面代码的运算结果，相当于下面的样子。\n\n```javascript\nw = (x = (y = z));\nq = a ? b : (c ? d : (e ? f : g));\n``` \n## 全部运算符优先级 汇总表\n下面的表将所有运算符按照优先级的不同从高到低排列。\n<table style=\"width:100%;margin-top:-8145px;\">\n  <tr>\n   <th>优先级</th>\n   <th>运算类型</th>\n   <th>关联性</th>\n   <th>运算符</th>\n  </tr>\n  <tr>\n   <td>19</td>\n   <td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Grouping\" title=\"圆括号运算符( ) 用来控制表达式中的运算优先级.\"><code>圆括号</code></a></td>\n   <td>n/a</td>\n   <td><code>( … )</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"3\">18</td>\n   <td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#点符号表示法\" title=\"属性访问器提供了两种方式用于访问一个对象的属性，它们分别是点符号和括号。\"><code>成员访问</code></a></td>\n   <td>从左到右</td>\n   <td><code>… . …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#括号表示法\" title=\"属性访问器提供了两种方式用于访问一个对象的属性，它们分别是点符号和括号。\"><code>需计算的成员访问</code></a></td>\n   <td>从左到右</td>\n   <td><code>… [ … ]</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\" title=\"new运算符的作用是创建一个对象实例。这个对象可以是用户自定义的，也可以是一些系统自带的带构造函数的对象。\"><code>new</code></a> (带参数列表)</td>\n   <td>n/a</td>\n   <td><code>new … ( … )</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"2\">17</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions\" title=\"JavaScript/Reference/Operators/Special_Operators/function_call\">函数调用</a></td>\n   <td>从左到右</td>\n   <td><code>… ( <var>… </var>)</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\" title=\"JavaScript/Reference/Operators/Special_Operators/new_Operator\">new</a> (无参数列表)</td>\n   <td>从右到左</td>\n   <td><code>new …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"2\">16</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">后置递增</a>(运算符在后)</td>\n   <td>n/a</td>\n   <td><code>… ++</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Decrement\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">后置递减</a>(运算符在后)</td>\n   <td>n/a</td>\n   <td><code>… --</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"9\">15</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_NOT\">逻辑非</a></td>\n   <td>从右到左</td>\n   <td><code>! …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位非</a></td>\n   <td>从右到左</td>\n   <td><code>~ …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">一元加法</a></td>\n   <td>从右到左</td>\n   <td><code>+ …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_negation\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">一元减法</a></td>\n   <td>从右到左</td>\n   <td><code>- …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">前置递增</a></td>\n   <td>从右到左</td>\n   <td><code>++ …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Decrement\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">前置递减</a></td>\n   <td>从右到左</td>\n   <td><code>-- …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\" title=\"JavaScript/Reference/Operators/Special_Operators/typeof_Operator\">typeof</a></td>\n   <td>从右到左</td>\n   <td><code>typeof …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void\" title=\"JavaScript/Reference/Operators/Special_Operators/void_Operator\">void</a></td>\n   <td>从右到左</td>\n   <td><code>void …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete\" title=\"JavaScript/Reference/Operators/Special_Operators/delete_Operator\">delete</a></td>\n   <td>从右到左</td>\n   <td><code>delete …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"3\">14</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Multiplication\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">乘法</a></td>\n   <td>从左到右</td>\n   <td><code>… * …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Division\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">除法</a></td>\n   <td>从左到右</td>\n   <td><code>… / …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">取模</a></td>\n   <td>从左到右</td>\n   <td><code>… % …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"2\">13</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Addition\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">加法</a></td>\n   <td>从左到右</td>\n   <td><code>… + …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Subtraction\" title=\"JavaScript/Reference/Operators/Arithmetic_Operators\">减法</a></td>\n   <td>从左到右</td>\n   <td><code>… - …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"3\">12</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位左移</a></td>\n   <td>从左到右</td>\n   <td><code>… &lt;&lt; …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位右移</a></td>\n   <td>从左到右</td>\n   <td><code>… &gt;&gt; …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">无符号右移</a></td>\n   <td>从左到右</td>\n   <td><code>… &gt;&gt;&gt; …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"6\">11</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than_operator\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">小于</a></td>\n   <td>从左到右</td>\n   <td><code>… &lt; …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than__or_equal_operator\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">小于等于</a></td>\n   <td>从左到右</td>\n   <td><code>… &lt;= …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Greater_than_operator\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">大于</a></td>\n   <td>从左到右</td>\n   <td><code>… &gt; …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Greater_than_or_equal_operator\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">大于等于</a></td>\n   <td>从左到右</td>\n   <td><code>… &gt;= …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in\" title=\"JavaScript/Reference/Operators/Special_Operators/in_Operator\">in</a></td>\n   <td>从左到右</td>\n   <td><code>… in …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\" title=\"JavaScript/Reference/Operators/Special_Operators/instanceof_Operator\">instanceof</a></td>\n   <td>从左到右</td>\n   <td><code>… instanceof …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"4\">10</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">等号</a></td>\n   <td>从左到右</td>\n   <td><code>… == …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">非等号</a></td>\n   <td>从左到右</td>\n   <td><code>… != …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">全等号</a></td>\n   <td>从左到右</td>\n   <td><code>… === …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Nonidentity\" title=\"JavaScript/Reference/Operators/Comparison_Operators\">非全等号</a></td>\n   <td>从左到右</td>\n   <td><code>… !== …</code></td>\n  </tr>\n  <tr>\n   <td>9</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_AND\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位与</a></td>\n   <td>从左到右</td>\n   <td><code>… &amp; …</code></td>\n  </tr>\n  <tr>\n   <td>8</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_XOR\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位异或</a></td>\n   <td>从左到右</td>\n   <td><code>… ^ …</code></td>\n  </tr>\n  <tr>\n   <td>7</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_OR\" title=\"JavaScript/Reference/Operators/Bitwise_Operators\">按位或</a></td>\n   <td>从左到右</td>\n   <td><code>… | …</code></td>\n  </tr>\n  <tr>\n   <td>6</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_AND\" title=\"JavaScript/Reference/Operators/Logical_Operators\">逻辑与</a></td>\n   <td>从左到右</td>\n   <td><code>… &amp;&amp; …</code></td>\n  </tr>\n  <tr>\n   <td>5</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_OR\" title=\"JavaScript/Reference/Operators/Logical_Operators\">逻辑或</a></td>\n   <td>从左到右</td>\n   <td><code>… || …</code></td>\n  </tr>\n  <tr>\n   <td>4</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\" title=\"JavaScript/Reference/Operators/Special_Operators/Conditional_Operator\">条件运算符</a></td>\n   <td>从右到左</td>\n   <td><code>… ? … : …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"12\">3</td>\n   <td rowspan=\"12\"><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators\" title=\"JavaScript/Reference/Operators/Assignment_Operators\">赋值</a></td>\n   <td rowspan=\"12\">从右到左</td>\n   <td><code>… = …</code></td>\n  </tr>\n  <tr>\n   <td><code>… += …</code></td>\n  </tr>\n  <tr>\n   <td><code>… -= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… *= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… /= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… %= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… &lt;&lt;= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… &gt;&gt;= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… &gt;&gt;&gt;= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… &amp;= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… ^= …</code></td>\n  </tr>\n  <tr>\n   <td><code>… |= …</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"2\" colspan=\"1\">2</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield\" title=\"JavaScript/Reference/Operators/yield\">yield</a></td>\n   <td>从右到左</td>\n   <td><code>yield …</code></td>\n  </tr>\n  <tr>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*\" title=\"JavaScript/Reference/Operators/yield\">yield*</a></td>\n   <td>从右到左</td>\n   <td>yield* …</td>\n  </tr>\n  <tr>\n   <td>1</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" title=\"JavaScript/Reference/Operators/Spread_operator\">Spread</a></td>\n   <td>n/a</td>\n   <td><code>...</code> …</td>\n  </tr>\n  <tr>\n   <td>0</td>\n   <td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator\" title=\"JavaScript/Reference/Operators/Comma_Operator\">逗号</a></td>\n   <td>从左到右</td>\n   <td><code>… , …</code></td>\n  </tr>\n\n</table>","slug":"运算符","published":1,"updated":"2016-06-11T07:48:31.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7pw0002543vrhssviap"},{"title":"类型转换","date":"2016-02-18T08:08:26.000Z","comments":1,"_content":"JavaScript是一种动态类型语言，变量是没有类型的，可以随时赋予任意值。但是，数据本身和各种运算是有类型的，因此运算时变量需要转换类型。大多数情况下，这种数据类型转换是自动的，但是有时也需要手动强制转换。\n<!--more-->\n## 强制转换\n强制转换主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。\n详细了解看这里：[好好学学Number！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n## 自动转换\n\n当遇到以下几种情况，JavaScript会自动转换数据类型：\n\n- 不同类型的数据进行互相运算；\n- 对非布尔值类型的数据求布尔值;\n- 对非数值类型的数据使用一元运算符（即“+”和“-”）。\n\n### 自动转换为布尔值\n\n当JavaScript遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。它的转换规则与上面的“强制转换成布尔值”的规则相同，也就是说，在预期为布尔值的地方，系统内部会自动调用Boolean方法。\n\n因此除了以下六个值，其他都是自动转为true：\n\n- undefined\n- null\n- -0\n- +0\n- NaN\n- ''（空字符串）\n\n### 自动转换为字符串\n\n当JavaScript遇到预期为字符串的地方，就会将非字符串的数据自动转为字符串，转换规则与“强制转换为字符串”相同。\n\n字符串的自动转换，主要发生在加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。\n\n```javascript\n'5' + 1 // '51'\n'5' + true // \"5true\"\n'5' + false // \"5false\"\n'5' + {} // \"5[object Object]\"\n'5' + [] // \"5\"\n'5' + function (){} // \"5function (){}\"\n'5' + undefined // \"5undefined\"\n'5' + null // \"5null\"\n```\n\n### 自动转换为数值\n\n当JavaScript遇到预期为数值的地方，就会将参数值自动转换为数值，转换规则与“强制转换为数值”相同。\n\n除了加法运算符有可能把运算子转为字符串，其他运算符都会把两侧的运算子自动转成数值。\n\n```javascript\n'5' - '2' // 3\n'5' * '2' // 10\ntrue - 1  // 0\nfalse - 1 // -1\n'1' - 1   // 0\n'5'*[]    // 0\nfalse/'5' // 0\n'abc'-1   // NaN\n```\n上面都是二元算术运算符的例子，JavaScript的两个一元算术运算符——正号和负号——也会把运算子自动转为数值。\n```javascript\n+'abc' // NaN\n-'abc' // NaN\n+true // 1\n-false // 0\n```\n\n### 小结\n\n由于自动转换有很大的不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String方法进行显式转换。\n\n## 加法运算符的类型转化\n\n加法运算符（+）需要特别讨论，因为它可以完成两种运算（加法和字符连接），所以不仅涉及到数据类型的转换，还涉及到确定运算类型。\n\n### 三种抽象操作\n加法运算符会触发三种类型转换(不包括一元`+`): 将值转换为原始值，转换为数字，转换为字符串，这刚好对应了JavaScript引擎内部的三种抽象操作: `ToPrimitive()`，`ToNumber()`，`ToString()`。\n\n#### 通过ToPrimitive()将值转换为原始值\n\nJavaScript引擎内部的抽象操作`ToPrimitive()`有着这样的签名:\n```javascript\n    ToPrimitive(input, PreferredType?)\n```\n可选参数PreferredType可以是Number或者String，它只代表了一个转换的偏好，转换结果不一定必须是这个参数所指的类型，但转换结果一定是一个原始值。\n如果PreferredType被标志为Number，则会进行下面的操作来转换输入的值:\n\n1. 如果输入的值已经是个原始值，则直接返回它。\n2. 否则，如果输入的值是一个对象。则调用该对象的valueOf()方法。如果valueOf()方法的返回值是一个原始值，则返回这个原始值。\n3. 否则，调用这个对象的toString()方法。如果toString()方法的返回值是一个原始值，则返回这个原始值。\n4. 否则，抛出TypeError异常。\n\n如果PreferredType被标志为String，则转换操作的第二步和第三步的顺序会调换。\n如果没有PreferredType这个参数，则PreferredType的值会按照这样的规则来自动设置：<span style=\"color:red;\">Date类型的对象会被设置为String，其它类型的值会被设置为Number。</span>\n如：\n```javascript\nnew Date() + 1 // \"Sat Jun 11 2016 12:32:55 GMT+0800 1\" 调用了 toString()\n\nvar a = {\n  valueOf:function(){\n    return 222\n    \n  },\n  toString:function(){\n    return \"aaa\"\n    \n  }};\n \"1\" + a//\"1222\"\n```\n#### 通过ToNumber()将值转换为数字\n下面的表格解释了ToNumber()是如何将原始值转换成数字的。\n\n| 参数 | 结果 |\n|:-----|:---:|\n|undefined| **`NaN`** |\n|null| **+0** |\n|布尔值| **true被转换为1，false转换为+0** |\n|数字| **无需转换** |\n|字符串| **由字符串解析为数字。例如，\"324\"被转换为324** |\n\n如果输入的值是一个对象，则会首先会调用ToPrimitive(obj， Number)将该对象转换为原始值，然后在调用ToNumber()将这个原始值转换为数字。\n\n#### 通过ToString()将值转换为字符串\n下面的表格解释了ToString()是如何将原始值转换成字符串的。\n\n| 参数 | 结果 |\n|:-----|:---:|\n|undefined| **\"undefined\"** |\n|null| **\"null\"** |\n|布尔值| **\"true\" 或者 \"false\"** |\n|数字| **数字作为字符串，比如。\"1.765\"** |\n|字符串| **无需转换** |\n如果输入的值是一个对象，则会首先会调用ToPrimitive(obj， String)将该对象转换为原始值，然后再调用ToString()将这个原始值转换为字符串。\n\n### 三种情况\n\n加法运算符的类型转换，可以分成三种情况讨论。\n\n**（1）运算子之中存在字符串**\n\n两个运算子之中，只要有一个是字符串，则另一个不管是什么类型，都会被自动转为字符串，然后执行字符串连接运算。前面的《自动转换为字符串》一节，已经举了很多例子。\n\n**（2）两个运算子都为数值或布尔值**\n\n这种情况下，执行加法运算，布尔值转为数值（`true`为1，`false`为0）。\n\n```javascript\ntrue + 5 // 6\n\ntrue + true // 2\n```\n\n**（3）运算子之中存在对象**\n\n运算子之中存在对象（或者准确地说，存在非简单类型的值），则先调用该对象的`valueOf`方法。如果返回结果为简单类型的值，则运用上面两条规则；否则继续调用该对象的`toString`方法，对其返回值运用上面两条规则。\n\n```javascript\n1 + [1，2]// \"11，2\"\nvar arr = [];\narr.valueOf() === arr //true\n```\n上面代码的运行顺序是，先调用`[1，2].valueOf()`，结果还是数组`[1，2]`本身，则继续调用`[1，2].toString()`，结果字符串`“1，2”`，所以最终结果为字符串`“11，2”`。\n```javascript\n1 + {a:1} // \"1[object Object]\"\n```\n对象`{a:1}`的`valueOf`方法，返回的就是这个对象的本身，因此接着对它调用`toString`方法。`({a:1}).toString()`默认返回字符串`\"[object Object]\"`，所以最终结果就是字符串`“1[object Object]”`。\n\n有趣的是，如果更换上面代码的运算次序，就会得到不同的值。\n```javascript\n{a:1} + 1 // 1\n```\n原来此时，JavaScript引擎不将`{a:1}`视为对象，而是视为一个代码块，这个代码块没有返回值，所以被忽略。因此上面的代码，实际上等同于 `{a:1};+1`，所以最终结果就是1。为了避免这种情况，需要对{a:1}加上括号。\n```javascript\n({a:1})+1 //\"[object Object]1\"\nconsole.log({a:1}+1) // \"[object Object]1\"\n```\n将`{a:1}`放置在括号之中，由于JavaScript引擎预期括号之中是一个值，所以不把它当作代码块处理，而是当作对象处理，所以最终结果为`“[object Object]1”`。\n\n```javascript\n1 + {valueOf:function(){return 2;}}// 3\n```\n上面代码的valueOf方法返回数值2，所以最终结果为3。\n```javascript\n1 + {valueOf:function(){return {};}}// \"1[object Object]\"\n```\n上面代码的`valueOf`方法返回一个空对象，则继续调用`toString`方法，所以最终结果是`“1[object Object]”`。\n```javascript\n1 + {valueOf:function(){return {};},toString:function(){return 2;}}// 3\n```\n上面代码的toString方法返回数值2（不是字符串），则最终结果就是数值3。\n```javascript\n1 + {valueOf:function(){return {};},toString:function(){return {};}}// TypeError: Cannot convert object to primitive value\n```\n上面代码的`toString`方法返回一个空对象，JavaScript就会报错，表示无法获得原始类型的值。\n\n### 四个特殊表达式\n\n有了上面这些例子，我们再进一步来看四个特殊表达式。\n\n**（1）空数组 + 空数组**\n\n```javascript\n[] + []// \"\"\n```\n\n首先，对空数组调用`valueOf`方法，返回的是数组本身；因此再对空数组调用`toString`方法，生成空字符串；所以，最终结果就是空字符串。\n\n**（2）空数组 + 空对象**\n```javascript\n[] + {}// \"[object Object]\"\n```\n\n这等同于空字符串与字符串`“[object Object]”`相加。因此，结果就是`“[object Object]”`。\n\n**（3）空对象 + 空数组**\n\n```javascript\n{} + []// 0\n```\n\nJavaScript引擎将空对象视为一个空的代码块，加以忽略。因此，整个表达式就变成`“+ []”`，等于对空数组求正值，因此结果就是0。转化过程如下：\n\n```javascript\n+ []\n\n// Number([])\n// Number([].toString())\n// Number(\"\")\n// 0\n```\n\n如果JavaScript不把前面的空对象视为代码块，则结果为字符串`“[object Object]”`。\n\n```javascript\n({}) + []// \"[object Object]\"\n```\n\n**（4）空对象 + 空对象**\n\n```javascript\n{} + {}// NaN\n```\n\nJavaScript同样将第一个空对象视为一个空代码块，整个表达式就变成`“+ {}”`。这时，后一个空对象的ValueOf方法得到本身，再调用toSting方法，得到字符串`“[object Object]”`，然后再将这个字符串转成数值，得到`NaN`。所以，最后的结果就是`NaN`。转化过程如下：\n\n```javascript\n+ {}\n\n// Number({})\n// Number({}.toString())\n// Number(\"[object Object]\")\n```\n\n如果，第一个空对象不被JavaScript视为空代码块，就会得到`“[object Object][object Object]”`的结果。\n\n```javascript\n({}) + {}// \"[object Object][object Object]\"\n\n({} + {})// \"[object Object][object Object]\"\t\n\nconsole.log({} + {})// \"[object Object][object Object]\"\n\nvar a = {} + {};\na\n// \"[object Object][object Object]\"\t\n```\n\n需要指出的是，对于第三和第四种情况，Node.js的运行结果不同于浏览器环境。\n\n```javascript\n{} + {}// \"[object Object][object Object]\"\n\n{} + []// \"[object Object]\"\n```\n\n可以看到，Node.js没有把第一个空对象视为代码块。原因是Node.js的命令行环境，内部执行机制大概是下面的样子：\n\n```javascript\neval.call(this，\"(function(){return {} + {}}).call(this)\")\n```\nNode.js把命令行输入都放在eval中执行，所以不会把起首的大括号理解为空代码块加以忽略。\n\n参考链接：[阮一峰](http://javascript.ruanyifeng.com/grammar/conversion.html)","source":"_posts/类型转换-2016-02-18.md","raw":"title: 类型转换\ndate: 2016-02-18 16:08:26\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\nJavaScript是一种动态类型语言，变量是没有类型的，可以随时赋予任意值。但是，数据本身和各种运算是有类型的，因此运算时变量需要转换类型。大多数情况下，这种数据类型转换是自动的，但是有时也需要手动强制转换。\n<!--more-->\n## 强制转换\n强制转换主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。\n详细了解看这里：[好好学学Number！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n## 自动转换\n\n当遇到以下几种情况，JavaScript会自动转换数据类型：\n\n- 不同类型的数据进行互相运算；\n- 对非布尔值类型的数据求布尔值;\n- 对非数值类型的数据使用一元运算符（即“+”和“-”）。\n\n### 自动转换为布尔值\n\n当JavaScript遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。它的转换规则与上面的“强制转换成布尔值”的规则相同，也就是说，在预期为布尔值的地方，系统内部会自动调用Boolean方法。\n\n因此除了以下六个值，其他都是自动转为true：\n\n- undefined\n- null\n- -0\n- +0\n- NaN\n- ''（空字符串）\n\n### 自动转换为字符串\n\n当JavaScript遇到预期为字符串的地方，就会将非字符串的数据自动转为字符串，转换规则与“强制转换为字符串”相同。\n\n字符串的自动转换，主要发生在加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。\n\n```javascript\n'5' + 1 // '51'\n'5' + true // \"5true\"\n'5' + false // \"5false\"\n'5' + {} // \"5[object Object]\"\n'5' + [] // \"5\"\n'5' + function (){} // \"5function (){}\"\n'5' + undefined // \"5undefined\"\n'5' + null // \"5null\"\n```\n\n### 自动转换为数值\n\n当JavaScript遇到预期为数值的地方，就会将参数值自动转换为数值，转换规则与“强制转换为数值”相同。\n\n除了加法运算符有可能把运算子转为字符串，其他运算符都会把两侧的运算子自动转成数值。\n\n```javascript\n'5' - '2' // 3\n'5' * '2' // 10\ntrue - 1  // 0\nfalse - 1 // -1\n'1' - 1   // 0\n'5'*[]    // 0\nfalse/'5' // 0\n'abc'-1   // NaN\n```\n上面都是二元算术运算符的例子，JavaScript的两个一元算术运算符——正号和负号——也会把运算子自动转为数值。\n```javascript\n+'abc' // NaN\n-'abc' // NaN\n+true // 1\n-false // 0\n```\n\n### 小结\n\n由于自动转换有很大的不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String方法进行显式转换。\n\n## 加法运算符的类型转化\n\n加法运算符（+）需要特别讨论，因为它可以完成两种运算（加法和字符连接），所以不仅涉及到数据类型的转换，还涉及到确定运算类型。\n\n### 三种抽象操作\n加法运算符会触发三种类型转换(不包括一元`+`): 将值转换为原始值，转换为数字，转换为字符串，这刚好对应了JavaScript引擎内部的三种抽象操作: `ToPrimitive()`，`ToNumber()`，`ToString()`。\n\n#### 通过ToPrimitive()将值转换为原始值\n\nJavaScript引擎内部的抽象操作`ToPrimitive()`有着这样的签名:\n```javascript\n    ToPrimitive(input, PreferredType?)\n```\n可选参数PreferredType可以是Number或者String，它只代表了一个转换的偏好，转换结果不一定必须是这个参数所指的类型，但转换结果一定是一个原始值。\n如果PreferredType被标志为Number，则会进行下面的操作来转换输入的值:\n\n1. 如果输入的值已经是个原始值，则直接返回它。\n2. 否则，如果输入的值是一个对象。则调用该对象的valueOf()方法。如果valueOf()方法的返回值是一个原始值，则返回这个原始值。\n3. 否则，调用这个对象的toString()方法。如果toString()方法的返回值是一个原始值，则返回这个原始值。\n4. 否则，抛出TypeError异常。\n\n如果PreferredType被标志为String，则转换操作的第二步和第三步的顺序会调换。\n如果没有PreferredType这个参数，则PreferredType的值会按照这样的规则来自动设置：<span style=\"color:red;\">Date类型的对象会被设置为String，其它类型的值会被设置为Number。</span>\n如：\n```javascript\nnew Date() + 1 // \"Sat Jun 11 2016 12:32:55 GMT+0800 1\" 调用了 toString()\n\nvar a = {\n  valueOf:function(){\n    return 222\n    \n  },\n  toString:function(){\n    return \"aaa\"\n    \n  }};\n \"1\" + a//\"1222\"\n```\n#### 通过ToNumber()将值转换为数字\n下面的表格解释了ToNumber()是如何将原始值转换成数字的。\n\n| 参数 | 结果 |\n|:-----|:---:|\n|undefined| **`NaN`** |\n|null| **+0** |\n|布尔值| **true被转换为1，false转换为+0** |\n|数字| **无需转换** |\n|字符串| **由字符串解析为数字。例如，\"324\"被转换为324** |\n\n如果输入的值是一个对象，则会首先会调用ToPrimitive(obj， Number)将该对象转换为原始值，然后在调用ToNumber()将这个原始值转换为数字。\n\n#### 通过ToString()将值转换为字符串\n下面的表格解释了ToString()是如何将原始值转换成字符串的。\n\n| 参数 | 结果 |\n|:-----|:---:|\n|undefined| **\"undefined\"** |\n|null| **\"null\"** |\n|布尔值| **\"true\" 或者 \"false\"** |\n|数字| **数字作为字符串，比如。\"1.765\"** |\n|字符串| **无需转换** |\n如果输入的值是一个对象，则会首先会调用ToPrimitive(obj， String)将该对象转换为原始值，然后再调用ToString()将这个原始值转换为字符串。\n\n### 三种情况\n\n加法运算符的类型转换，可以分成三种情况讨论。\n\n**（1）运算子之中存在字符串**\n\n两个运算子之中，只要有一个是字符串，则另一个不管是什么类型，都会被自动转为字符串，然后执行字符串连接运算。前面的《自动转换为字符串》一节，已经举了很多例子。\n\n**（2）两个运算子都为数值或布尔值**\n\n这种情况下，执行加法运算，布尔值转为数值（`true`为1，`false`为0）。\n\n```javascript\ntrue + 5 // 6\n\ntrue + true // 2\n```\n\n**（3）运算子之中存在对象**\n\n运算子之中存在对象（或者准确地说，存在非简单类型的值），则先调用该对象的`valueOf`方法。如果返回结果为简单类型的值，则运用上面两条规则；否则继续调用该对象的`toString`方法，对其返回值运用上面两条规则。\n\n```javascript\n1 + [1，2]// \"11，2\"\nvar arr = [];\narr.valueOf() === arr //true\n```\n上面代码的运行顺序是，先调用`[1，2].valueOf()`，结果还是数组`[1，2]`本身，则继续调用`[1，2].toString()`，结果字符串`“1，2”`，所以最终结果为字符串`“11，2”`。\n```javascript\n1 + {a:1} // \"1[object Object]\"\n```\n对象`{a:1}`的`valueOf`方法，返回的就是这个对象的本身，因此接着对它调用`toString`方法。`({a:1}).toString()`默认返回字符串`\"[object Object]\"`，所以最终结果就是字符串`“1[object Object]”`。\n\n有趣的是，如果更换上面代码的运算次序，就会得到不同的值。\n```javascript\n{a:1} + 1 // 1\n```\n原来此时，JavaScript引擎不将`{a:1}`视为对象，而是视为一个代码块，这个代码块没有返回值，所以被忽略。因此上面的代码，实际上等同于 `{a:1};+1`，所以最终结果就是1。为了避免这种情况，需要对{a:1}加上括号。\n```javascript\n({a:1})+1 //\"[object Object]1\"\nconsole.log({a:1}+1) // \"[object Object]1\"\n```\n将`{a:1}`放置在括号之中，由于JavaScript引擎预期括号之中是一个值，所以不把它当作代码块处理，而是当作对象处理，所以最终结果为`“[object Object]1”`。\n\n```javascript\n1 + {valueOf:function(){return 2;}}// 3\n```\n上面代码的valueOf方法返回数值2，所以最终结果为3。\n```javascript\n1 + {valueOf:function(){return {};}}// \"1[object Object]\"\n```\n上面代码的`valueOf`方法返回一个空对象，则继续调用`toString`方法，所以最终结果是`“1[object Object]”`。\n```javascript\n1 + {valueOf:function(){return {};},toString:function(){return 2;}}// 3\n```\n上面代码的toString方法返回数值2（不是字符串），则最终结果就是数值3。\n```javascript\n1 + {valueOf:function(){return {};},toString:function(){return {};}}// TypeError: Cannot convert object to primitive value\n```\n上面代码的`toString`方法返回一个空对象，JavaScript就会报错，表示无法获得原始类型的值。\n\n### 四个特殊表达式\n\n有了上面这些例子，我们再进一步来看四个特殊表达式。\n\n**（1）空数组 + 空数组**\n\n```javascript\n[] + []// \"\"\n```\n\n首先，对空数组调用`valueOf`方法，返回的是数组本身；因此再对空数组调用`toString`方法，生成空字符串；所以，最终结果就是空字符串。\n\n**（2）空数组 + 空对象**\n```javascript\n[] + {}// \"[object Object]\"\n```\n\n这等同于空字符串与字符串`“[object Object]”`相加。因此，结果就是`“[object Object]”`。\n\n**（3）空对象 + 空数组**\n\n```javascript\n{} + []// 0\n```\n\nJavaScript引擎将空对象视为一个空的代码块，加以忽略。因此，整个表达式就变成`“+ []”`，等于对空数组求正值，因此结果就是0。转化过程如下：\n\n```javascript\n+ []\n\n// Number([])\n// Number([].toString())\n// Number(\"\")\n// 0\n```\n\n如果JavaScript不把前面的空对象视为代码块，则结果为字符串`“[object Object]”`。\n\n```javascript\n({}) + []// \"[object Object]\"\n```\n\n**（4）空对象 + 空对象**\n\n```javascript\n{} + {}// NaN\n```\n\nJavaScript同样将第一个空对象视为一个空代码块，整个表达式就变成`“+ {}”`。这时，后一个空对象的ValueOf方法得到本身，再调用toSting方法，得到字符串`“[object Object]”`，然后再将这个字符串转成数值，得到`NaN`。所以，最后的结果就是`NaN`。转化过程如下：\n\n```javascript\n+ {}\n\n// Number({})\n// Number({}.toString())\n// Number(\"[object Object]\")\n```\n\n如果，第一个空对象不被JavaScript视为空代码块，就会得到`“[object Object][object Object]”`的结果。\n\n```javascript\n({}) + {}// \"[object Object][object Object]\"\n\n({} + {})// \"[object Object][object Object]\"\t\n\nconsole.log({} + {})// \"[object Object][object Object]\"\n\nvar a = {} + {};\na\n// \"[object Object][object Object]\"\t\n```\n\n需要指出的是，对于第三和第四种情况，Node.js的运行结果不同于浏览器环境。\n\n```javascript\n{} + {}// \"[object Object][object Object]\"\n\n{} + []// \"[object Object]\"\n```\n\n可以看到，Node.js没有把第一个空对象视为代码块。原因是Node.js的命令行环境，内部执行机制大概是下面的样子：\n\n```javascript\neval.call(this，\"(function(){return {} + {}}).call(this)\")\n```\nNode.js把命令行输入都放在eval中执行，所以不会把起首的大括号理解为空代码块加以忽略。\n\n参考链接：[阮一峰](http://javascript.ruanyifeng.com/grammar/conversion.html)","slug":"类型转换","published":1,"updated":"2016-06-11T06:28:09.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7q40007543vyjoywltq"},{"title":"类型检验","date":"2016-02-19T02:38:35.000Z","comments":1,"_content":"在JavaScript中，有5种简单数据类型和1种复杂数据类型，简单数据类型有：Undefined，Null，Boolean， Number和String；复杂数据类型是Object，Object中还细分了很多具体的类型，比如：Array，Function，Date，RegExp等等，还有我们自己定义的对象，自定义类型。今天我们就来探讨一下，使用什么方法判断一个出一个变量的类型。\n<!--more-->\n## 类型系统\n{% asset_img type.jpg %}\n\n## 类型转化表\n| Value | Boolean | Number | String |\n|:-----|:-----:|:-----:|:-----:|\n| undefined | false | NaN | \"undefined\" |\n| null | false | 0 | \"null\" |\n| true | true | 1 | \"true\" |\n| false | false | 0 | \"false\" |\n| '' | false | 0 | \"\" |\n| '123' | true | 123 | \"123\" |\n| '1a' | true | NaN | \"1a\" |\n| 0 | false | 0 | \"0\" |\n| 1 | true | 1 | \"1\" |\n| Infinity | true | Infinity | \"Infinity\" |\n| NaN | false | NaN | \"NaN\" |\n| {} | true | NaN | \"[object Object]\" |\n\n## 类型判断\n\n### typeof\n\n* 可以判别简单数据类型(null除外)\n* 不可判别具体的复杂数据类型(Function除外)\n\n```javascript\n//1. 可以判别简单数据类型(`null`除外)\nvar obj = 1;\ntypeof obj; //\"number\"\nobj = \"abc\"\ntypeof obj; //\"string\"\nobj = false\ntypeof obj; //\"boolean\"\nobj = undefined;\ntypeof obj; //\"undefined\"\nobj = null;\ntypeof obj; //\"object\"，WTF，其实这是js的一个bug，人艰不拆 T_T\n//2. 不可判别具体的复杂数据类型(`Function`除外)\nobj = function(){};\ntypeof obj; //\"function\"\nobj = [];\ntypeof obj; //\"object\"\nobj = {};\ntypeof obj; //\"object\"\nobj = /w/g;\ntypeof obj //\"object\"\nobj = new Error();\ntypeof obj //\"object\"\n```\n\n### instanceof\n`instanceof`左侧为查询变量，右侧为标识对象的类。\n* 能够判别复杂数据类型，但是不能判别`具体的复杂数据类型`和Object类型。\n* 不能判别简单数据类型，但是能判别通过基本包装行创建的变量。\n* 能够判别自定义类型。\n\n```javascript\nconsole.log(\n    //1. 不能判别简单数据类型 (number、string、boolean、null、undefined)，\n    99 instanceof Number,//false\n    \"2\" instanceof String,//false\n    true instanceof Boolean,//false\n    undefined instanceof Object,//false\n    null instanceof Object,//false\n    \n    //2.能够判别复杂数据类型，\n    [] instanceof Array,//true\n    {} instanceof Object,//true\n    (function(){}) instanceof Function,//true\n    (new Date()) instanceof Date,//true\n    /\\d/ instanceof RegExp,//true\n    (new Error()) instanceof Error,//true\n    //但是不能判别`具体的复杂数据类型`和Object类型\n    [] instanceof Object,//true\n    /\\d/ instanceof Object//true\n)\n//但是使用基本包装类型创建的对象通过 instanceof 可以判别。\n//如果指定obj = \"abc\"则obj保存的实际上就是abc的值，是一个基本类型。而如果指定obj = new String('abc')那么obj实际上保存的是一个指向字符串对象的指针。\nvar obj = new String('abc');\nobj instanceof String//true\n\"abc\" instanceof String//false \n\n//3. 能够判别自定义类型\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nvar c = new Point(2,3);\n\nc instanceof Point;//true\n```\n### Object.prototype.toString.call()\n* 能判别所有类型(除去自定义类型)\n* 不能判别自定义类型\n\n```javascript\n//1. 所有类型(除去自定义类型)\nconsole.log(\n    Object.prototype.toString.call(1),// '[object Number]'\n    Object.prototype.toString.call(\"abc\"),//'[object String]'\n    Object.prototype.toString.call(true),//'[object Boolean]'\n    Object.prototype.toString.call([]),//'[object Array]'\n    Object.prototype.toString.call({}),//'[object Object]'\n    Object.prototype.toString.call(function(){}),//'[object Function]'\n    Object.prototype.toString.call(undefined),//'[object Undefined]'\n    Object.prototype.toString.call(null),//'[object Null]'\n    Object.prototype.toString.call(new Date()),//'[object Date]'\n    Object.prototype.toString.call(/^[a-zA-Z]{5,20}$/),//'[object RegExp]'\n    Object.prototype.toString.call(new Error())//'[object Error]'\n);\n\n//2. 不能判别自定义类型\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nvar c = new Point(2,3);//c instanceof Point;//true\nObject.prototype.toString.call(c);//\"[object Object]\"\n```\n**简单封装**\n```javascript\nfunction typeProto(obj) {\n    return Object.prototype.toString.call(obj).slice(8,-1);\n}\n\ntypeProto(\"guo\");//\"String\"\ntypeProto({});//\"Object\"\n```\n\n### constructor\nconstructor本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用constructor属性的。\n* 不可判别`null`、`undefined`\n* 可判别简单类型数据(`null`、`undefined`除外)\n* 可判别复杂类型数据包括自定义类型数据\n```javascript\nfunction Person(){}\nvar Tom = new Person();\n// undefined和null没有constructor属性\nconsole.log(\n    Tom.constructor === Person,\n    (2).constructor === Number,//或者 2..constructor\n    \"abc\".constructor === String,\n    true.constructor === Boolean,\n    [].constructor === Array,\n    {}.constructor === Object,\n    (function aa(){}).constructor === Function,\n    (new Date()).constructor === Date,\n    /\\d/.constructor === RegExp,\n    (new Error()).constructor === Error\n);\n```\n不过使用constructor也不是保险的，因为constructor属性是可以被修改的，会导致检测出的结果不正确，例如：\n```javascript\nfunction Person(){}\nfunction Student(){}\nStudent.prototype = new Person();\nvar John = new Student();\nconsole.log(John.constructor==Student); // false\nconsole.log(John.constructor==Person);  // true\n```\n在上面的例子中，Student原型中的constructor被修改为指向到Person，导致检测不出实例对象John真实的构造函数。\n**注意：**\n同时，使用`instaceof`和`construcor`，被判断的array必须是在当前页面声明的！比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时在父页面判断该变量，Array(父页面的Array构造函数) === object(子页面穿过来的字页面的Array对象).constructor;肯定会返回false；原因：\n1. array属于引用型数据，在传递过程中，仅仅是引用地址的传递。\n2. 每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array；切记，不然很难跟踪问题！\n\n## 各种检验方法对应值\n| 类型判断 | typeof | instanceof | constructor | toString.call | $.type(jQuery库的方法) |\n| :-----|:-----:|:-----:|:-----:|:-----:|:-----:|\n| 99 | number | false | true | [object Number] | number |\n| \"abc\" | string | false | true | [object String] | string |\n| true | boolean | false | true | [object Boolean] | boolean |\n| [1,2] | object | true | true | [object Array] | array |\n| `{}` | object | true | true | [object Object] | object |\n| `(function aa(){})` | function | true | true | [object Function] | function |\n| `undefined` | undefined | false | - | [object Undefined] | undefined | \n| `null` | object | false | - | [object Null] | null |\n| `new Date()` | object | true | true | [object Date] | date |\n| `/\\d/` | object | true | true | [object RegExp] | regexp |\n| `new Error()` | object | true | true | [object Error] | error |\n| 优点\t| 使用简单，能直接输出结果 | 能检测出复杂的类型 | 基本能检测出所有的类型 | 检测出所有的类型\t|-|\n| 缺点\t| 检测出的类型太少 | 基本类型检测不出，且不能跨iframe | 不能跨iframe，且constructor易被修改 | IE6下undefined,null均为Object |-|\n    $.type 原理：先判断 undefined 和 null\n    obj == null ? String( obj ) : Object.prototype.toString.call(obj)\n\n## 一些常用的校验函数\n\n```javascript\n//低版本ie中undefined变量可以被修改，所以使用void 0 获取真实的undefined值，\nvar isUndefined = function(obj) {\n    //or: return typeof obj === 'undefined';\n    return obj === void 0;\n};\n//typeof null 的结果是\"object\"。\nvar isNull = function(obj) {\n    return obj === null;\n};\n// boolean值，number值和string值需要考虑两种情况，值为字面量时使用typeof和Object.prototype.toString能检测; \n// 值为构造函数构建的时候需要使用Object.prototype.toString或者instanceof检测\nvar isBoolean = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object Boolean]';\n};\nvar isNumber = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object Number]';\n};\nvar isString = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object String]';\n};\nvar isNaN = function(obj) {\n    return obj !== obj;\n};\n\n//typeof 操作符在引用类型的变量里能对function有效。\nvar isFunction = function(obj) {\n    //or:  return Object.prototype.toString.call(obj) == '[object Function]';\n    return typeof obj === 'function';\n\n};\nvar isDate = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object Date]';\n}\nvar isArray = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object Array]';\n}\nvar isObject = function(obj) {\n    //or: return obj === Object(obj);\n    return Object.prototype.toString.call(obj) == '[object Object]';\n}\n```","source":"_posts/类型检验-2016-02-19.md","raw":"title: 类型检验\ndate: 2016-02-19 10:38:35\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n在JavaScript中，有5种简单数据类型和1种复杂数据类型，简单数据类型有：Undefined，Null，Boolean， Number和String；复杂数据类型是Object，Object中还细分了很多具体的类型，比如：Array，Function，Date，RegExp等等，还有我们自己定义的对象，自定义类型。今天我们就来探讨一下，使用什么方法判断一个出一个变量的类型。\n<!--more-->\n## 类型系统\n{% asset_img type.jpg %}\n\n## 类型转化表\n| Value | Boolean | Number | String |\n|:-----|:-----:|:-----:|:-----:|\n| undefined | false | NaN | \"undefined\" |\n| null | false | 0 | \"null\" |\n| true | true | 1 | \"true\" |\n| false | false | 0 | \"false\" |\n| '' | false | 0 | \"\" |\n| '123' | true | 123 | \"123\" |\n| '1a' | true | NaN | \"1a\" |\n| 0 | false | 0 | \"0\" |\n| 1 | true | 1 | \"1\" |\n| Infinity | true | Infinity | \"Infinity\" |\n| NaN | false | NaN | \"NaN\" |\n| {} | true | NaN | \"[object Object]\" |\n\n## 类型判断\n\n### typeof\n\n* 可以判别简单数据类型(null除外)\n* 不可判别具体的复杂数据类型(Function除外)\n\n```javascript\n//1. 可以判别简单数据类型(`null`除外)\nvar obj = 1;\ntypeof obj; //\"number\"\nobj = \"abc\"\ntypeof obj; //\"string\"\nobj = false\ntypeof obj; //\"boolean\"\nobj = undefined;\ntypeof obj; //\"undefined\"\nobj = null;\ntypeof obj; //\"object\"，WTF，其实这是js的一个bug，人艰不拆 T_T\n//2. 不可判别具体的复杂数据类型(`Function`除外)\nobj = function(){};\ntypeof obj; //\"function\"\nobj = [];\ntypeof obj; //\"object\"\nobj = {};\ntypeof obj; //\"object\"\nobj = /w/g;\ntypeof obj //\"object\"\nobj = new Error();\ntypeof obj //\"object\"\n```\n\n### instanceof\n`instanceof`左侧为查询变量，右侧为标识对象的类。\n* 能够判别复杂数据类型，但是不能判别`具体的复杂数据类型`和Object类型。\n* 不能判别简单数据类型，但是能判别通过基本包装行创建的变量。\n* 能够判别自定义类型。\n\n```javascript\nconsole.log(\n    //1. 不能判别简单数据类型 (number、string、boolean、null、undefined)，\n    99 instanceof Number,//false\n    \"2\" instanceof String,//false\n    true instanceof Boolean,//false\n    undefined instanceof Object,//false\n    null instanceof Object,//false\n    \n    //2.能够判别复杂数据类型，\n    [] instanceof Array,//true\n    {} instanceof Object,//true\n    (function(){}) instanceof Function,//true\n    (new Date()) instanceof Date,//true\n    /\\d/ instanceof RegExp,//true\n    (new Error()) instanceof Error,//true\n    //但是不能判别`具体的复杂数据类型`和Object类型\n    [] instanceof Object,//true\n    /\\d/ instanceof Object//true\n)\n//但是使用基本包装类型创建的对象通过 instanceof 可以判别。\n//如果指定obj = \"abc\"则obj保存的实际上就是abc的值，是一个基本类型。而如果指定obj = new String('abc')那么obj实际上保存的是一个指向字符串对象的指针。\nvar obj = new String('abc');\nobj instanceof String//true\n\"abc\" instanceof String//false \n\n//3. 能够判别自定义类型\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nvar c = new Point(2,3);\n\nc instanceof Point;//true\n```\n### Object.prototype.toString.call()\n* 能判别所有类型(除去自定义类型)\n* 不能判别自定义类型\n\n```javascript\n//1. 所有类型(除去自定义类型)\nconsole.log(\n    Object.prototype.toString.call(1),// '[object Number]'\n    Object.prototype.toString.call(\"abc\"),//'[object String]'\n    Object.prototype.toString.call(true),//'[object Boolean]'\n    Object.prototype.toString.call([]),//'[object Array]'\n    Object.prototype.toString.call({}),//'[object Object]'\n    Object.prototype.toString.call(function(){}),//'[object Function]'\n    Object.prototype.toString.call(undefined),//'[object Undefined]'\n    Object.prototype.toString.call(null),//'[object Null]'\n    Object.prototype.toString.call(new Date()),//'[object Date]'\n    Object.prototype.toString.call(/^[a-zA-Z]{5,20}$/),//'[object RegExp]'\n    Object.prototype.toString.call(new Error())//'[object Error]'\n);\n\n//2. 不能判别自定义类型\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nvar c = new Point(2,3);//c instanceof Point;//true\nObject.prototype.toString.call(c);//\"[object Object]\"\n```\n**简单封装**\n```javascript\nfunction typeProto(obj) {\n    return Object.prototype.toString.call(obj).slice(8,-1);\n}\n\ntypeProto(\"guo\");//\"String\"\ntypeProto({});//\"Object\"\n```\n\n### constructor\nconstructor本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用constructor属性的。\n* 不可判别`null`、`undefined`\n* 可判别简单类型数据(`null`、`undefined`除外)\n* 可判别复杂类型数据包括自定义类型数据\n```javascript\nfunction Person(){}\nvar Tom = new Person();\n// undefined和null没有constructor属性\nconsole.log(\n    Tom.constructor === Person,\n    (2).constructor === Number,//或者 2..constructor\n    \"abc\".constructor === String,\n    true.constructor === Boolean,\n    [].constructor === Array,\n    {}.constructor === Object,\n    (function aa(){}).constructor === Function,\n    (new Date()).constructor === Date,\n    /\\d/.constructor === RegExp,\n    (new Error()).constructor === Error\n);\n```\n不过使用constructor也不是保险的，因为constructor属性是可以被修改的，会导致检测出的结果不正确，例如：\n```javascript\nfunction Person(){}\nfunction Student(){}\nStudent.prototype = new Person();\nvar John = new Student();\nconsole.log(John.constructor==Student); // false\nconsole.log(John.constructor==Person);  // true\n```\n在上面的例子中，Student原型中的constructor被修改为指向到Person，导致检测不出实例对象John真实的构造函数。\n**注意：**\n同时，使用`instaceof`和`construcor`，被判断的array必须是在当前页面声明的！比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时在父页面判断该变量，Array(父页面的Array构造函数) === object(子页面穿过来的字页面的Array对象).constructor;肯定会返回false；原因：\n1. array属于引用型数据，在传递过程中，仅仅是引用地址的传递。\n2. 每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array；切记，不然很难跟踪问题！\n\n## 各种检验方法对应值\n| 类型判断 | typeof | instanceof | constructor | toString.call | $.type(jQuery库的方法) |\n| :-----|:-----:|:-----:|:-----:|:-----:|:-----:|\n| 99 | number | false | true | [object Number] | number |\n| \"abc\" | string | false | true | [object String] | string |\n| true | boolean | false | true | [object Boolean] | boolean |\n| [1,2] | object | true | true | [object Array] | array |\n| `{}` | object | true | true | [object Object] | object |\n| `(function aa(){})` | function | true | true | [object Function] | function |\n| `undefined` | undefined | false | - | [object Undefined] | undefined | \n| `null` | object | false | - | [object Null] | null |\n| `new Date()` | object | true | true | [object Date] | date |\n| `/\\d/` | object | true | true | [object RegExp] | regexp |\n| `new Error()` | object | true | true | [object Error] | error |\n| 优点\t| 使用简单，能直接输出结果 | 能检测出复杂的类型 | 基本能检测出所有的类型 | 检测出所有的类型\t|-|\n| 缺点\t| 检测出的类型太少 | 基本类型检测不出，且不能跨iframe | 不能跨iframe，且constructor易被修改 | IE6下undefined,null均为Object |-|\n    $.type 原理：先判断 undefined 和 null\n    obj == null ? String( obj ) : Object.prototype.toString.call(obj)\n\n## 一些常用的校验函数\n\n```javascript\n//低版本ie中undefined变量可以被修改，所以使用void 0 获取真实的undefined值，\nvar isUndefined = function(obj) {\n    //or: return typeof obj === 'undefined';\n    return obj === void 0;\n};\n//typeof null 的结果是\"object\"。\nvar isNull = function(obj) {\n    return obj === null;\n};\n// boolean值，number值和string值需要考虑两种情况，值为字面量时使用typeof和Object.prototype.toString能检测; \n// 值为构造函数构建的时候需要使用Object.prototype.toString或者instanceof检测\nvar isBoolean = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object Boolean]';\n};\nvar isNumber = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object Number]';\n};\nvar isString = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object String]';\n};\nvar isNaN = function(obj) {\n    return obj !== obj;\n};\n\n//typeof 操作符在引用类型的变量里能对function有效。\nvar isFunction = function(obj) {\n    //or:  return Object.prototype.toString.call(obj) == '[object Function]';\n    return typeof obj === 'function';\n\n};\nvar isDate = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object Date]';\n}\nvar isArray = function(obj) {\n    return Object.prototype.toString.call(obj) == '[object Array]';\n}\nvar isObject = function(obj) {\n    //or: return obj === Object(obj);\n    return Object.prototype.toString.call(obj) == '[object Object]';\n}\n```","slug":"类型检验","published":1,"updated":"2016-06-11T05:26:42.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7q8000a543vj6i67sjy"},{"title":"如何学习javascript(转帖)","date":"2016-01-27T02:24:34.000Z","comments":1,"_content":"# 首先说明\n首先要说明的是，咱现在不是高手，最多还是一个半桶水，算是入了JS的门。 谈不上经验，都是一些教训。这个时候有人要说，“靠，你丫半桶水，凭啥教我们”。您先别急着骂，先听我说。你叫一个大学生去教小学数学，不见得比一个初中生教得好。因为大学生早已经过了那个阶段，都忘记自己怎么走过来的了。而对于初中生，刚好走过那个阶段，对自己怎么走过来的还记忆犹新，或者还有一些自己的总结。比如，很多高手觉得那本犀牛书入门很好，他们觉得太简单了，但以我的经验来看，它不是入门的最好选择。\n<!--more-->\n# 先说说学js的条件\n论条件，咱是文科生，大学专业工商管理，和计算机毛关系都没；有人说英语，读了四年大学，很遗憾，咱还四级没混过；就咱这条件都学得乐呵呵的，您还等啥。 当然学习JS也是有门槛的，就是你的html和css至少还比较熟练，您不能连<body>这东东是干啥的都不知道就开始上JS了，学乘除前，学好加减法总是有益无害的。\n# 再说几点忠告\n\n1. 不要着急看一些复杂网页效果的代码，这样除了打击你自信心，什么也学不到。没达到一定的武功水平，割了小JJ也学不会葵花宝典的。\n2. 别急着加技术交流QQ群，加牛人QQ。如果你找张三丰交流武功，你上去第一句问“丰哥，where is 丹田？”，你会被他一掌劈死的。\n3. 看网上什么多少天精通JS，啥啥啥从入门到精通，这种教程直接跳过吧，太多的事实证明，以一种浮躁的心态去做任何事都会以失败而告终。\n4. 千万别去弄啥电脑培训，花了钱和时间不说，关键是学不到东西。本来你买两本好书自学3个月能学会的，他们硬是能折腾你两年。\n\n# 推荐几本好书\n“超毛，你丫吹了半天牛B，还是没说怎么学啊” 呵呵，我也没啥特别的办法，只是推荐几本好书。推荐的书，得按先后顺序看。别第一本没看完，就急着上第二本，并不是每次“穿越”都能成功的\n## 第一阶段：《JavaScript DOM编程艺术》\n看这本书之前，请先确认您对Javascript有个基本的了解，应该知道if else之类的语法，如果不懂，先去看看我第二阶段推荐的《Javascript高级程序设计》的前三章，记住看三章就别往下看了，回到《JavaScript DOM编程艺术》这本书上来。 学习Javascript用《JavaScript DOM编程艺术》来入门最好不过了，老老实实看两遍，看完了你就会对JS有一个大概的了解，整本书都围绕着一个网页效果例子展开，你跟着老老实实敲一篇，敲完之后，你会发现这个效果不是常在网页中看到么，发现自己也能做出来网上的效果了，嘿嘿，小有成就感吧。\n## 第二阶段：《JavaScript高级程序设计》\n有的书是用来成为经典的，比如犀牛书；还有些书是用来超越经典的，显然这本书就是这种。书中章章经典，由浅入深，其中第6章，关于JS面向对象的解说，没有教程出其右。 如果有一场满分100分的JS考试，看了《JavaScript DOM编程艺术》能让你拿到20分，那么看完这本书，你就能拿到60分以上了。学完后，你会成就感倍增的，相信我（至少看两遍，推荐三篇，跟着书上的代码一行行的敲）。 这本书强烈推荐购买，写的太TMD牛逼了，给你带来的价值超过百倍千倍。 这本书最新的是第三版，貌似就是前些日子出来的，我看的是第二版，第三版相对第二版变动不大，添加了几章内容，价格目前相差10元左右。 接下来，恭喜你可以下山了，这个时候可以自己做一些事情了。 你可以去Ferris这个教程看看他写的这些效果，看看源代码，怎么样，是不是觉得有一部分很简单了，尝试着跟着他写一写这些效果吧。 学技术闭门造车是行不通的，适当的加一两个QQ群交流（注重质量），常去论坛逛逛，你会经常有些小收获的。 再有就是看看前辈这些牛人前辈们分享的文章，它会让你的学习事半功倍的，这里是热心人收集的国内一些牛人的博客、个人网站，点这里。\n## 第三阶段：《JavaScript语言精粹》和《高性能JavaScript》\n接下来两本书《JavaScript语言精粹》和《高性能JavaScript》算是JS高级教程的补充，里面有一些内容和JS高级教程重复了，两本书可以同时看，都不厚，可以对前面所学的有一个很好的加强和巩固。\n## 第四阶段：《JavaScript DOM高级程序设计》和《JavaScript设计模式》\n在吃透了前面所说的书之后，接下来两本书的顺序已经无关紧要了，《JavaScript DOM高级程序设计》（注意和《JavaScript 高级程序设计》相区别）和《JavaScript设计模式》，这两本都是重量级的书，能让你的JS技术上一个新的台阶；这两本书前者主修炼外功，后者主修炼内功，有点想乾坤大挪移和九阳神功的关系。《JavaScript DOM高级程序设计》 首先教你搭建一个类似JQuery的额工具函数库，然后通过讲解几个实际中经常遇到的几个应用例子，会让初学者受益匪浅。《JavaScript设计模式》主要讲Javascript的设计模式，说实话，翻译的质量很一般，有些生硬，但已经基本不影响你的学习，看代码完全可以理解出自己的意思。\n# 最后想说的\n不安逸，不浮躁。任何学习都不是一蹴而就的，牛B就是一个学习积累的过程，别指望两三个月，你的水平就多么厉害。倚天屠龙记里面的武功最牛B的是张三丰，而不是张无忌。任何工作都需要多种技能，别忽略了html, css等其他知识的学习。\n\n>转自 (博客园)[http://kb.cnblogs.com/page/191787/]","source":"_posts/如何学习javascript-转帖-2016-01-27.md","raw":"title: 如何学习javascript(转帖)\ndate: 2016-01-27 10:24:34\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# 首先说明\n首先要说明的是，咱现在不是高手，最多还是一个半桶水，算是入了JS的门。 谈不上经验，都是一些教训。这个时候有人要说，“靠，你丫半桶水，凭啥教我们”。您先别急着骂，先听我说。你叫一个大学生去教小学数学，不见得比一个初中生教得好。因为大学生早已经过了那个阶段，都忘记自己怎么走过来的了。而对于初中生，刚好走过那个阶段，对自己怎么走过来的还记忆犹新，或者还有一些自己的总结。比如，很多高手觉得那本犀牛书入门很好，他们觉得太简单了，但以我的经验来看，它不是入门的最好选择。\n<!--more-->\n# 先说说学js的条件\n论条件，咱是文科生，大学专业工商管理，和计算机毛关系都没；有人说英语，读了四年大学，很遗憾，咱还四级没混过；就咱这条件都学得乐呵呵的，您还等啥。 当然学习JS也是有门槛的，就是你的html和css至少还比较熟练，您不能连<body>这东东是干啥的都不知道就开始上JS了，学乘除前，学好加减法总是有益无害的。\n# 再说几点忠告\n\n1. 不要着急看一些复杂网页效果的代码，这样除了打击你自信心，什么也学不到。没达到一定的武功水平，割了小JJ也学不会葵花宝典的。\n2. 别急着加技术交流QQ群，加牛人QQ。如果你找张三丰交流武功，你上去第一句问“丰哥，where is 丹田？”，你会被他一掌劈死的。\n3. 看网上什么多少天精通JS，啥啥啥从入门到精通，这种教程直接跳过吧，太多的事实证明，以一种浮躁的心态去做任何事都会以失败而告终。\n4. 千万别去弄啥电脑培训，花了钱和时间不说，关键是学不到东西。本来你买两本好书自学3个月能学会的，他们硬是能折腾你两年。\n\n# 推荐几本好书\n“超毛，你丫吹了半天牛B，还是没说怎么学啊” 呵呵，我也没啥特别的办法，只是推荐几本好书。推荐的书，得按先后顺序看。别第一本没看完，就急着上第二本，并不是每次“穿越”都能成功的\n## 第一阶段：《JavaScript DOM编程艺术》\n看这本书之前，请先确认您对Javascript有个基本的了解，应该知道if else之类的语法，如果不懂，先去看看我第二阶段推荐的《Javascript高级程序设计》的前三章，记住看三章就别往下看了，回到《JavaScript DOM编程艺术》这本书上来。 学习Javascript用《JavaScript DOM编程艺术》来入门最好不过了，老老实实看两遍，看完了你就会对JS有一个大概的了解，整本书都围绕着一个网页效果例子展开，你跟着老老实实敲一篇，敲完之后，你会发现这个效果不是常在网页中看到么，发现自己也能做出来网上的效果了，嘿嘿，小有成就感吧。\n## 第二阶段：《JavaScript高级程序设计》\n有的书是用来成为经典的，比如犀牛书；还有些书是用来超越经典的，显然这本书就是这种。书中章章经典，由浅入深，其中第6章，关于JS面向对象的解说，没有教程出其右。 如果有一场满分100分的JS考试，看了《JavaScript DOM编程艺术》能让你拿到20分，那么看完这本书，你就能拿到60分以上了。学完后，你会成就感倍增的，相信我（至少看两遍，推荐三篇，跟着书上的代码一行行的敲）。 这本书强烈推荐购买，写的太TMD牛逼了，给你带来的价值超过百倍千倍。 这本书最新的是第三版，貌似就是前些日子出来的，我看的是第二版，第三版相对第二版变动不大，添加了几章内容，价格目前相差10元左右。 接下来，恭喜你可以下山了，这个时候可以自己做一些事情了。 你可以去Ferris这个教程看看他写的这些效果，看看源代码，怎么样，是不是觉得有一部分很简单了，尝试着跟着他写一写这些效果吧。 学技术闭门造车是行不通的，适当的加一两个QQ群交流（注重质量），常去论坛逛逛，你会经常有些小收获的。 再有就是看看前辈这些牛人前辈们分享的文章，它会让你的学习事半功倍的，这里是热心人收集的国内一些牛人的博客、个人网站，点这里。\n## 第三阶段：《JavaScript语言精粹》和《高性能JavaScript》\n接下来两本书《JavaScript语言精粹》和《高性能JavaScript》算是JS高级教程的补充，里面有一些内容和JS高级教程重复了，两本书可以同时看，都不厚，可以对前面所学的有一个很好的加强和巩固。\n## 第四阶段：《JavaScript DOM高级程序设计》和《JavaScript设计模式》\n在吃透了前面所说的书之后，接下来两本书的顺序已经无关紧要了，《JavaScript DOM高级程序设计》（注意和《JavaScript 高级程序设计》相区别）和《JavaScript设计模式》，这两本都是重量级的书，能让你的JS技术上一个新的台阶；这两本书前者主修炼外功，后者主修炼内功，有点想乾坤大挪移和九阳神功的关系。《JavaScript DOM高级程序设计》 首先教你搭建一个类似JQuery的额工具函数库，然后通过讲解几个实际中经常遇到的几个应用例子，会让初学者受益匪浅。《JavaScript设计模式》主要讲Javascript的设计模式，说实话，翻译的质量很一般，有些生硬，但已经基本不影响你的学习，看代码完全可以理解出自己的意思。\n# 最后想说的\n不安逸，不浮躁。任何学习都不是一蹴而就的，牛B就是一个学习积累的过程，别指望两三个月，你的水平就多么厉害。倚天屠龙记里面的武功最牛B的是张三丰，而不是张无忌。任何工作都需要多种技能，别忽略了html, css等其他知识的学习。\n\n>转自 (博客园)[http://kb.cnblogs.com/page/191787/]","slug":"如何学习javascript-转帖","published":1,"updated":"2016-01-27T02:42:52.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7qg000d543v919gfst8"},{"title":"好好学学undefined！","date":"2016-01-29T01:48:56.000Z","comments":1,"_content":"# undefined类型\nundefined类型只有一个值，即特殊的undefined，我们称之为`字面值undefined`，undefined意为`未定义`。\n<!--more-->\n`字面值undefined`是全局Global对象（window）的一个特殊属性，其值是未定义的。但 typeof window.undefined 返回\"undefined\" 。\n\n我们可以通过下面的例子来验证undefined是否为全局Global对象（window）的属性:\n\n    alert('undefined' in window);//输出：true   \n    var anObj = {};   \n    alert('undefined' in anObj); //输出：false \n    从中可以看出，undefined是window对象的一个属性，但却不是anObj对象的一个属性。\n## `字面值undefined`的产生\n`字面值undefined`产生的原因有5种：\n\n    * 访问对象不存在的属性或方法\n    * 声明了变量但从未赋值\n    * 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n    * 方法没有返回值，默认返回undefined\n    * 访问越界的数组。\n    * void(expression) 形式的表达式。\n    \n    {% codeblock lang:JavaScript %}\n    var v1,obj = {};      \n      \n    console.log(v1); //`字面值undefined`    \n    console.log(obj.get); //`字面值undefined`\n    \n    typeof v1; // \"undefined\"    \n    typeof v2; // 对未声明的变量使用typeof 也会输出 \"undefined\"。     \n    typeof obj.get; // \"undefined\"\n    \n    var message1 = undefined;  //显示的设置为undefined\n    typeof message1 //\"undefined\"\n    \n    function test(){}; \n    console.log(test()); //`字面值undefined`\n    \n    var arr = []; \n    console.log(arr[8]) //`字面值undefined`\n    {% endcodeblock %}\n        \n<span style=\"color: red;\">当我们在程序中使用`字面值undefined`时，实际上使用的是window对象的undefined属性，同样，当我们定义一个变量但未赋予其初始值，例如：`var aValue;`这时，JavaScript在预编译时会将其初始值设置为对window.undefined属性的引用，于是，当我们将一个变量或值与undefined比较时，实际上是与window对象的undefined属性比较。这个比较过程中，JavaScript会搜索window对象名叫\"undefined\"的属性，然后再比较两个操作数的引用指针是否相同。</span>\n\n---\n您可以通过将变量与`字面值undefined`进行比较确定变量是否存在，您也可以通过将变量的类型与字符串“undefined”进行比较确定其类型是否为 undefined类型。\n以下示例演示了如何确定已声明的变量的 x：\n        \n    var x;\n    \n    // This method works.\n    if (x == undefined) { //这种方式只能对已经声明的变量使用，对未声明的变量使用会报错。\n        document.write(\"comparing x to undefined <br/>\");\n    }\n    \n    // This method doesn't work - you must check for the string \"undefined\".\n    if (typeof(x) == undefined) {//未执行，因为typeof 方法返回的是字符串。\n        document.write(\"comparing the type of x to undefined <br/>\");\n    }\n    // This method does work. \n    if (typeof(x) == \"undefined\") {\n        document.write(\"comparing the type of x to the string 'undefined'\");\n    }\n    \n    // Output: \n    // comparing x to undefined \n    // comparing the type of x to the string 'undefined'\n## 提高访问`字面值undefined`的性能：\n由于window对象的属性值是非常多的，在每一次与`字面值undefined`的比较中，搜索window对象的undefined属性都会花费时间。在需要频繁与undefined进行比较的函数中，这可能会是一个性能问题点。因此，在这种情况下，我们可以自行定义一个局部的undefined变量，来加快对undefined的比较速度。例如：\n\n    function anyFunc() {\n        var undefined; //自定义局部undefined变量\n        if (x == undefined){} //作用域上的引用比较\n        while (y != undefined){} //作用域上的引用比较\n    };\n其中，定义undefined局部变量时，其初始值会是对window.undefined属性值的引用。新定义的局部undefined变量存在与该函数的作用域上。\n在随后的比较操作中，JavaScript代码的书写方式没有任何的改变，但比较速度却很快。因为作用域上的变量数量会远远少于window对象的属性，搜索变量的速度会极大提高。\n这就是许多前端JS框架为什么常常要自己定义一个局部undefined变量的原因!!!\n比如jQuery 源码：\n\n    (function( window, undefined ) {\n        /*\n        * \n        * code\n        * \n        * */\n    })( window );\n    ","source":"_posts/好好学学undefined！-2016-01-29.md","raw":"title: 好好学学undefined！\ndate: 2016-01-29 09:48:56\ntags:\n- jQuery\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# undefined类型\nundefined类型只有一个值，即特殊的undefined，我们称之为`字面值undefined`，undefined意为`未定义`。\n<!--more-->\n`字面值undefined`是全局Global对象（window）的一个特殊属性，其值是未定义的。但 typeof window.undefined 返回\"undefined\" 。\n\n我们可以通过下面的例子来验证undefined是否为全局Global对象（window）的属性:\n\n    alert('undefined' in window);//输出：true   \n    var anObj = {};   \n    alert('undefined' in anObj); //输出：false \n    从中可以看出，undefined是window对象的一个属性，但却不是anObj对象的一个属性。\n## `字面值undefined`的产生\n`字面值undefined`产生的原因有5种：\n\n    * 访问对象不存在的属性或方法\n    * 声明了变量但从未赋值\n    * 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n    * 方法没有返回值，默认返回undefined\n    * 访问越界的数组。\n    * void(expression) 形式的表达式。\n    \n    {% codeblock lang:JavaScript %}\n    var v1,obj = {};      \n      \n    console.log(v1); //`字面值undefined`    \n    console.log(obj.get); //`字面值undefined`\n    \n    typeof v1; // \"undefined\"    \n    typeof v2; // 对未声明的变量使用typeof 也会输出 \"undefined\"。     \n    typeof obj.get; // \"undefined\"\n    \n    var message1 = undefined;  //显示的设置为undefined\n    typeof message1 //\"undefined\"\n    \n    function test(){}; \n    console.log(test()); //`字面值undefined`\n    \n    var arr = []; \n    console.log(arr[8]) //`字面值undefined`\n    {% endcodeblock %}\n        \n<span style=\"color: red;\">当我们在程序中使用`字面值undefined`时，实际上使用的是window对象的undefined属性，同样，当我们定义一个变量但未赋予其初始值，例如：`var aValue;`这时，JavaScript在预编译时会将其初始值设置为对window.undefined属性的引用，于是，当我们将一个变量或值与undefined比较时，实际上是与window对象的undefined属性比较。这个比较过程中，JavaScript会搜索window对象名叫\"undefined\"的属性，然后再比较两个操作数的引用指针是否相同。</span>\n\n---\n您可以通过将变量与`字面值undefined`进行比较确定变量是否存在，您也可以通过将变量的类型与字符串“undefined”进行比较确定其类型是否为 undefined类型。\n以下示例演示了如何确定已声明的变量的 x：\n        \n    var x;\n    \n    // This method works.\n    if (x == undefined) { //这种方式只能对已经声明的变量使用，对未声明的变量使用会报错。\n        document.write(\"comparing x to undefined <br/>\");\n    }\n    \n    // This method doesn't work - you must check for the string \"undefined\".\n    if (typeof(x) == undefined) {//未执行，因为typeof 方法返回的是字符串。\n        document.write(\"comparing the type of x to undefined <br/>\");\n    }\n    // This method does work. \n    if (typeof(x) == \"undefined\") {\n        document.write(\"comparing the type of x to the string 'undefined'\");\n    }\n    \n    // Output: \n    // comparing x to undefined \n    // comparing the type of x to the string 'undefined'\n## 提高访问`字面值undefined`的性能：\n由于window对象的属性值是非常多的，在每一次与`字面值undefined`的比较中，搜索window对象的undefined属性都会花费时间。在需要频繁与undefined进行比较的函数中，这可能会是一个性能问题点。因此，在这种情况下，我们可以自行定义一个局部的undefined变量，来加快对undefined的比较速度。例如：\n\n    function anyFunc() {\n        var undefined; //自定义局部undefined变量\n        if (x == undefined){} //作用域上的引用比较\n        while (y != undefined){} //作用域上的引用比较\n    };\n其中，定义undefined局部变量时，其初始值会是对window.undefined属性值的引用。新定义的局部undefined变量存在与该函数的作用域上。\n在随后的比较操作中，JavaScript代码的书写方式没有任何的改变，但比较速度却很快。因为作用域上的变量数量会远远少于window对象的属性，搜索变量的速度会极大提高。\n这就是许多前端JS框架为什么常常要自己定义一个局部undefined变量的原因!!!\n比如jQuery 源码：\n\n    (function( window, undefined ) {\n        /*\n        * \n        * code\n        * \n        * */\n    })( window );\n    ","slug":"好好学学undefined！","published":1,"updated":"2016-02-02T05:56:57.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7ql000h543vau1b4at5"},{"title":"好好学学number!","date":"2016-01-29T01:55:43.000Z","comments":1,"_content":"# Number类型\n\nJavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相等的，而且1加上1.0得到的还是一个整数，不会像有些语言那样变成小数。\n<!--more-->\n```javascript\n1 === 1.0 // true\n1 + 1.0 // 2\n```\n也就是说，在JavaScript语言的底层，根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算。\n\n由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n```javascript    \n0.1 + 0.2 === 0.3  // false\n\n0.3 / 0.1          // 2.9999999999999996\n\n(0.3 - 0.2) === (0.2 - 0.1)    // false\n```\n{% asset_img number2.png %}\n\n解释：根据国际标准IEEE-754，64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分（共52位），第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数。\n\n```javascript\nMath.pow(2, 53)        // 9007199254740992\n\nMath.pow(2, 53) + 1    // 9007199254740992\n\nMath.pow(2, 53) + 2    // 9007199254740994\n\nMath.pow(2, 53) + 3    // 9007199254740996\n\nMath.pow(2, 53) + 4    // 9007199254740996\n```\n    \n从上面示例可以看到，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于等于2的53次方的数值，都无法保持精度。因此，JavaScript提供的有效数字的精度为53个二进制位（IEEE 754规定有效数字第一位默认总是为1，不保存在64位浮点数之中，这一位再加上后面的52位，就是总共53位），也就是说，绝对值小于2的53次方的整数，即-(2<sup>53</sup>-1)到2<sup>53</sup>-1，都可以精确表示。\n    \n那么超过2<sup>53</sup>部分的数字怎么处理呢？\n\n```javascript\nMath.pow(2, 53)    // 9007199254740992\n\n9007199254740992111    // 9007199254740992000    \n```\n上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的`111`）都会无法保存，变成0。\n\n另一方面，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。\n\n如果指数部分等于或超过最大正值1024，JavaScript会返回`Infinity`（关于Infinity的介绍参见下文），这称为“正向溢出”；如果等于或超过最小负值-1023（即非常接近0），JavaScript会直接把这个数转为0，这称为“负向溢出”。事实上，JavaScript对指数部分的两个极端值（`11111111111`(二进制)和`00000000000`(二进制)）做了定义，`11111111111`(二进制)表示`NaN`和`Infinity`，`00000000000`(二进制)表示0。\n    \n```javascript\n    var x = 0.5;\n    \n    for(var i = 0; i < 25; i++) {\n      x = x * x;\n    }\n    console.log(x);// 0\n```\n上面代码对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript就直接将其转为0。\n\n>* 精确地描述，Number类型拥有 18437736874454810627（即，2<sup>64</sup>-2<sup>53</sup>+3）个值，表示为 IEEE-754 格式 64 位双精度数值（IEEE 二进制浮点数算术中描述了它）。\n>* <span style=\"color: red;\">除了 IEEE 标准中的 9007199254740990（即，2<sup>53</sup>-2）个明显的“非数字”值；在 ECMAScript 中，它们被表示为一个单独的特殊值：NaN。</span>（请注意，NaN 值由程序表达式 NaN 产生，并假设执行程序不能调整定义的全局变量 NaN，在javascript中NaN是global全局对象的一个属性`window.NaN`） 在某些实现中，外部代码也许有能力探测出众多非数字值之间的不同，但此类行为依赖于具体实现；对于 ECMAScript 代码而言，NaN 值相互之间无法区别。\n>* 还有另外两个特殊值，称为正无穷和负无穷。为简洁起见，在说明目的时，用符号 +∞ 和 -∞ 分别代表它们。（请注意，两个无限数值由程序表达式 +Infinity（简作 Infinity） 和 -Infinity 产生，并假设执行程序不能调整定义的全局变量 Infinity，在javascript中global全局对象的一个Infinity属性`window.Infinity`）。\n>* 另外 18437736874454810624（即，2<sup>64</sup>-2<sup>53</sup>）个值被称为有限数值，其中的一半是正数，另一半是负数，对于每个正数而言，都有一个与之对应的、相同规模的负数。\n>* 请注意，还有一个正零和一个负零。\n>* [查看number类型数值的二进制](http://alvarto.github.io/VisualNumeric64/)\n\n数轴：\n\n{% asset_img number.png [200] [400] %}\n\n    \n> 对于这个如果有兴趣细扣就[点这里](http://www.cnblogs.com/kingwolfofsky/archive/2011/07/21/2112299.html)，[还有这里](https://www.w3.org/html/ig/zh/wiki/ES5/types#Number_.E7.B1.BB.E5.9E.8B)\n\n## 整数\n\n整数可以被表示成十进制（基数为10）、十六进制（基数为16）以及八进制（基数为8）。\n\n* 十进制：十进制整数字组成的数字序列，不带前导0（零）。\n* 八进制：八进制整数只能包括数字0-7，通过在八进制整数前面加前导`0`（零）或者或`0o`的数值来表示八进制整数。八进制整数只包含 0 到 7 的数字。<span style=\"color:red;\">具有前导`0`并包含数字“8”和/或“9”的数字将被解释为十进制数字</span>，具有前导`0o`并包含数字“8”和/或“9”的数字将会报错。\n* 十六进制：通过在整数前面加前导“0x”（零和 x|X）来表示十六进制（“hex”）整数。字母 A 到 F 以单个数字的形式表示以 10 为基数的 10 到 15。字母 A 到 F 用于以单个数字的形式表示以 10 为基数的 10 到 15。即，0xF 相当于 15，0x10 相当于 16。\n* 二进制：有前缀`0b`或`0B`的数值。\n\n在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值，还有严格模式下禁止使用八进制。\n    \n```javascript\n    //默认情况下，JavaScript内部会自动将八进制、十六进制、二进制转为十进制。    \n    0xff   // 255\n    -0xF1A7// -61863\n    0o377  // 255\n    015    // 13\n    019    // 19\n    0b11   // 3\n    \n    //如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。\n    0xzz // 报错\n    0o88 // 报错\n    0b22 // 报错\n```\n\n<span style=\"color:#555;\">IEBUG：从 Internet Explorer 9 标准模式、Internet Explorer 10 标准模式、Internet Explorer 11 标准模式和 Windows 应用商店应用 开始，parseInt 函数不将前缀为“0”的字符串视为八进制。但在不使用 parseInt 函数时，前缀为“0”的字符串仍可被解释为八进制。</span>\n\n## 浮点值\n\n* 一个十进制整数，它可以带符号（即前面的“+”或“ - ”号），\n* 一个小数点（“.”），\n* 一个小数部分（由一串十进制数表示），\n* 一个指数部分\n指数部分是以“e”或“E”开头后面跟着一个整数，可以有正负号（即前面写“+”或“-”）。一个浮点数字面值必须至少有一位数字，后接小数点或者“e”（大写“E”也可）组成。一些浮点数字面值的例子，如3.1415，-3.1E13，.1e12以及2E-12。\n简言之，其语法是：\n\n    [digits][.digits][(E|e)[(+|-)]digits]\n    //实例:\n    3.14\n    2345.789\n    .3333333333333333333 // 0 可以省略\n\n以下两种情况，JavaScript会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。\n\n* 小数点前的数字多于21位\n```javascript\n    console.log(1234567890123456789012)    // 1.2345678901234568e+21\n```\n* 小数点后的零多于5个\n```javascript\n    console.log(0.0000003) //3e-7\n```\n\n## NaN\n\nNaN(not a number)用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。由上面的表中可以看出，对于单精度浮点数，NaN 表示为指数为 emax + 1 = 128（指数域全为 1），且尾数域不等于零的浮点数。IEEE 标准没有要求具体的尾数域，所以 <span style=\"red;\">NaN 实际上不是一个，而是一族</span>，它是全局对象global对象的一个属性(`window.NaN`)。\n需要注意的是，NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。\n\n```javascript\n    console.log(typeof NaN) // 'number\n```\n### 特性：\n* NaN不等于任何值，包括它本身。`NaN === NaN // false`\n* 由于数组的indexOf方法，内部使用的是严格相等运算符，所以该方法对NaN不成立。`NaN].indexOf(NaN) // -1`\n* NaN在布尔运算时被当作false。`Boolean(NaN) // false`\n* NaN与任何数（包括它自己）的运算，得到的都是NaN。\n\n```javascript\n    NaN + 32 // NaN\n    NaN - 32 // NaN\n    NaN * 32 // NaN\n    NaN / 32 // NaN\n```\n    \n### 判断NaN的方法 isNaN\n\n```javascript\n    isNaN(NaN) // true\n    isNaN(123) // false\n```\n    \n但是，`isNaN`只对数值有效，<span style=\"color:red;\">如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成`NaN`，所以最后返回`true`</span>，这一点要特别引起注意。也就是说，`isNaN`为`true`的值，有可能不是`NaN`，而是一个字符串。出于同样的原因，对于对象和数组，`isNaN`也返回`true`。\n\n```javascript\n    isNaN('Hello') // true\n    // 等同于\n    isNaN(Number('Hello')) // true\n\n    isNaN({}) // true\n    // 等同于\n    isNaN(Number({})) // true\n\n    isNaN(['xzy']) // true\n    // 等同于\n    isNaN(Number(['xzy'])) // true\n```\n\n但是，对于空数组和只有一个数值成员的数组，`isNaN`返回`false`。\n\n```javascript\n    isNaN([]) // false\n    isNaN([123]) // false\n    isNaN(['123']) // false\n```\n \n上面的代码之所以返回`false`，原因是这些数组能被`Number`函数转成数值，请参见《数据类型转换》一节。\n\n因此，使用`isNaN`之前，最好判断一下数据类型。\n\n```javascript\n    function myIsNaN(value) {\n    return typeof value === 'number' && isNaN(value);\n    }\n    判断NaN更可靠的方法是，利用`NaN`是JavaScript之中唯一不等于自身的值这个特点，进行判断。\n\n    function myIsNaN(value) {\n    return value !== value;\n    }\n```\n    \n## +0 和 -0\n\n先看一道题： 假如 A === B 并且 1/A < 1/B; 请问 A 等于 几？\n\n### 产生原因\n数字需要被编码才能进行数字化存储.举个例子,假如我们要将一个整数编码为4位的二进制数,使用原码(sign-and-magnitude)方法,则最高位是符号位(0代表正,1代表负),剩下的三位表示大小(具体的值).因此,−2和+2会编码成为下面这样:\n\n    1010 // +2\n    0010 // -2\n    这就意味着将会有两个零:\n    1000 // -0\n    0000 // +0\n在JavaScript中,所有的数字都是浮点数,都是根据IEEE-754标准中的浮点数算法以双精度格式被编码。这个标准中正负号的处理方式类似于原码(sign-and-magnitude)方法中整数的编码方式,所以也有正负零。\n\n### 参与运算\n```javascript\n+0 === -0 //true 虽然有正0和负0但是他们两个是相等\n-0 < +0   //false  \n+0 < -0   //false\n\n-0 + -0  // -0\n-0 + +0  // +0\n+0 X -5  // -0\n-0 X -5  // +0\n1 / +0  // Infinity\n1 / -0  // -Infinity\n+0 / -0  // NaN\n```\n    \n### 参与Math对象的方法\n\n* Math.pow(x,y)方法可返回从  之间的角度。\n    \n```javascript\nMath.pow(+0, -1) // Infinity\nMath.pow(-0, -1) // -Infinity\n```\n    \n* Math.atan2(x,y)方法可返回从 x<sup>y</sup> 的值。\n        \n```javascript\nx = 0 , y <= -0     // π(3.141592653589793)\nMath.atan2(+0, -0)  // π(3.141592653589793)\n\nx = 0 , y >= 0      // 0\nMath.atan2(+0, +0)  // 0\n\nx = -0 , y >= +0    // -0\nMath.atan2(-0, +0)  // -0\n\nx = -0 , y <= -0    // -π(-3.141592653589793)\nMath.atan2(-0, -0)  // -π(-3.141592653589793)\n```\n    \n* Math.round()是另外一个参数不为零却产生-0结果的操作:\n```javascript\nMath.round(-0.1) // -0\n```\n\n### 区分这两个零\n\n方法1: 判断一个零是正还是负的标准解法是用它除1，然后看计算的结果是-Infinity还是+Infinity\n        \n```javascript\nfunction isNegativeZero(x) {\n    return x === 0 && (1/x < 0);\n}\n```\n\n方法2: 除了上面讲的几种解法.还有一个解法来自Allen Wirfs-Brock(译者注:TC39编辑,ES标准就是他写出来的。):\n        \n```javascript\nfunction isNegativeZero(x) {\n    if (x !== 0) return false;\n    var obj = {};\n    Object.defineProperty(obj, 'z', { value: -0, configurable: false });\n    try {\n        // 如果x的值和z属性的当前值不相等的话,就会抛出异常.\n        Object.defineProperty(obj, 'z', { value: x });\n    } catch (e) {\n        return false\n    };\n    return true;\n}\n```\n        \n解释: 通常情况下,你不能重新定义一个不可配置的对象属性，否则会抛出异常:`TypeError: Cannot redefine property: z`可是，如果你重新定义属性时指定的属性特性的值与该特性当前的值相等，则JavaScript会忽略掉这个重定义，不会抛出异常。其中在判断两个值是否相等时使用的运算不是===，是一个称之为SameValue的内部算法，该算法可以区分开 -0 和 +0 。可以从Wirfs-Brock的原文中了解更多细。(冻结一个对象会让该对象的所有属性变的不可配置)。\n\n    SameValue 算法\n    内部严格比较操作 SameValue(x,y)，x 和 y 为 ECMAScript 语言中的值，需要产出 true 或 false。Note.png Note.png V8.png\n\n    比较过程如下：\n\n    如果 Type(x) 与 Type(y) 的结果不一致，返回 false，否则\n    如果 Type(x) 结果为 Undefined，返回 true\n    如果 Type(x) 结果为 Null，返回 true\n    如果 Type(x) 结果为 Number，则\n    如果 x 为 NaN，且 y 也为 NaN，返回 true\n    如果 x 为 +0，y 为 -0，返回 false\n    如果 x 为 -0，y 为 +0，返回 false\n    如果 x 与 y 为同一个数字，返回 true\n    返回 false\n    如果 Type(x) 结果为 String，如果 x 与 y 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 true，否则，返回 false\n    如果 Type(x) 结果为 Boolean，如果 x 与 y 都为 true 或 false，则返回 true，否则，返回 false\n    如果 x 和 y 引用到同一个 Object 对象，返回 true，否则，返回 false\n\n\n> 在执行一些特殊方法的时候，比如alert或innerHTML等方法，它将由脚本解析器自动调用toString()方法。\n\n看完上面这些，那么这节开头的题目的结果自然而然就知道喽。\n\n## Infinity\nInfinity 表示“无穷”，挂在global对象下的Infinity属性上(window.Infinity)。除了0除以0得到NaN，其他任意数除以0，得到Infinity。获得方式\n\n```javascript\nNumber.NEGATIVE_INFINITY // +infinity\nNumber.POSITIVE_INFINITY // -infinity\n\nwindow.Infinity === Number.POSITIVE_INFINITY // ture\n```\n\n```javascript\n1 / -0 // -Infinity\n1 / +0 // Infinity\n```\n    \n### 正负之分\n和+0\\-0 不同，`Infinity` 不等于 `-Infinity`。\n\n```javascript\nInfinity === -Infinity // false\n```\n### 产生原因\n\n```javascript\nMath.pow(+0, -1) // Infinity\nMath.pow(-0, -1) // -Infinity\n\n//运算结果超出JavaScript可接受范围，也会返回无穷。\nMath.pow(2, 2048) // Infinity\n-Math.pow(2, 2048) // -Infinity\n```\n\n### 参与运算\n\nInfinity的四则运算，符合无穷的数学计算规则。\n\n```javascript\n5 * Infinity // Infinity\n5 - Infinity // -Infinity\nInfinity / 5 // Infinity\n5 / Infinity // 0\n```\n\n```javascript\nInfinity - Infinity // NaN\nInfinity / Infinity // NaN\n\nInfinity + Infinity // Infinity\nInfinity * Infinity // Infinity\n```\n    \nnfinity可以用于布尔运算。可以记住，Infinity是JavaScript中最大的值（NaN除外），-Infinity是最小的值（NaN除外）。\n\n```javascript    \n5 > -Infinity // true\n5 > Infinity // false\n```\n\n由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript都不报错，所以单纯的数学运算几乎没有可能抛出错误。\n\n### isFinite函数\nisFinite函数返回一个布尔值，检查某个值是否为正常值，而不是Infinity。\n\n```javascript\nisFinite(Infinity) // false\nisFinite(-1) // true\nisFinite(true) // true\nisFinite(NaN) // false //如果对NaN使用isFinite函数，也返回false，表示NaN不是一个正常值\n```\n\n# 数值转换\n\n## Number()\n\n使用Number函数，可以将任意类型的值(<span style=\"color:red;\">parseInt和parseFloat只能转换字符串和数值类型</span>)转化成数字。\n\n* **简单类型转换规则**\n\n    - 数值：转换为十进制(因为默认调用toString()，会以十进制输出)。\n        ```javascript\n        Number(10);     // 10 \n        Number(010);    // 8\n        Number(090);    // 90 因为八进制中没有9，所以按照十进制处理 \n        Number(0x16);   // 22 \n        \n        Number(0o10);   //  在chrome和firefox为8，IE报错 `缺少 “)”` \n        Number(0b1000); //  在chrome和firefox为8，IE报错 `缺少 “)”` \n        ```\n\n    - 字符串：先去掉字符串前后的空格，如果可以被解析为数值，则转换为相应的数值，否则得到NaN。**空字符串`\"\"`转为0**。\n        - 如果字符串是`Number(\"0o17\")`和`Number(\"0b10000\")`（包括前面带正号或负号的情况）在chrome和firefox会按照八进制转换为十进制 16，但是IE不会生产`NaN`，十六进制没问题chrome和firefox、IE没问题。\n        - 如果字符串中包含有效的浮点格式，如\"1.1\"，则将其转换为对应的浮点数值（同样，也会忽略前导零）。\n        \n    - 布尔值：`true`转成 1，`false` 转成 0。\n\n    - `undefined`：转成`NaN`。\n\n    - `null`：转成0。\n\n    ```javascript\n    Number(\"324\") // 324\n    Number(\" -9.8 \") // -9.8\n    \n    Number(\"010\") // 10 和parseInt(\"010\")为不同\n    Number(\"0o17\")//  在chrome和firefox为16。IE为NaN。 \n    Number(\"0b10000\") // 在chrome和firefox为16。IE为NaN。 \n    Number(\"0x10\") // 在chrome和firefox为16。IE也为16。\n    \n    Number(\"324abc\") // NaN\n\n    Number(\"\") // 0\n\n    Number(false) // 0\n\n    Number(undefined) // NaN\n\n    Number(null) // 0\n    ```\n* **对象的转换规则**\n    对象的转换规则比较复杂。\n    1. 先调用对象自身的`valueOf`方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用`Number`方法，不再进行后续步骤。\n    2. 如果`valueOf`方法返回复合类型的值，再调用对象自身的`toString`方法，如果`toString`方法返回原始类型的值，则对该值使用`Number`方法，不再进行后续步骤。\n    3. 如果`toString`方法返回的是复合类型的值，则报错。\n    \n    ```javascript\n    Number({a:1,valueOf:function(){return \"5\"}}); //5  先调用对象自身的`valueOf`方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用`Number`方法，不再进行后续步骤。\n    Number({a:1,valueOf:function(){return {b:5}},toString:function(){return 4}}); //4  如果`valueOf`方法返回复合类型的值，再调用对象自身的`toString`方法，如果`toString`方法返回原始类型的值，则对该值使用`Number`方法，不再进行后续步骤。\n    Number({a:1,valueOf:function(){return {b:5}},toString:function(){return {}}}); //TypeError: Cannot convert object to primitive value 如果`toString`方法返回的是复合类型的值，则报错。\n    ```\n## parseInt()\n* 基本用法    \n    `parseInt()`方法可以将字符串转化为整数。如果字符串头部有空格，空格会被自动去除。\n    ```javascript\n        parseInt('8a') // 8\n        parseInt(\" -12 ba\") //-12\n        \n        //十六进制\n        parseInt('0xf00') // 3840 开头两个字符是`0x`或`0X`，`parseInt`将其视为十六进制数\n        //八进制\n        parseInt('056') // 56\n        parseInt('0o56') // 0\n        parseInt('0O56') // 0\n        //二进制\n        parseInt(\"0B10\") // 0\n    ```\n    上面代码中，`parseInt`的参数都是字符串，结果只返回字符串头部可以转为数字的部分。最后一行的`0xf00`之所以可以转为数字，因为如果开头两个字符是`0x`或`0X`，`parseInt`将其视为十六进制数，但是八进制和二进制确默认视为普通字符串。\n    如果字符串的第一个`非空格字符`不能转化为数字（数字的正负号除外），返回`NaN`。\n    \n    ```javascript\n    parseInt('abc') // NaN\n    parseInt('.3') // NaN\n    parseInt('') // NaN 不同于Number()\n    parseInt(null) // NaN 不同于Number()\n    parseInt('+') // NaN\n    ```\n* 进制转换\n`parseInt()`方法还可以接受第二个参数（2到36之间，超出区间(`包括负数但0除外`)返回`NaN`），表示被解析的值的进制，返回该值对应的十进制数。\n如果第二个参数不是数值，会被自动转为（调用`Number()`）一个整数，这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回`NaN`，如果转换的结果为`0，NaN`，都会直接忽略返回原值。\n如果第二个参数是`0`、`undefined`和`null`等等一些不能转为正常整数的值，则直接忽略。\n\n    ```javascript\n        parseInt(1000, 2) // 8\n        parseInt(1000, 6) // 216\n        parseInt(1000, 8) // 512\n        //特殊情况\n        parseInt(1000, \"8\") // 512 把\"8\"自动转为8\n        parseInt(1000, \" +8 \") // 512 会自动去掉前置和后置空格\n        parseInt(1000, \" -8 \") // NaN 负数超出范围\n        parseInt(1000, 1) // NaN 超出范围\n        parseInt(1000, 37) // NaN 超出范围\n        parseInt(1000, \"8aa\") // 1000 因为Number(\"8aa\")等于NaN\n        parseInt(1000, 0) // 1000  直接忽略返回原值\n        parseInt(1000, NaN) // 1000\n        parseInt(1000, null) // 1000 因为Number(NaN)等于0\n        parseInt(1000, undefined) // 1000 因为Number(undefined)等于NaN\n        parseInt(\"1000\", {\n            a:1,\n            valueOf:function(){\n                return 5;\n            }\n        }) //125  因为Number({a:1,valueOf:function(){return 5;}}) 返回5 所以\n    ```\n  \n* 特别注意\n需要注意的是，进制转换的时候，参数是字符串或数值，`parseInt`的行为不一致。\n1. 如果第一个参数是数值，会将这个数值先转为十进制，然后再应用第二个参数。\n\n    ```javascript\n    parseInt(0x11, 36) // 43\n    parseInt(17, 36) // 43\n    ```\n    上面代码中，`0x11`会被先转为十进制的17，然后再用36进制解读这个17，最后返回结果43。\n\n2. 如果第一个参数是字符串，则会直接用指定进制解读这个字符串。\n    \n    ```javascript\n    parseInt('0x11', 36) // 42805\n    parseInt('x', 36) // 33\n    ```\n\n    上面代码中，字符串`0x11`会被直接当作一个36进制的数。由于字符`x`在36进制中代表33，导致`0x11`被解读为42805。\n\n    ```javascript\n    parseInt(010, 10) // 8\n    parseInt('010', 10) // 10\n\n    parseInt(010, 2) // NaN 因为`010数值`转换为十进制是8，而8在二进制是不存在的所以返回`NaN`\n    parseInt('010', 2) // 2\n\n    parseInt(010, 8) // NaN 因为`010数值`转换为十进制是8，而8在八进制是不存在的所以返回`NaN`\n    parseInt('010', 8) // 8\n\n    parseInt(020, 10) // 16\n    parseInt('020', 10) // 20\n\n    parseInt(020, 8) // 14 因为`020数值`转换为十进制是16，再转换为8进制刚好14\n    parseInt('020', 8) // 16 因为`020字符串`转换为十进制是20，再转换为8进制刚好16\n    ```\n\n    上面代码中，`010`会被先转为十进制8，然后再应用第二个参数，由于二进制和八进制中没有8这个数字，所以`parseInt(010, 2)`和`parseInt(010, 8)`返回`NaN`。同理，数值`020`会被先转为十进制的16，然后再应用第二个参数。\n    > `parseInt`的很多复杂行为，都是由八进制的前缀0引发的，这增加编程处理的复杂性。因此，ECMAScript 5不再允许parseInt将带有前缀0的数字，视为八进制数，而是要求忽略这个`0`。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。\n\n3. 如果第一个参数是以`0x`或`0X`开头的字符串，而第二个参数省略或为0，则`parseInt`自动将第二个参数设为16。\n    ```javascript\n        parseInt('0xFF') // 255\n        parseInt('0xFF', 0) // 255\n        parseInt('0xFF', 16) // 255\n        \n        parseInt('0xFF', 10) // 0\n        parseInt('0xFF', 17) // 0\n    ```\n    上面代码中，第二个参数除了0、16和省略，其他情况都会依次解析第一个参数，直到遇到第一个不可解析字符。\n\n4. 如果参数是对象，数据或者{}\n  和Number()过程相反，先调用 toString()，如果返回的不是 简单数据类型则再调用valueOf方法。\n  `parseInt({a:1,valueOf:function(){return 5},toString:function(){return 4}});// 4`\n  `parseInt([2,3]);//2因为数组的valueOf返回还是数组，继续调用toString方法，返回\"2,3\",再parseInt返回 2`\n\n5. 科学计数法产生的扯淡问题\n    对于那些会自动转为科学计数法的数字，`parseInt`会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。\n    \n    ```javascript\n    parseInt(1000000000000000000000.5, 10) // 1\n    // 等同于\n    parseInt('1e+21', 10) // 1\n\n    parseInt(0.0000008, 10) // 8\n    // 等同于\n    parseInt('8e-7', 10) // 8\n    ```\n  \n## parseFloat()\n* 基本用法\n    parseFloat`方法用于将一个字符串转为浮点数。    \n    ```javascript\n    parseFloat(\"3.14\") // 3.14\n    ```\n\n1. 如果字符串符合科学计数法，则会进行相应的转换。\n    \n    ```javascript\n    parseFloat('314e-2') // 3.14\n    parseFloat('0.0314E+2') // 3.14\n    ```\n2. 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。\n    ```javascript\n    parseFloat('3.14more non-digit characters') // 3.14\n    ```\n    `parseFloat`方法会自动过滤字符串前导的空格。\n    ```javascript\n    parseFloat('\\t\\v\\r12.34\\n ') // 12.34\n    ```\n\n3. 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回`NaN`。\n    ```javascript\n    parseFloat([]) // NaN\n    parseFloat('FF2') // NaN\n\n    parseFloat(true)  // NaN 不同于`Number`函数\n    Number(true) // 1\n\n    parseFloat(null) // NaN 不同于`Number`函数\n    Number(null) // 0\n\n    parseFloat('') // NaN 不同于`Number`函数\n    Number('') // 0\n\n    parseFloat('123.45#') // 123.45  不同于`Number`函数\n    Number('123.45#') // NaN\n    ```\n 4. 如果参数是对象，数据或者{}\n  和Number()过程相反，先调用 toString()，如果返回的不是 简单数据类型则再调用valueOf方法。\n  `parseFloat({a:1,valueOf:function(){return 5},toString:function(){return 4}});// 4`\n  `parseInt([2,3]);//2因为数组的valueOf返回还是数组，继续调用toString方法，返回\"2,3\",再parseInt返回 2`\n  \n** 特别注意：`parseInt()`和`parseFloat()`会先调用值的`toString()`方法，`Number()`是先调用`valueOf`，返回结果有问题再调用`toString`**\n```javascript\nparseInt({\na: 1,\ntoString: function(){\n            return \"11\"\n            }\n});\n\nparseFloat({\na: 1,\ntoString: function(){\n            return \"11\"\n            }\n});\n```\n上面这两种情况也会正确的返回`11`，看到这儿你会说“你不是说parseInt只能转换字符串”吗？其实真正的原因是，所有的转换第一步都是调用`toString()`方法。\n\n```javascript\nNumber.prototype.toString = function(){\n    console.log(\"我被调用了\")\n    return 123123;\n}\nNumber.prototype.valueOf = function(){\n    console.log(\"我被调用了-valueOf\")\n    return 123123;\n}\n\nvar a  = new Number(12);\n\n\nparseInt(a) // 我被调用了 123123\nNumber(a) // 我被调用了-valueOf 123123\n```\n上面这段code 足以证明**特别注意**。\n详见：[Ex igne vita](http://es5.github.io/#x15.1.2.2)\n\n** 引用：**\n\n> [紫云飞](http://www.cnblogs.com/ziyunfei/archive/2012/12/10/2777099.html)\n> [阮一峰](http://javascript.ruanyifeng.com/)","source":"_posts/好好学学number-2016-01-29.md","raw":"title: '好好学学number!'\ndate: 2016-01-29 09:55:43\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# Number类型\n\nJavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相等的，而且1加上1.0得到的还是一个整数，不会像有些语言那样变成小数。\n<!--more-->\n```javascript\n1 === 1.0 // true\n1 + 1.0 // 2\n```\n也就是说，在JavaScript语言的底层，根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算。\n\n由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n```javascript    \n0.1 + 0.2 === 0.3  // false\n\n0.3 / 0.1          // 2.9999999999999996\n\n(0.3 - 0.2) === (0.2 - 0.1)    // false\n```\n{% asset_img number2.png %}\n\n解释：根据国际标准IEEE-754，64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分（共52位），第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数。\n\n```javascript\nMath.pow(2, 53)        // 9007199254740992\n\nMath.pow(2, 53) + 1    // 9007199254740992\n\nMath.pow(2, 53) + 2    // 9007199254740994\n\nMath.pow(2, 53) + 3    // 9007199254740996\n\nMath.pow(2, 53) + 4    // 9007199254740996\n```\n    \n从上面示例可以看到，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于等于2的53次方的数值，都无法保持精度。因此，JavaScript提供的有效数字的精度为53个二进制位（IEEE 754规定有效数字第一位默认总是为1，不保存在64位浮点数之中，这一位再加上后面的52位，就是总共53位），也就是说，绝对值小于2的53次方的整数，即-(2<sup>53</sup>-1)到2<sup>53</sup>-1，都可以精确表示。\n    \n那么超过2<sup>53</sup>部分的数字怎么处理呢？\n\n```javascript\nMath.pow(2, 53)    // 9007199254740992\n\n9007199254740992111    // 9007199254740992000    \n```\n上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的`111`）都会无法保存，变成0。\n\n另一方面，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。\n\n如果指数部分等于或超过最大正值1024，JavaScript会返回`Infinity`（关于Infinity的介绍参见下文），这称为“正向溢出”；如果等于或超过最小负值-1023（即非常接近0），JavaScript会直接把这个数转为0，这称为“负向溢出”。事实上，JavaScript对指数部分的两个极端值（`11111111111`(二进制)和`00000000000`(二进制)）做了定义，`11111111111`(二进制)表示`NaN`和`Infinity`，`00000000000`(二进制)表示0。\n    \n```javascript\n    var x = 0.5;\n    \n    for(var i = 0; i < 25; i++) {\n      x = x * x;\n    }\n    console.log(x);// 0\n```\n上面代码对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript就直接将其转为0。\n\n>* 精确地描述，Number类型拥有 18437736874454810627（即，2<sup>64</sup>-2<sup>53</sup>+3）个值，表示为 IEEE-754 格式 64 位双精度数值（IEEE 二进制浮点数算术中描述了它）。\n>* <span style=\"color: red;\">除了 IEEE 标准中的 9007199254740990（即，2<sup>53</sup>-2）个明显的“非数字”值；在 ECMAScript 中，它们被表示为一个单独的特殊值：NaN。</span>（请注意，NaN 值由程序表达式 NaN 产生，并假设执行程序不能调整定义的全局变量 NaN，在javascript中NaN是global全局对象的一个属性`window.NaN`） 在某些实现中，外部代码也许有能力探测出众多非数字值之间的不同，但此类行为依赖于具体实现；对于 ECMAScript 代码而言，NaN 值相互之间无法区别。\n>* 还有另外两个特殊值，称为正无穷和负无穷。为简洁起见，在说明目的时，用符号 +∞ 和 -∞ 分别代表它们。（请注意，两个无限数值由程序表达式 +Infinity（简作 Infinity） 和 -Infinity 产生，并假设执行程序不能调整定义的全局变量 Infinity，在javascript中global全局对象的一个Infinity属性`window.Infinity`）。\n>* 另外 18437736874454810624（即，2<sup>64</sup>-2<sup>53</sup>）个值被称为有限数值，其中的一半是正数，另一半是负数，对于每个正数而言，都有一个与之对应的、相同规模的负数。\n>* 请注意，还有一个正零和一个负零。\n>* [查看number类型数值的二进制](http://alvarto.github.io/VisualNumeric64/)\n\n数轴：\n\n{% asset_img number.png [200] [400] %}\n\n    \n> 对于这个如果有兴趣细扣就[点这里](http://www.cnblogs.com/kingwolfofsky/archive/2011/07/21/2112299.html)，[还有这里](https://www.w3.org/html/ig/zh/wiki/ES5/types#Number_.E7.B1.BB.E5.9E.8B)\n\n## 整数\n\n整数可以被表示成十进制（基数为10）、十六进制（基数为16）以及八进制（基数为8）。\n\n* 十进制：十进制整数字组成的数字序列，不带前导0（零）。\n* 八进制：八进制整数只能包括数字0-7，通过在八进制整数前面加前导`0`（零）或者或`0o`的数值来表示八进制整数。八进制整数只包含 0 到 7 的数字。<span style=\"color:red;\">具有前导`0`并包含数字“8”和/或“9”的数字将被解释为十进制数字</span>，具有前导`0o`并包含数字“8”和/或“9”的数字将会报错。\n* 十六进制：通过在整数前面加前导“0x”（零和 x|X）来表示十六进制（“hex”）整数。字母 A 到 F 以单个数字的形式表示以 10 为基数的 10 到 15。字母 A 到 F 用于以单个数字的形式表示以 10 为基数的 10 到 15。即，0xF 相当于 15，0x10 相当于 16。\n* 二进制：有前缀`0b`或`0B`的数值。\n\n在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值，还有严格模式下禁止使用八进制。\n    \n```javascript\n    //默认情况下，JavaScript内部会自动将八进制、十六进制、二进制转为十进制。    \n    0xff   // 255\n    -0xF1A7// -61863\n    0o377  // 255\n    015    // 13\n    019    // 19\n    0b11   // 3\n    \n    //如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。\n    0xzz // 报错\n    0o88 // 报错\n    0b22 // 报错\n```\n\n<span style=\"color:#555;\">IEBUG：从 Internet Explorer 9 标准模式、Internet Explorer 10 标准模式、Internet Explorer 11 标准模式和 Windows 应用商店应用 开始，parseInt 函数不将前缀为“0”的字符串视为八进制。但在不使用 parseInt 函数时，前缀为“0”的字符串仍可被解释为八进制。</span>\n\n## 浮点值\n\n* 一个十进制整数，它可以带符号（即前面的“+”或“ - ”号），\n* 一个小数点（“.”），\n* 一个小数部分（由一串十进制数表示），\n* 一个指数部分\n指数部分是以“e”或“E”开头后面跟着一个整数，可以有正负号（即前面写“+”或“-”）。一个浮点数字面值必须至少有一位数字，后接小数点或者“e”（大写“E”也可）组成。一些浮点数字面值的例子，如3.1415，-3.1E13，.1e12以及2E-12。\n简言之，其语法是：\n\n    [digits][.digits][(E|e)[(+|-)]digits]\n    //实例:\n    3.14\n    2345.789\n    .3333333333333333333 // 0 可以省略\n\n以下两种情况，JavaScript会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。\n\n* 小数点前的数字多于21位\n```javascript\n    console.log(1234567890123456789012)    // 1.2345678901234568e+21\n```\n* 小数点后的零多于5个\n```javascript\n    console.log(0.0000003) //3e-7\n```\n\n## NaN\n\nNaN(not a number)用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。由上面的表中可以看出，对于单精度浮点数，NaN 表示为指数为 emax + 1 = 128（指数域全为 1），且尾数域不等于零的浮点数。IEEE 标准没有要求具体的尾数域，所以 <span style=\"red;\">NaN 实际上不是一个，而是一族</span>，它是全局对象global对象的一个属性(`window.NaN`)。\n需要注意的是，NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。\n\n```javascript\n    console.log(typeof NaN) // 'number\n```\n### 特性：\n* NaN不等于任何值，包括它本身。`NaN === NaN // false`\n* 由于数组的indexOf方法，内部使用的是严格相等运算符，所以该方法对NaN不成立。`NaN].indexOf(NaN) // -1`\n* NaN在布尔运算时被当作false。`Boolean(NaN) // false`\n* NaN与任何数（包括它自己）的运算，得到的都是NaN。\n\n```javascript\n    NaN + 32 // NaN\n    NaN - 32 // NaN\n    NaN * 32 // NaN\n    NaN / 32 // NaN\n```\n    \n### 判断NaN的方法 isNaN\n\n```javascript\n    isNaN(NaN) // true\n    isNaN(123) // false\n```\n    \n但是，`isNaN`只对数值有效，<span style=\"color:red;\">如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成`NaN`，所以最后返回`true`</span>，这一点要特别引起注意。也就是说，`isNaN`为`true`的值，有可能不是`NaN`，而是一个字符串。出于同样的原因，对于对象和数组，`isNaN`也返回`true`。\n\n```javascript\n    isNaN('Hello') // true\n    // 等同于\n    isNaN(Number('Hello')) // true\n\n    isNaN({}) // true\n    // 等同于\n    isNaN(Number({})) // true\n\n    isNaN(['xzy']) // true\n    // 等同于\n    isNaN(Number(['xzy'])) // true\n```\n\n但是，对于空数组和只有一个数值成员的数组，`isNaN`返回`false`。\n\n```javascript\n    isNaN([]) // false\n    isNaN([123]) // false\n    isNaN(['123']) // false\n```\n \n上面的代码之所以返回`false`，原因是这些数组能被`Number`函数转成数值，请参见《数据类型转换》一节。\n\n因此，使用`isNaN`之前，最好判断一下数据类型。\n\n```javascript\n    function myIsNaN(value) {\n    return typeof value === 'number' && isNaN(value);\n    }\n    判断NaN更可靠的方法是，利用`NaN`是JavaScript之中唯一不等于自身的值这个特点，进行判断。\n\n    function myIsNaN(value) {\n    return value !== value;\n    }\n```\n    \n## +0 和 -0\n\n先看一道题： 假如 A === B 并且 1/A < 1/B; 请问 A 等于 几？\n\n### 产生原因\n数字需要被编码才能进行数字化存储.举个例子,假如我们要将一个整数编码为4位的二进制数,使用原码(sign-and-magnitude)方法,则最高位是符号位(0代表正,1代表负),剩下的三位表示大小(具体的值).因此,−2和+2会编码成为下面这样:\n\n    1010 // +2\n    0010 // -2\n    这就意味着将会有两个零:\n    1000 // -0\n    0000 // +0\n在JavaScript中,所有的数字都是浮点数,都是根据IEEE-754标准中的浮点数算法以双精度格式被编码。这个标准中正负号的处理方式类似于原码(sign-and-magnitude)方法中整数的编码方式,所以也有正负零。\n\n### 参与运算\n```javascript\n+0 === -0 //true 虽然有正0和负0但是他们两个是相等\n-0 < +0   //false  \n+0 < -0   //false\n\n-0 + -0  // -0\n-0 + +0  // +0\n+0 X -5  // -0\n-0 X -5  // +0\n1 / +0  // Infinity\n1 / -0  // -Infinity\n+0 / -0  // NaN\n```\n    \n### 参与Math对象的方法\n\n* Math.pow(x,y)方法可返回从  之间的角度。\n    \n```javascript\nMath.pow(+0, -1) // Infinity\nMath.pow(-0, -1) // -Infinity\n```\n    \n* Math.atan2(x,y)方法可返回从 x<sup>y</sup> 的值。\n        \n```javascript\nx = 0 , y <= -0     // π(3.141592653589793)\nMath.atan2(+0, -0)  // π(3.141592653589793)\n\nx = 0 , y >= 0      // 0\nMath.atan2(+0, +0)  // 0\n\nx = -0 , y >= +0    // -0\nMath.atan2(-0, +0)  // -0\n\nx = -0 , y <= -0    // -π(-3.141592653589793)\nMath.atan2(-0, -0)  // -π(-3.141592653589793)\n```\n    \n* Math.round()是另外一个参数不为零却产生-0结果的操作:\n```javascript\nMath.round(-0.1) // -0\n```\n\n### 区分这两个零\n\n方法1: 判断一个零是正还是负的标准解法是用它除1，然后看计算的结果是-Infinity还是+Infinity\n        \n```javascript\nfunction isNegativeZero(x) {\n    return x === 0 && (1/x < 0);\n}\n```\n\n方法2: 除了上面讲的几种解法.还有一个解法来自Allen Wirfs-Brock(译者注:TC39编辑,ES标准就是他写出来的。):\n        \n```javascript\nfunction isNegativeZero(x) {\n    if (x !== 0) return false;\n    var obj = {};\n    Object.defineProperty(obj, 'z', { value: -0, configurable: false });\n    try {\n        // 如果x的值和z属性的当前值不相等的话,就会抛出异常.\n        Object.defineProperty(obj, 'z', { value: x });\n    } catch (e) {\n        return false\n    };\n    return true;\n}\n```\n        \n解释: 通常情况下,你不能重新定义一个不可配置的对象属性，否则会抛出异常:`TypeError: Cannot redefine property: z`可是，如果你重新定义属性时指定的属性特性的值与该特性当前的值相等，则JavaScript会忽略掉这个重定义，不会抛出异常。其中在判断两个值是否相等时使用的运算不是===，是一个称之为SameValue的内部算法，该算法可以区分开 -0 和 +0 。可以从Wirfs-Brock的原文中了解更多细。(冻结一个对象会让该对象的所有属性变的不可配置)。\n\n    SameValue 算法\n    内部严格比较操作 SameValue(x,y)，x 和 y 为 ECMAScript 语言中的值，需要产出 true 或 false。Note.png Note.png V8.png\n\n    比较过程如下：\n\n    如果 Type(x) 与 Type(y) 的结果不一致，返回 false，否则\n    如果 Type(x) 结果为 Undefined，返回 true\n    如果 Type(x) 结果为 Null，返回 true\n    如果 Type(x) 结果为 Number，则\n    如果 x 为 NaN，且 y 也为 NaN，返回 true\n    如果 x 为 +0，y 为 -0，返回 false\n    如果 x 为 -0，y 为 +0，返回 false\n    如果 x 与 y 为同一个数字，返回 true\n    返回 false\n    如果 Type(x) 结果为 String，如果 x 与 y 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 true，否则，返回 false\n    如果 Type(x) 结果为 Boolean，如果 x 与 y 都为 true 或 false，则返回 true，否则，返回 false\n    如果 x 和 y 引用到同一个 Object 对象，返回 true，否则，返回 false\n\n\n> 在执行一些特殊方法的时候，比如alert或innerHTML等方法，它将由脚本解析器自动调用toString()方法。\n\n看完上面这些，那么这节开头的题目的结果自然而然就知道喽。\n\n## Infinity\nInfinity 表示“无穷”，挂在global对象下的Infinity属性上(window.Infinity)。除了0除以0得到NaN，其他任意数除以0，得到Infinity。获得方式\n\n```javascript\nNumber.NEGATIVE_INFINITY // +infinity\nNumber.POSITIVE_INFINITY // -infinity\n\nwindow.Infinity === Number.POSITIVE_INFINITY // ture\n```\n\n```javascript\n1 / -0 // -Infinity\n1 / +0 // Infinity\n```\n    \n### 正负之分\n和+0\\-0 不同，`Infinity` 不等于 `-Infinity`。\n\n```javascript\nInfinity === -Infinity // false\n```\n### 产生原因\n\n```javascript\nMath.pow(+0, -1) // Infinity\nMath.pow(-0, -1) // -Infinity\n\n//运算结果超出JavaScript可接受范围，也会返回无穷。\nMath.pow(2, 2048) // Infinity\n-Math.pow(2, 2048) // -Infinity\n```\n\n### 参与运算\n\nInfinity的四则运算，符合无穷的数学计算规则。\n\n```javascript\n5 * Infinity // Infinity\n5 - Infinity // -Infinity\nInfinity / 5 // Infinity\n5 / Infinity // 0\n```\n\n```javascript\nInfinity - Infinity // NaN\nInfinity / Infinity // NaN\n\nInfinity + Infinity // Infinity\nInfinity * Infinity // Infinity\n```\n    \nnfinity可以用于布尔运算。可以记住，Infinity是JavaScript中最大的值（NaN除外），-Infinity是最小的值（NaN除外）。\n\n```javascript    \n5 > -Infinity // true\n5 > Infinity // false\n```\n\n由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript都不报错，所以单纯的数学运算几乎没有可能抛出错误。\n\n### isFinite函数\nisFinite函数返回一个布尔值，检查某个值是否为正常值，而不是Infinity。\n\n```javascript\nisFinite(Infinity) // false\nisFinite(-1) // true\nisFinite(true) // true\nisFinite(NaN) // false //如果对NaN使用isFinite函数，也返回false，表示NaN不是一个正常值\n```\n\n# 数值转换\n\n## Number()\n\n使用Number函数，可以将任意类型的值(<span style=\"color:red;\">parseInt和parseFloat只能转换字符串和数值类型</span>)转化成数字。\n\n* **简单类型转换规则**\n\n    - 数值：转换为十进制(因为默认调用toString()，会以十进制输出)。\n        ```javascript\n        Number(10);     // 10 \n        Number(010);    // 8\n        Number(090);    // 90 因为八进制中没有9，所以按照十进制处理 \n        Number(0x16);   // 22 \n        \n        Number(0o10);   //  在chrome和firefox为8，IE报错 `缺少 “)”` \n        Number(0b1000); //  在chrome和firefox为8，IE报错 `缺少 “)”` \n        ```\n\n    - 字符串：先去掉字符串前后的空格，如果可以被解析为数值，则转换为相应的数值，否则得到NaN。**空字符串`\"\"`转为0**。\n        - 如果字符串是`Number(\"0o17\")`和`Number(\"0b10000\")`（包括前面带正号或负号的情况）在chrome和firefox会按照八进制转换为十进制 16，但是IE不会生产`NaN`，十六进制没问题chrome和firefox、IE没问题。\n        - 如果字符串中包含有效的浮点格式，如\"1.1\"，则将其转换为对应的浮点数值（同样，也会忽略前导零）。\n        \n    - 布尔值：`true`转成 1，`false` 转成 0。\n\n    - `undefined`：转成`NaN`。\n\n    - `null`：转成0。\n\n    ```javascript\n    Number(\"324\") // 324\n    Number(\" -9.8 \") // -9.8\n    \n    Number(\"010\") // 10 和parseInt(\"010\")为不同\n    Number(\"0o17\")//  在chrome和firefox为16。IE为NaN。 \n    Number(\"0b10000\") // 在chrome和firefox为16。IE为NaN。 \n    Number(\"0x10\") // 在chrome和firefox为16。IE也为16。\n    \n    Number(\"324abc\") // NaN\n\n    Number(\"\") // 0\n\n    Number(false) // 0\n\n    Number(undefined) // NaN\n\n    Number(null) // 0\n    ```\n* **对象的转换规则**\n    对象的转换规则比较复杂。\n    1. 先调用对象自身的`valueOf`方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用`Number`方法，不再进行后续步骤。\n    2. 如果`valueOf`方法返回复合类型的值，再调用对象自身的`toString`方法，如果`toString`方法返回原始类型的值，则对该值使用`Number`方法，不再进行后续步骤。\n    3. 如果`toString`方法返回的是复合类型的值，则报错。\n    \n    ```javascript\n    Number({a:1,valueOf:function(){return \"5\"}}); //5  先调用对象自身的`valueOf`方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用`Number`方法，不再进行后续步骤。\n    Number({a:1,valueOf:function(){return {b:5}},toString:function(){return 4}}); //4  如果`valueOf`方法返回复合类型的值，再调用对象自身的`toString`方法，如果`toString`方法返回原始类型的值，则对该值使用`Number`方法，不再进行后续步骤。\n    Number({a:1,valueOf:function(){return {b:5}},toString:function(){return {}}}); //TypeError: Cannot convert object to primitive value 如果`toString`方法返回的是复合类型的值，则报错。\n    ```\n## parseInt()\n* 基本用法    \n    `parseInt()`方法可以将字符串转化为整数。如果字符串头部有空格，空格会被自动去除。\n    ```javascript\n        parseInt('8a') // 8\n        parseInt(\" -12 ba\") //-12\n        \n        //十六进制\n        parseInt('0xf00') // 3840 开头两个字符是`0x`或`0X`，`parseInt`将其视为十六进制数\n        //八进制\n        parseInt('056') // 56\n        parseInt('0o56') // 0\n        parseInt('0O56') // 0\n        //二进制\n        parseInt(\"0B10\") // 0\n    ```\n    上面代码中，`parseInt`的参数都是字符串，结果只返回字符串头部可以转为数字的部分。最后一行的`0xf00`之所以可以转为数字，因为如果开头两个字符是`0x`或`0X`，`parseInt`将其视为十六进制数，但是八进制和二进制确默认视为普通字符串。\n    如果字符串的第一个`非空格字符`不能转化为数字（数字的正负号除外），返回`NaN`。\n    \n    ```javascript\n    parseInt('abc') // NaN\n    parseInt('.3') // NaN\n    parseInt('') // NaN 不同于Number()\n    parseInt(null) // NaN 不同于Number()\n    parseInt('+') // NaN\n    ```\n* 进制转换\n`parseInt()`方法还可以接受第二个参数（2到36之间，超出区间(`包括负数但0除外`)返回`NaN`），表示被解析的值的进制，返回该值对应的十进制数。\n如果第二个参数不是数值，会被自动转为（调用`Number()`）一个整数，这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回`NaN`，如果转换的结果为`0，NaN`，都会直接忽略返回原值。\n如果第二个参数是`0`、`undefined`和`null`等等一些不能转为正常整数的值，则直接忽略。\n\n    ```javascript\n        parseInt(1000, 2) // 8\n        parseInt(1000, 6) // 216\n        parseInt(1000, 8) // 512\n        //特殊情况\n        parseInt(1000, \"8\") // 512 把\"8\"自动转为8\n        parseInt(1000, \" +8 \") // 512 会自动去掉前置和后置空格\n        parseInt(1000, \" -8 \") // NaN 负数超出范围\n        parseInt(1000, 1) // NaN 超出范围\n        parseInt(1000, 37) // NaN 超出范围\n        parseInt(1000, \"8aa\") // 1000 因为Number(\"8aa\")等于NaN\n        parseInt(1000, 0) // 1000  直接忽略返回原值\n        parseInt(1000, NaN) // 1000\n        parseInt(1000, null) // 1000 因为Number(NaN)等于0\n        parseInt(1000, undefined) // 1000 因为Number(undefined)等于NaN\n        parseInt(\"1000\", {\n            a:1,\n            valueOf:function(){\n                return 5;\n            }\n        }) //125  因为Number({a:1,valueOf:function(){return 5;}}) 返回5 所以\n    ```\n  \n* 特别注意\n需要注意的是，进制转换的时候，参数是字符串或数值，`parseInt`的行为不一致。\n1. 如果第一个参数是数值，会将这个数值先转为十进制，然后再应用第二个参数。\n\n    ```javascript\n    parseInt(0x11, 36) // 43\n    parseInt(17, 36) // 43\n    ```\n    上面代码中，`0x11`会被先转为十进制的17，然后再用36进制解读这个17，最后返回结果43。\n\n2. 如果第一个参数是字符串，则会直接用指定进制解读这个字符串。\n    \n    ```javascript\n    parseInt('0x11', 36) // 42805\n    parseInt('x', 36) // 33\n    ```\n\n    上面代码中，字符串`0x11`会被直接当作一个36进制的数。由于字符`x`在36进制中代表33，导致`0x11`被解读为42805。\n\n    ```javascript\n    parseInt(010, 10) // 8\n    parseInt('010', 10) // 10\n\n    parseInt(010, 2) // NaN 因为`010数值`转换为十进制是8，而8在二进制是不存在的所以返回`NaN`\n    parseInt('010', 2) // 2\n\n    parseInt(010, 8) // NaN 因为`010数值`转换为十进制是8，而8在八进制是不存在的所以返回`NaN`\n    parseInt('010', 8) // 8\n\n    parseInt(020, 10) // 16\n    parseInt('020', 10) // 20\n\n    parseInt(020, 8) // 14 因为`020数值`转换为十进制是16，再转换为8进制刚好14\n    parseInt('020', 8) // 16 因为`020字符串`转换为十进制是20，再转换为8进制刚好16\n    ```\n\n    上面代码中，`010`会被先转为十进制8，然后再应用第二个参数，由于二进制和八进制中没有8这个数字，所以`parseInt(010, 2)`和`parseInt(010, 8)`返回`NaN`。同理，数值`020`会被先转为十进制的16，然后再应用第二个参数。\n    > `parseInt`的很多复杂行为，都是由八进制的前缀0引发的，这增加编程处理的复杂性。因此，ECMAScript 5不再允许parseInt将带有前缀0的数字，视为八进制数，而是要求忽略这个`0`。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。\n\n3. 如果第一个参数是以`0x`或`0X`开头的字符串，而第二个参数省略或为0，则`parseInt`自动将第二个参数设为16。\n    ```javascript\n        parseInt('0xFF') // 255\n        parseInt('0xFF', 0) // 255\n        parseInt('0xFF', 16) // 255\n        \n        parseInt('0xFF', 10) // 0\n        parseInt('0xFF', 17) // 0\n    ```\n    上面代码中，第二个参数除了0、16和省略，其他情况都会依次解析第一个参数，直到遇到第一个不可解析字符。\n\n4. 如果参数是对象，数据或者{}\n  和Number()过程相反，先调用 toString()，如果返回的不是 简单数据类型则再调用valueOf方法。\n  `parseInt({a:1,valueOf:function(){return 5},toString:function(){return 4}});// 4`\n  `parseInt([2,3]);//2因为数组的valueOf返回还是数组，继续调用toString方法，返回\"2,3\",再parseInt返回 2`\n\n5. 科学计数法产生的扯淡问题\n    对于那些会自动转为科学计数法的数字，`parseInt`会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。\n    \n    ```javascript\n    parseInt(1000000000000000000000.5, 10) // 1\n    // 等同于\n    parseInt('1e+21', 10) // 1\n\n    parseInt(0.0000008, 10) // 8\n    // 等同于\n    parseInt('8e-7', 10) // 8\n    ```\n  \n## parseFloat()\n* 基本用法\n    parseFloat`方法用于将一个字符串转为浮点数。    \n    ```javascript\n    parseFloat(\"3.14\") // 3.14\n    ```\n\n1. 如果字符串符合科学计数法，则会进行相应的转换。\n    \n    ```javascript\n    parseFloat('314e-2') // 3.14\n    parseFloat('0.0314E+2') // 3.14\n    ```\n2. 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。\n    ```javascript\n    parseFloat('3.14more non-digit characters') // 3.14\n    ```\n    `parseFloat`方法会自动过滤字符串前导的空格。\n    ```javascript\n    parseFloat('\\t\\v\\r12.34\\n ') // 12.34\n    ```\n\n3. 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回`NaN`。\n    ```javascript\n    parseFloat([]) // NaN\n    parseFloat('FF2') // NaN\n\n    parseFloat(true)  // NaN 不同于`Number`函数\n    Number(true) // 1\n\n    parseFloat(null) // NaN 不同于`Number`函数\n    Number(null) // 0\n\n    parseFloat('') // NaN 不同于`Number`函数\n    Number('') // 0\n\n    parseFloat('123.45#') // 123.45  不同于`Number`函数\n    Number('123.45#') // NaN\n    ```\n 4. 如果参数是对象，数据或者{}\n  和Number()过程相反，先调用 toString()，如果返回的不是 简单数据类型则再调用valueOf方法。\n  `parseFloat({a:1,valueOf:function(){return 5},toString:function(){return 4}});// 4`\n  `parseInt([2,3]);//2因为数组的valueOf返回还是数组，继续调用toString方法，返回\"2,3\",再parseInt返回 2`\n  \n** 特别注意：`parseInt()`和`parseFloat()`会先调用值的`toString()`方法，`Number()`是先调用`valueOf`，返回结果有问题再调用`toString`**\n```javascript\nparseInt({\na: 1,\ntoString: function(){\n            return \"11\"\n            }\n});\n\nparseFloat({\na: 1,\ntoString: function(){\n            return \"11\"\n            }\n});\n```\n上面这两种情况也会正确的返回`11`，看到这儿你会说“你不是说parseInt只能转换字符串”吗？其实真正的原因是，所有的转换第一步都是调用`toString()`方法。\n\n```javascript\nNumber.prototype.toString = function(){\n    console.log(\"我被调用了\")\n    return 123123;\n}\nNumber.prototype.valueOf = function(){\n    console.log(\"我被调用了-valueOf\")\n    return 123123;\n}\n\nvar a  = new Number(12);\n\n\nparseInt(a) // 我被调用了 123123\nNumber(a) // 我被调用了-valueOf 123123\n```\n上面这段code 足以证明**特别注意**。\n详见：[Ex igne vita](http://es5.github.io/#x15.1.2.2)\n\n** 引用：**\n\n> [紫云飞](http://www.cnblogs.com/ziyunfei/archive/2012/12/10/2777099.html)\n> [阮一峰](http://javascript.ruanyifeng.com/)","slug":"好好学学number","published":1,"updated":"2016-06-11T04:57:41.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7qp000m543v57wgdxee"},{"title":"好好学学String!","date":"2016-02-02T06:36:10.000Z","comments":1,"_content":"## 概述\n\n### 定义\n\n字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。\n<!--more-->\n```javascript\n'abc'\n\"abc\"\n```\n\n单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。\n\n```javascript\n'key=\"value\"'\n\"It's a long journey\"\n```\n\n上面两个都是合法的字符串。\n\n如果要在单引号字符串的内部，使用单引号（或者在双引号字符串的内部，使用双引号），就必须在内部的单引号（或者双引号）前面加上反斜杠，用来转义。\n\n```javascript\n'Did she say \\'Hello\\'?'\n// \"Did she say 'Hello'?\"\n\n\"Did she say \\\"Hello\\\"?\"\n// \"Did she say \"Hello\"?\"\n```\n\n字符串默认只能写在一行内，分成多行将会报错。\n\n```javascript\n'a\nb\nc'\n// SyntaxError: Unexpected token ILLEGAL\n```\n\n上面代码将一个字符串分成三行，JavaScript就会报错。\n\n多行字符串是正式规范(ECMA 265 5th edition)的一部分，ES5扩展了字符串字面量的语法。在(7.8.4 String Literals)中添加了`DoubleStringCharacter`和 `SingleStringCharacter`: `LineContinuation`。\nLineTerminatorSequence 指的是下面这些字符中的一个：\n* 换行符 `<LF>`\n* 回车符 `<CR>`\n* 行分割符 `<LS>`\n* 段分隔符 `<PS>`\n\nLineContinuation 的语法是:\n```javascript\n    \\ LineTerminatorSequence\n```\n如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\n\n```javascript\nvar longString = \"Long\\\\n\\\nlong \\\nlong \\\nstring\";\n\nlongString\n// \"Long\\nlong long string\"\n```\n\n上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行，效果与写在同一行完全一样。注意，反斜杠的后面必须是`LineTerminatorSequence`中的一个上例中的是换行符，而不能有其他字符（比如空格），否则会报错。\n\n连接运算符（`+`）可以连接多个单行字符串，用来模拟多行字符串。\n\n```javascript\nvar longString = 'Long '\n  + 'long '\n  + 'long '\n  + 'string';\n```\n\n另外，有一种利用多行注释，生成多行字符串的变通方法。\n\n```javascript\n(function () { /*\nline 1\nline 2\nline 3\n*/}).toString().split('\\n').slice(1,-1).join('\\n')\n// \"line 1 line 2 line 3\"\n\n### 转义\n\n反斜杠（`\\\\`）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。\n\n需要用反斜杠转义的特殊字符，主要有下面这些：\n\n- `\\0` 代表没有内容的字符（\\u0000）\n- `\\b` 后退键（\\u0008）\n- `\\f` 换页符（\\u000C）\n- `\\n` 换行符（\\u000A）\n- `\\r` 回车键（\\u000D）\n- `\\t` 制表符（\\u0009）\n- `\\v` 垂直制表符（\\u000B）\n- `\\'` 单引号（\\u0027）\n- `\\\"` 双引号（\\u0022）\n- `\\\\\\\\` 反斜杠（\\u005C）\n- `\\XXX` 用三个八进制数（000到377）表示字符，`XXX`对应该字符的Unicode，比如`\\251`表示版权符号。\n- `\\xXX` 用两个十六进制数（00到FF）表示字符，`XX`对应该字符的Unicode，比如`\\xA9`表示版权符号。\n- `\\uXXXX` 用四位十六进制的Unicode编号代表某个字符，比如`\\u00A9`表示版权符号。\n\n下面是最后三种字符的特殊写法的例子。\n\n```javascript\n'\\251' // \"©\"\n'\\xA9' // \"©\"\n'\\u00A9' // \"©\"\n\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n```\n\n如果非特殊字符前面使用反斜杠，则反斜杠会被省略。\n\n```javascript\n'\\a' // \"a\"\n```\n\n上面代码表示`a`是一个正常字符，前面加反斜杠没有特殊含义，则反斜杠会被自动省略。\n\n如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前需要再加一个反斜杠，用来对自身转义。\n\n```javascript\n\"Prev \\\\ Next\" // \"Prev \\ Next\"\n```\n\n### 字符串与数组\n\n字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（从0开始）。\n\n```javascript\nvar s = 'hello';\n\ns[0] // \"h\"\ns[1] // \"e\"\ns[4] // \"o\"\n\n// 也可以直接对字符串使用方括号运算符\n'hello'[1] // \"e\"\n```\n\n如果方括号中的数字超过字符串的范围，或者方括号中根本不是数字，则返回`undefined`。\n\n```javascript\n'abc'[3] // undefined\n'abc'[-1] // undefined\n'abc'['x'] // undefined\n```\n\n但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。\n\n```javascript\nvar s = 'hello';\n\ndelete s[0];\ns // \"hello\"\n\ns[1] = 'a';\ns // \"hello\"\n\ns[5] = '!';\ns // \"hello\"\n```\n\n上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。\n\n字符串也无法添加新属性。\n\n```javascript\nvar s = 'Hello World';\ns.x = 123;\ns.x // undefined\n```\n\n上面代码为字符串`s`添加了一个`x`属性，结果无效，总是返回`undefined`。\n\n上面这些行为的原因是，在JavaScript内部，变量`s`其实指向字符串`Hello World`的地址，而`Hello World`本身是一个常量，所以无法改变它，既不能新增，也不能删除。另一方面，当一个字符串被调用属性时，它会自动转为String对象的实例（参见《标准库》一章），调用结束后，该对象自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个临时生成的新对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果想要为字符串添加属性，只有在它的原型对象`String.prototype`上定义（参见《面向对象编程》一章）。\n\n### length属性\n\n`length`属性返回字符串的长度，该属性也是无法改变的。\n\n```javascript\nvar s = 'hello';\ns.length // 5\n\ns.length = 3;\ns.length // 5\n\ns.length = 7;\ns.length // 5\n```\n\n上面代码表示字符串的`length`属性无法改变，但是不会报错。\n\n## 字符集\n\nJavaScript使用Unicode字符集，也就是说在JavaScript内部，所有字符都用Unicode表示。\n\n不仅JavaScript内部使用Unicode储存字符，而且还可以直接在程序中使用Unicode，所有字符都可以写成\"\\uxxxx\"的形式，其中xxxx代表该字符的Unicode编码。比如，`\\u00A9`代表版权符号。\n\n```javascript\nvar s = '\\u00A9';\ns // \"©\"\n```\n\n每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。\n\n但是，UTF-16有两种长度：对于`U+0000`到`U+FFFF`之间的字符，长度为16位（即2个字节）；对于`U+10000`到`U+10FFFF`之间的字符，长度为32位（即4个字节），而且前两个字节在`0xD800`到`0xDBFF`之间，后两个字节在`0xDC00`到`0xDFFF`之间。举例来说，`U+1D306`对应的字符为𝌆，它写成UTF-16就是`0xD834 0xDF06`。浏览器会正确将这四个字节识别为一个字符，但是JavaScript内部的字符长度总是固定为16位，会把这四个字节视为两个字符。\n\n```javascript\nvar s = '\\uD834\\uDF06';\n\ns // \"𝌆\"\ns.length // 2\n/^.$/.test(s) // false\ns.charAt(0) // \"\"\ns.charAt(1) // \"\"\ns.charCodeAt(0) // 55348\ns.charCodeAt(1) // 57094\n```\n\n上面代码说明，对于于`U+10000`到`U+10FFFF`之间的字符，JavaScript总是视为两个字符（字符的`length`属性为2），用来匹配单个字符的正则表达式会失败（JavaScript认为这里不止一个字符），`charAt`方法无法返回单个字符，`charCodeAt`方法返回每个字节对应的十进制值。\n\n所以处理的时候，必须把这一点考虑在内。对于4个字节的Unicode字符，假定`C`是字符的Unicode编号，`H`是前两个字节，`L`是后两个字节，则它们之间的换算关系如下。\n\n```javascript\n// 将大于U+FFFF的字符，从Unicode转为UTF-16\nH = Math.floor((C - 0x10000) / 0x400) + 0xD800\nL = (C - 0x10000) % 0x400 + 0xDC00\n\n// 将大于U+FFFF的字符，从UTF-16转为Unicode\nC = (H - 0xD800) * 0x400 + L - 0xDC00 + 0x10000\n```\n\n下面的正则表达式可以识别所有UTF-16字符。\n\n```javascript\n([\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])\n```\n\n由于JavaScript引擎（严格说是ES5规格）不能自动识别辅助平面（编号大于0xFFFF）的Unicode字符，导致所有字符串处理函数遇到这类字符，都会产生错误的结果（详见《标准库》一章的`String`对象章节）。如果要完成字符串相关操作，就必须判断字符是否落在`0xD800`到`0xDFFF`这个区间。\n\n下面是能够正确处理字符串遍历的函数。\n\n```javascript\nfunction getSymbols(string) {\n  var length = string.length;\n  var index = -1;\n  var output = [];\n  var character;\n  var charCode;\n  while (++index < length) {\n    character = string.charAt(index);\n    charCode = character.charCodeAt(0);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      output.push(character + string.charAt(++index));\n    } else {\n      output.push(character);\n    }\n  }\n  return output;\n}\n\nvar symbols = getSymbols('𝌆');\n\nsymbols.forEach(function(symbol) {\n  // ...\n});\n```\n\n替换（`String.prototype.replace`）、截取子字符串（`String.prototype.substring`, `String.prototype.slice`）等其他字符串操作，都必须做类似的处理。\n\n## Base64转码\n\nBase64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是为了不出现特殊字符，简化程序的处理。\n\nJavaScript原生提供两个Base64相关方法。\n\n- btoa()：字符串或二进制值转为Base64编码\n- atob()：Base64编码转为原来的编码\n\n```javascript\nvar string = 'Hello World!';\nbtoa(string) // \"SGVsbG8gV29ybGQh\"\natob('SGVsbG8gV29ybGQh') // \"Hello World!\"\n```\n\n这两个方法不适合非ASCII码的字符，会报错。\n\n```javascript\nbtoa('你好')\n// Uncaught DOMException: The string to be encoded contains characters outside of the Latin1 range.\n```\n\n要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。\n\n```javascript\nfunction b64Encode( str ) {\n  return btoa(unescape(encodeURIComponent( str )));\n}\n\nfunction b64Decode( str ) {\n  return decodeURIComponent(escape(atob( str )));\n}\n\nb64Encode('你好') // \"5L2g5aW9\"\nb64Decode('5L2g5aW9') // \"你好\"\n```\n## 转换为字符串 String()\n\n### toString()\n数值、布尔值、对象和字符串值（没错，每个字符串也都有一个`toString()`方法，该方法返回字符串的一个副本）都有`toString()`方法。但`null` 和 `undefined` 值没有这个方法。\n多数情况下，调用`toString()`方法不必传递参数。但是，在调用数值的`toString()`方法时，可以传递一个参数：输出数值的基数。默认情况下，`toString()`方法以十进制格式返回数值的字符串表示。而通过传递基数，`toString()`可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。\n在不知道要转换的值是不是`null` 或 `undefined` 的情况下，还可以使用转型函数`String()`。\n### String()\n\n使用String函数，可以将任意类型的值转化成字符串。规则如下：\n\n1. 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果。\n2. 如果值是null，则返回\"null\"。\n3. 如果值是undefined，则返回\"undefined\"。\n\n**（1）原始类型值的转换规则**\n\n- **数值**：调用Number的toString()方法，转换后还是原来的值。转为相应的字符串。\n\n- **字符串**：调用String的toString()方法，转换后还是原来的值。\n\n- **布尔值**：调用Boolean的toString()方法，true转为“true”，false转为“false”。\n\n- **undefined**：转为“undefined”。\n\n- **null**：转为“null”。\n```javascript\nString(123) // \"123\"\n\nString(\"abc\") // \"abc\"\n\nString(true) // \"true\"\n\nString(undefined) // \"undefined\"\n\nString(null) // \"null\"\n\nBoolean.prototype.toString = function(){\n    console.log(\"wo bei diaoyongle\");\n}\nvar a = new Boolean(true);\nString(a) // \"wo bei diaoyongle\" \"undefined\"\n\n```\n**（2）对象的转换规则**\n\n如果要将对象转为字符串，则是采用以下步骤。\n\n1. 先调用`toString`方法，如果toString方法返回的是简单类型(`Boolean`、`number`、`string`、`null`、`undefined`)的值，则对该值使用`String`方法，不再进行以下步骤。\n\n2. 如果`toString`方法返回的是复合类型的值，再调用`valueOf`方法，如果`valueOf`方法返回的是原始类型的值，则对该值使用String方法，不再进行以下步骤。\n\n3. 如果`valueOf`方法返回的是复合类型的值，则报错。\n\nString方法的这种过程正好与Number方法相反。\n\n```javascript\n\nString({a:1}) // \"[object Object]\"\n```\n\n上面代码相当于下面这样。\n\n```javascript\n\nString({a:1}.toString()) // \"[object Object]\"\n\n```\n\n如果toString方法和valueOf方法，返回的都不是原始类型的值，则String方法报错。\n```javascript\nvar  T = {toString:function(){return true},valueOf:function(){return undefined}};\nString(T) // \"true\" 调用toString\n\nvar  T = {toString:function(){return {}},valueOf:function(){return undefined}};\nString(T) // \"undefined\" 调用valueOf\n\nvar  T = {toString:function(){return {}},valueOf:function(){return {}}};\nString(T) // Error Uncaught TypeError: Cannot convert object to primitive value(…)\n\n```\n\n下面是一个自定义toString方法的例子。\n\n```javascript\n\nString({toString:function(){return 3;}}) // \"3\"\n\nString({valueOf:function (){return 2;}}) // \"[object Object]\"\n\nString({valueOf:function (){return 2;},toString:function(){return 3;}}) // \"3\"\n```\n\n上面代码对三个对象使用String方法。第一个对象返回toString方法的值（数值3），然后对其使用String方法，得到字符串“3”；第二个对象返回的还是toString方法的值（\"[object Object]\"），这次直接就是字符串；第三个对象表示toString方法先于valueOf方法执行。\n\n\n> ** 转自：** (阮一峰)[http://javascript.ruanyifeng.com/grammar/string.html]","source":"_posts/好好学学String-2016-02-02.md","raw":"title: 好好学学String!\ndate: 2016-02-02 14:36:10\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n## 概述\n\n### 定义\n\n字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。\n<!--more-->\n```javascript\n'abc'\n\"abc\"\n```\n\n单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。\n\n```javascript\n'key=\"value\"'\n\"It's a long journey\"\n```\n\n上面两个都是合法的字符串。\n\n如果要在单引号字符串的内部，使用单引号（或者在双引号字符串的内部，使用双引号），就必须在内部的单引号（或者双引号）前面加上反斜杠，用来转义。\n\n```javascript\n'Did she say \\'Hello\\'?'\n// \"Did she say 'Hello'?\"\n\n\"Did she say \\\"Hello\\\"?\"\n// \"Did she say \"Hello\"?\"\n```\n\n字符串默认只能写在一行内，分成多行将会报错。\n\n```javascript\n'a\nb\nc'\n// SyntaxError: Unexpected token ILLEGAL\n```\n\n上面代码将一个字符串分成三行，JavaScript就会报错。\n\n多行字符串是正式规范(ECMA 265 5th edition)的一部分，ES5扩展了字符串字面量的语法。在(7.8.4 String Literals)中添加了`DoubleStringCharacter`和 `SingleStringCharacter`: `LineContinuation`。\nLineTerminatorSequence 指的是下面这些字符中的一个：\n* 换行符 `<LF>`\n* 回车符 `<CR>`\n* 行分割符 `<LS>`\n* 段分隔符 `<PS>`\n\nLineContinuation 的语法是:\n```javascript\n    \\ LineTerminatorSequence\n```\n如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\n\n```javascript\nvar longString = \"Long\\\\n\\\nlong \\\nlong \\\nstring\";\n\nlongString\n// \"Long\\nlong long string\"\n```\n\n上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行，效果与写在同一行完全一样。注意，反斜杠的后面必须是`LineTerminatorSequence`中的一个上例中的是换行符，而不能有其他字符（比如空格），否则会报错。\n\n连接运算符（`+`）可以连接多个单行字符串，用来模拟多行字符串。\n\n```javascript\nvar longString = 'Long '\n  + 'long '\n  + 'long '\n  + 'string';\n```\n\n另外，有一种利用多行注释，生成多行字符串的变通方法。\n\n```javascript\n(function () { /*\nline 1\nline 2\nline 3\n*/}).toString().split('\\n').slice(1,-1).join('\\n')\n// \"line 1 line 2 line 3\"\n\n### 转义\n\n反斜杠（`\\\\`）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。\n\n需要用反斜杠转义的特殊字符，主要有下面这些：\n\n- `\\0` 代表没有内容的字符（\\u0000）\n- `\\b` 后退键（\\u0008）\n- `\\f` 换页符（\\u000C）\n- `\\n` 换行符（\\u000A）\n- `\\r` 回车键（\\u000D）\n- `\\t` 制表符（\\u0009）\n- `\\v` 垂直制表符（\\u000B）\n- `\\'` 单引号（\\u0027）\n- `\\\"` 双引号（\\u0022）\n- `\\\\\\\\` 反斜杠（\\u005C）\n- `\\XXX` 用三个八进制数（000到377）表示字符，`XXX`对应该字符的Unicode，比如`\\251`表示版权符号。\n- `\\xXX` 用两个十六进制数（00到FF）表示字符，`XX`对应该字符的Unicode，比如`\\xA9`表示版权符号。\n- `\\uXXXX` 用四位十六进制的Unicode编号代表某个字符，比如`\\u00A9`表示版权符号。\n\n下面是最后三种字符的特殊写法的例子。\n\n```javascript\n'\\251' // \"©\"\n'\\xA9' // \"©\"\n'\\u00A9' // \"©\"\n\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n```\n\n如果非特殊字符前面使用反斜杠，则反斜杠会被省略。\n\n```javascript\n'\\a' // \"a\"\n```\n\n上面代码表示`a`是一个正常字符，前面加反斜杠没有特殊含义，则反斜杠会被自动省略。\n\n如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前需要再加一个反斜杠，用来对自身转义。\n\n```javascript\n\"Prev \\\\ Next\" // \"Prev \\ Next\"\n```\n\n### 字符串与数组\n\n字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（从0开始）。\n\n```javascript\nvar s = 'hello';\n\ns[0] // \"h\"\ns[1] // \"e\"\ns[4] // \"o\"\n\n// 也可以直接对字符串使用方括号运算符\n'hello'[1] // \"e\"\n```\n\n如果方括号中的数字超过字符串的范围，或者方括号中根本不是数字，则返回`undefined`。\n\n```javascript\n'abc'[3] // undefined\n'abc'[-1] // undefined\n'abc'['x'] // undefined\n```\n\n但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。\n\n```javascript\nvar s = 'hello';\n\ndelete s[0];\ns // \"hello\"\n\ns[1] = 'a';\ns // \"hello\"\n\ns[5] = '!';\ns // \"hello\"\n```\n\n上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。\n\n字符串也无法添加新属性。\n\n```javascript\nvar s = 'Hello World';\ns.x = 123;\ns.x // undefined\n```\n\n上面代码为字符串`s`添加了一个`x`属性，结果无效，总是返回`undefined`。\n\n上面这些行为的原因是，在JavaScript内部，变量`s`其实指向字符串`Hello World`的地址，而`Hello World`本身是一个常量，所以无法改变它，既不能新增，也不能删除。另一方面，当一个字符串被调用属性时，它会自动转为String对象的实例（参见《标准库》一章），调用结束后，该对象自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个临时生成的新对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果想要为字符串添加属性，只有在它的原型对象`String.prototype`上定义（参见《面向对象编程》一章）。\n\n### length属性\n\n`length`属性返回字符串的长度，该属性也是无法改变的。\n\n```javascript\nvar s = 'hello';\ns.length // 5\n\ns.length = 3;\ns.length // 5\n\ns.length = 7;\ns.length // 5\n```\n\n上面代码表示字符串的`length`属性无法改变，但是不会报错。\n\n## 字符集\n\nJavaScript使用Unicode字符集，也就是说在JavaScript内部，所有字符都用Unicode表示。\n\n不仅JavaScript内部使用Unicode储存字符，而且还可以直接在程序中使用Unicode，所有字符都可以写成\"\\uxxxx\"的形式，其中xxxx代表该字符的Unicode编码。比如，`\\u00A9`代表版权符号。\n\n```javascript\nvar s = '\\u00A9';\ns // \"©\"\n```\n\n每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。\n\n但是，UTF-16有两种长度：对于`U+0000`到`U+FFFF`之间的字符，长度为16位（即2个字节）；对于`U+10000`到`U+10FFFF`之间的字符，长度为32位（即4个字节），而且前两个字节在`0xD800`到`0xDBFF`之间，后两个字节在`0xDC00`到`0xDFFF`之间。举例来说，`U+1D306`对应的字符为𝌆，它写成UTF-16就是`0xD834 0xDF06`。浏览器会正确将这四个字节识别为一个字符，但是JavaScript内部的字符长度总是固定为16位，会把这四个字节视为两个字符。\n\n```javascript\nvar s = '\\uD834\\uDF06';\n\ns // \"𝌆\"\ns.length // 2\n/^.$/.test(s) // false\ns.charAt(0) // \"\"\ns.charAt(1) // \"\"\ns.charCodeAt(0) // 55348\ns.charCodeAt(1) // 57094\n```\n\n上面代码说明，对于于`U+10000`到`U+10FFFF`之间的字符，JavaScript总是视为两个字符（字符的`length`属性为2），用来匹配单个字符的正则表达式会失败（JavaScript认为这里不止一个字符），`charAt`方法无法返回单个字符，`charCodeAt`方法返回每个字节对应的十进制值。\n\n所以处理的时候，必须把这一点考虑在内。对于4个字节的Unicode字符，假定`C`是字符的Unicode编号，`H`是前两个字节，`L`是后两个字节，则它们之间的换算关系如下。\n\n```javascript\n// 将大于U+FFFF的字符，从Unicode转为UTF-16\nH = Math.floor((C - 0x10000) / 0x400) + 0xD800\nL = (C - 0x10000) % 0x400 + 0xDC00\n\n// 将大于U+FFFF的字符，从UTF-16转为Unicode\nC = (H - 0xD800) * 0x400 + L - 0xDC00 + 0x10000\n```\n\n下面的正则表达式可以识别所有UTF-16字符。\n\n```javascript\n([\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])\n```\n\n由于JavaScript引擎（严格说是ES5规格）不能自动识别辅助平面（编号大于0xFFFF）的Unicode字符，导致所有字符串处理函数遇到这类字符，都会产生错误的结果（详见《标准库》一章的`String`对象章节）。如果要完成字符串相关操作，就必须判断字符是否落在`0xD800`到`0xDFFF`这个区间。\n\n下面是能够正确处理字符串遍历的函数。\n\n```javascript\nfunction getSymbols(string) {\n  var length = string.length;\n  var index = -1;\n  var output = [];\n  var character;\n  var charCode;\n  while (++index < length) {\n    character = string.charAt(index);\n    charCode = character.charCodeAt(0);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      output.push(character + string.charAt(++index));\n    } else {\n      output.push(character);\n    }\n  }\n  return output;\n}\n\nvar symbols = getSymbols('𝌆');\n\nsymbols.forEach(function(symbol) {\n  // ...\n});\n```\n\n替换（`String.prototype.replace`）、截取子字符串（`String.prototype.substring`, `String.prototype.slice`）等其他字符串操作，都必须做类似的处理。\n\n## Base64转码\n\nBase64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是为了不出现特殊字符，简化程序的处理。\n\nJavaScript原生提供两个Base64相关方法。\n\n- btoa()：字符串或二进制值转为Base64编码\n- atob()：Base64编码转为原来的编码\n\n```javascript\nvar string = 'Hello World!';\nbtoa(string) // \"SGVsbG8gV29ybGQh\"\natob('SGVsbG8gV29ybGQh') // \"Hello World!\"\n```\n\n这两个方法不适合非ASCII码的字符，会报错。\n\n```javascript\nbtoa('你好')\n// Uncaught DOMException: The string to be encoded contains characters outside of the Latin1 range.\n```\n\n要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。\n\n```javascript\nfunction b64Encode( str ) {\n  return btoa(unescape(encodeURIComponent( str )));\n}\n\nfunction b64Decode( str ) {\n  return decodeURIComponent(escape(atob( str )));\n}\n\nb64Encode('你好') // \"5L2g5aW9\"\nb64Decode('5L2g5aW9') // \"你好\"\n```\n## 转换为字符串 String()\n\n### toString()\n数值、布尔值、对象和字符串值（没错，每个字符串也都有一个`toString()`方法，该方法返回字符串的一个副本）都有`toString()`方法。但`null` 和 `undefined` 值没有这个方法。\n多数情况下，调用`toString()`方法不必传递参数。但是，在调用数值的`toString()`方法时，可以传递一个参数：输出数值的基数。默认情况下，`toString()`方法以十进制格式返回数值的字符串表示。而通过传递基数，`toString()`可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。\n在不知道要转换的值是不是`null` 或 `undefined` 的情况下，还可以使用转型函数`String()`。\n### String()\n\n使用String函数，可以将任意类型的值转化成字符串。规则如下：\n\n1. 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果。\n2. 如果值是null，则返回\"null\"。\n3. 如果值是undefined，则返回\"undefined\"。\n\n**（1）原始类型值的转换规则**\n\n- **数值**：调用Number的toString()方法，转换后还是原来的值。转为相应的字符串。\n\n- **字符串**：调用String的toString()方法，转换后还是原来的值。\n\n- **布尔值**：调用Boolean的toString()方法，true转为“true”，false转为“false”。\n\n- **undefined**：转为“undefined”。\n\n- **null**：转为“null”。\n```javascript\nString(123) // \"123\"\n\nString(\"abc\") // \"abc\"\n\nString(true) // \"true\"\n\nString(undefined) // \"undefined\"\n\nString(null) // \"null\"\n\nBoolean.prototype.toString = function(){\n    console.log(\"wo bei diaoyongle\");\n}\nvar a = new Boolean(true);\nString(a) // \"wo bei diaoyongle\" \"undefined\"\n\n```\n**（2）对象的转换规则**\n\n如果要将对象转为字符串，则是采用以下步骤。\n\n1. 先调用`toString`方法，如果toString方法返回的是简单类型(`Boolean`、`number`、`string`、`null`、`undefined`)的值，则对该值使用`String`方法，不再进行以下步骤。\n\n2. 如果`toString`方法返回的是复合类型的值，再调用`valueOf`方法，如果`valueOf`方法返回的是原始类型的值，则对该值使用String方法，不再进行以下步骤。\n\n3. 如果`valueOf`方法返回的是复合类型的值，则报错。\n\nString方法的这种过程正好与Number方法相反。\n\n```javascript\n\nString({a:1}) // \"[object Object]\"\n```\n\n上面代码相当于下面这样。\n\n```javascript\n\nString({a:1}.toString()) // \"[object Object]\"\n\n```\n\n如果toString方法和valueOf方法，返回的都不是原始类型的值，则String方法报错。\n```javascript\nvar  T = {toString:function(){return true},valueOf:function(){return undefined}};\nString(T) // \"true\" 调用toString\n\nvar  T = {toString:function(){return {}},valueOf:function(){return undefined}};\nString(T) // \"undefined\" 调用valueOf\n\nvar  T = {toString:function(){return {}},valueOf:function(){return {}}};\nString(T) // Error Uncaught TypeError: Cannot convert object to primitive value(…)\n\n```\n\n下面是一个自定义toString方法的例子。\n\n```javascript\n\nString({toString:function(){return 3;}}) // \"3\"\n\nString({valueOf:function (){return 2;}}) // \"[object Object]\"\n\nString({valueOf:function (){return 2;},toString:function(){return 3;}}) // \"3\"\n```\n\n上面代码对三个对象使用String方法。第一个对象返回toString方法的值（数值3），然后对其使用String方法，得到字符串“3”；第二个对象返回的还是toString方法的值（\"[object Object]\"），这次直接就是字符串；第三个对象表示toString方法先于valueOf方法执行。\n\n\n> ** 转自：** (阮一峰)[http://javascript.ruanyifeng.com/grammar/string.html]","slug":"好好学学String","published":1,"updated":"2016-02-03T08:10:14.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7r0000p543v6eayhyn4"},{"title":"好好学学Object!","date":"2016-02-03T08:09:30.000Z","comments":1,"_content":"## 概述\n\n### 定义方法\n\n对象（object）是JavaScript的核心概念，也是最重要的数据类型。JavaScript的所有数据都可以被视为对象。\n简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。\n<!--more-->\n\n```javascript\nvar o = {\n  'p': 'Hello World'\n};\n```\n\n上面代码中，大括号就定义了一个对象，它被赋值给变量`o`。这个对象内部包含一个键值对（又称为“成员”），`p`是“键名”（成员的名称），字符串“Hello World”是“键值”（成员的值）。键名与键值之间用冒号分隔。如果对象内部包含多个键值对，每个键值对之间用逗号分隔。\n\n### 键名\n\n对象的所有键名都是字符串，所以加不加引号都可以。上面的代码也可以写成下面这样。\n\n```javascript\nvar o = {\n  p: 'Hello World'\n};\n```\n\n但是，如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号。\n\n```javascript\nvar o = {\n  '1p': \"Hello World\",\n  'h w': \"Hello World\",\n  'p+q': \"Hello World\"\n};\n```\n\n上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。\n\n注意，JavaScript的保留字可以不加引号当作键名。\n\n```javascript\nvar obj = {\n  for: 1,\n  class: 2\n};\n```\n\n如果键名是数字，则会默认转为对应的字符串。\n\n```javascript\nvar obj = {\n  1e2: true,\n  1e-2: true,\n  .234: true,\n  0xFF: true,\n};\n\n//Obj =\n// {\n//   100: true,\n//   255: true,\n//   0.01: true,\n//   0.234: true\n// }\n```\n\n上面代码表示，如果键名为数值，则会先转为标准形式的数值，然后再转为字符串。\n\n### 属性\n\n对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。\n\n```javascript\nvar o = {\n  p: function(x) {\n   return 2 * x;\n  }\n};\n\no.p(1)\n// 2\n```\n\n上面的对象就有一个方法`p`，它就是一个函数。\n\n对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。\n\n```javascript\nvar o = {\n  p: 123,\n  m: function () { ... },//这个逗号不能加\n}\n```\n\n上面的代码中m属性后面的那个逗号，有或没有都不算错。但是，ECMAScript 3不允许添加逗号，所以如果要兼容老式浏览器（比如IE 8），那就不能加这个逗号。\n\n### 生成方法\n\n对象的生成方法，通常有三种方法。除了像上面那样直接使用大括号生成（`{}`），还可以用`new`命令生成一个Object对象的实例，或者使用`Object.create`方法生成。\n\n```javascript\nvar o1 = {};\nvar o2 = new Object();// 可以简写为 var o2 = new Object; 但是不推荐\nvar o3 = Object.create(null);\n```\n\n上面三行语句是等价的。一般来说，第一种采用大括号的写法比较简洁，第二种采用构造函数的写法清晰地表示了意图，第三种写法一般用在需要对象继承的场合。关于第二种写法，详见《标准库》一章的Object对象一节，第三种写法详见《面向对象编程》一章。\n\n### 读写属性\n\n**（1）读取属性**\n\n读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。\n\n```javascript\nvar o = {\n  p: 'Hello World'\n};\n\no.p // \"Hello World\"\no['p'] // \"Hello World\"\n```\n\n上面代码分别采用点运算符和方括号运算符，读取属性`p`。\n\n请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。\n\n```javascript\nvar o = {\n  0.7: \"Hello World\"\n};\n\no.['0.7'] // \"Hello World\"\no[0.7] // \"Hello World\"\n```\n\n方括号运算符内部可以使用表达式。\n\n```javascript\no['hello' + ' world']\no[3 + 3]\n```\n\n数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。\n\n```javascript\nobj.0xFF\n// SyntaxError: Unexpected token\nobj[0xFF]\n// true\n```\n\n上面代码的第一个表达式，对数值键名0xFF使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。\n\n**（2）检查变量是否声明**\n\n如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个变量是否被声明。\n\n```javascript\n// 检查a变量是否被声明\n\nif(a) {...} // 报错\n\nif(window.a) {...} // 不报错\nif(window['a']) {...} // 不报错\n```\n\n上面的后两种写法之所以不报错，是因为在浏览器环境，所有全局变量都是window对象的属性。`window.`的含义就是读取window对象的a属性，如果该属性不存在，就返回undefined，并不会报错。需要注意的是，后两种写法有漏洞，如果a属性值是一个空字符串（或其对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。\n正确的写法是使用`in`运算符，或者使用Object原型的方法`hasOwnProperty()`也就是Object原型。\n\n```javascript\nif('a' in window) {\n  ...\n}\n\nif(window.hasOwnProperty(\"a\")) {\n  ...\n}\n```\n\n**（3）写入属性**\n\n点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。\n\n```javascript\no.p = 'abc';\no['p'] = 'abc';\n```\n\n上面代码分别使用点运算符和方括号运算符，对属性p赋值。\n\nJavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。\n\n```javascript\nvar o = { p: 1 };\n\n// 等价于\n\nvar o = {};\no.p = 1;\n```\n\n**（4）查看所有属性**\n\n`Object.keys()` 方法会返回一个由给定对象的所有**可枚举自身属性的属性名组成的数组**，数组中属性名的排列顺序和使用`for-in`循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。\n支持：`IE9+`(包括IE9)。\n\n```javascript\nvar o = {\n  key1: 1,\n  key2: 2\n};\n\nObject.keys(o);\n// ['key1', 'key2']\n```\n兼容处理方案：\n```javascirpt\nif (!Object.keys) {\n    Object.keys = function(o) {\n        if (o !== Object(o)) {\n            throw new TypeError('Object.keys called on a non-object');\n        }\n        var k = [],\n            p;\n        for (p in o) {\n            if (Object.prototype.hasOwnProperty.call(o, p)) {\n                k.push(p);\n            }\n        }\n        return k;\n    }\n}\n```\n\n### 属性的删除\n\n删除一个属性，需要使用`delete`命令。\n\n```javascript\nvar o = {p: 1};\nObject.keys(o) // [\"p\"]\n\ndelete o.p // true\no.p // undefined\nObject.keys(o) // []\n```\n\n上面代码表示，一旦使用`delete`命令删除某个属性，再读取该属性就会返回`undefined`，而且`Object.keys`方法返回的该对象的所有属性中，也将不再包括该属性。\n\n<span style=\"color: red;\">麻烦的是，如果删除一个不存在的属性，delete不报错，而且返回true。</span>\n\n```javascript\nvar o = {};\ndelete o.p // true\n```\n\n上面代码表示，delete命令只能用来保证某个属性的值为undefined，而无法保证该属性是否真的存在。\n\n只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。\n\n```javascript\n\nvar o = Object.defineProperty({}, \"p\", {\n        value: 123,\n        configurable: false\n});\n\no.p // 123\ndelete o.p // false\n\n```\n\n上面代码之中，o对象的p属性是不能删除的，所以delete命令返回false（关于Object.defineProperty方法的介绍，请看《标准库》一章的Object对象章节）。\n\n另外，需要注意的是，delete命令只能删除对象本身的属性，不能删除继承的属性（关于继承参见《面向对象编程》一节）。delete命令也不能删除var命令声明的变量，只能用来删除属性。\n\n#### 以下这些都不能delete\n* ```javascript\n  function func() {\n    console.log(delete arguments);//false\n    console.log(Object.getOwnPropertyDescriptor(func,\"arguments\"));//{writable: false, enumerable: false, configurable: false}\n  }\n  func(1);\n  ```\n* var 声明的变量。\n* ```javascript\n  function func() {\n\n  }\n  delete func//false\n  Object.getOwnPropertyDescriptor(window,\"func\"); // {writable: true, enumerable: true, configurable: false}\n  ```\n* delete不能删除对象继承来自原型上的属性\n总结下：\n 1. 内置对象的属性及方法多数不能delete，保护该语言最核心API，这些API被delete了，基本上就废了。如delete Object.prototype。\n 2. 对象继承于原型的属性和方法不能delete是出于保护原型，否则 “类A的对象delete了原型上的属性，那么继承于A的都将丢失该属性”\n\n### 对象的引用\n\n如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。\n\n```javascript\nvar o1 = {};\nvar o2 = o1;\n\no1.a = 1;\no2.a // 1\n\no2.b = 2;\no1.b // 2\n```\n\n上面代码中，`o1`和`o2`指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。\n\n此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。\n\n```javascript\nvar o1 = {};\nvar o2 = o1;\n\no1 = 1;\no2 // {}\n```\n\n上面代码中，`o1`和`o2`指向同一个对象，然后`o1`的值变为1，这时不会对`o2`产生影响，`o2`还是指向原来的那个对象。\n\n但是，这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。\n\n```javascript\nvar x = 1;\nvar y = x;\n\nx = 2;\ny // 1\n```\n\n上面的代码中，当`x`的值发生变化后，`y`的值并不变，这就表示`y`和`x`并不是指向同一个内存地址。\n\n### `in`运算符\n\n1. in操作符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。\n\n```javascript\nvar o = { p: 1 };\n'p' in o // true\n```\n\n2. 在JavaScript语言中，所有全局变量都是顶层对象（浏览器的顶层对象就是`window`对象）的属性，因此可以用`in`运算符判断，一个全局变量是否存在。\n\n```javascript\n// 假设变量x未定义\n\n// 写法一：报错\nif (x) { return 1; }\n\n// 写法二：不正确\nif (window.x) { return 1; }\n\n// 写法三：正确\nif ('x' in window) { return 1; }\nif ( x in window) { return 1; } // 注意x要用引号包括起来，是字符串\n\n// 写法四： 正确\nif (window.hasOwnProperty('x')) { return 1; } // 注意x要用引号包括起来，是字符串\n```\n\n上面三种写法之中，如果`x`不存在，第一种写法会报错；如果`x`的值对应布尔值`false`（比如`x`等于空字符串），第二种写法无法得到正确结果；只有第三种、第四种写法，才能正确判断变量`x`是否存在。\n\n<span style=\"color: red;\">`in`运算符的一个问题是，它不能区分对象继承的属性。</span>\n\n```javascript\nvar o = new Object();\no.hasOwnProperty('toString') // false\n\n'toString' in o // true\n```\n\n上面代码中，`toString`方法不是对象`o`自身的属性，而是继承的属性，`hasOwnProperty`方法可以说明这一点。但是，`in`运算符不能区分，对继承的属性也返回`true`。\n3. in的右边必须是一个对象\n```javascript\nvar color1 = new String(\"green\");\n\"length\" in color1 // return true\nvar color2 = \"coral\";\n\"length\" in color2 // Uncaught TypeError: Cannot use 'in' operator to search for 'length' in coral(…)\n```\n4. 检验数组指定角标是否越界。\n```javascript\nvar trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");\n0 in trees        // returns true\n3 in trees        // returns true\n6 in trees        // returns false\n\"bay\" in trees    // returns false (you must specify the index number, not the value at that index)\n\"length\" in trees // returns true (length is an Array property)\n```\n5. 如果你使用`delete`操作符删除了一个属性，再次用in检查时，会返回false，如：\n```javascript\nvar mycar = {make: \"Honda\", model: \"Accord\", year: 1998};\nmycar.make = undefined;\n\"make\" in mycar;  // return true\ndelete mycar.Accord;\n\"Accord\" in mycar;  // return false\n \n\nvar trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");\ntrees[3] = undefined;\n3 in trees; // return true\ndelete trees[2];\n2 in trees; // return false\n```\n6. 如果一个属性是从原型链上继承来的，in 运算符也会返回 true。\n```javascript\n\"toString\" in {}; // 返回true\n```\n### for...in循环\nfor...in 循环不遍历不可枚举属性。使用内建构造器例如 Array 和 Object 创建的对象拥有从 Object.prototype 和 String.prototype 继承的不可枚举属性，例如 String 的 indexOf()  方法或者 Object 的 toString 方法。循环将迭代对象的所有可枚举属性，包括从它的构造函数的 prototype 继承而来的（包括被覆盖的内建属性）。\n** 删除，添加或者修改属性 **\nfor...in 循环以任意序迭代一个对象的属性。通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。\n\n** Array 迭代和 for...in **\n数组索引仅是可枚举的整数名，其他方面和别的普通对象属性没有什么区别。for...in 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的。因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。 因此当迭代那些访问次序重要的 arrays 时用整数索引去进行 for 循环 (或者使用 Array.prototype.forEach() 或 for...of 循环) 。\n\n** 仅迭代自身的属性 **\n如果你只要考虑对象本身的属性，而不是它的原型，那么使用 `getOwnPropertyNames()`(自身的可枚举和不可枚举属性都能获得) 或执行  `hasOwnProperty()` 来确定某属性是否是对象本身的属性 (也能使用`propertyIsEnumerable`)。另外，如果你知道外部不存在任何的干扰代码，你可以扩展内置原型与检查方法。\n```javascript\nvar o = {a: 1, b: 2, c: 3};\n\nfor (i in o){\n  console.log(o[i]);\n}\n// 1\n// 2\n// 3\n```\n\n下面是一个使用`for...in`循环，进行数组赋值的例子。\n\n```javascript\nvar props = [], i = 0;\n\nfor (props[i++] in {x: 1, y: 2});//循环执行的时候会给每一个变量(`props[i++]`)赋`{x: 1, y: 2}`的属性值。\n\nprops // ['x', 'y']\n```\n\n注意，`for...in`循环遍历的是对象所有可`enumberable`的属性(属性特性`[[enumberable]]`为`true`)，其中不仅包括定义在对象本身的属性，还包括对象继承的属性。\n> 属性特性 `enumerable` 定义了对象的属性是否可以在 `for...in` 循环和 `Object.keys()` 中被枚举。\n```javascript\n// name 是 Person 本身的属性\nfunction Person(name) {\n  this.name = name;\n}\n\n// describe是Person.prototype的属性\nPerson.prototype.describe = function () {\n  return 'Name: '+this.name;\n};\n\nvar person = new Person('Jane');\n\n// for...in循环会遍历实例自身的属性（name），\n// 以及继承的属性（describe）\nfor (var key in person) {\n  console.log(key);\n}\n// name\n// describe\n```\n\n上面代码中，`name`是对象本身的属性，`describe`是对象继承的属性，`for...in`循环的遍历会包括这两者。\n\n如果只想遍历对象本身的属性，可以使用hasOwnProperty方法，在循环内部做一个判断。\n\n```javascript\nfor (var key in person) {\n  if (person.hasOwnProperty(key)) {\n    console.log(key);\n  }\n}\n// name\n```\n\n为了避免这一点，可以新建一个继承`null`的对象。由于`null`没有任何属性，所以新对象也就不会有继承的属性了。\n\n## with语句\n\nwith语句的格式如下：\n\n```javascript\n\nwith (object)\n  statement\n\n```\n\n它的作用是操作同一个对象的多个属性时，提供一些书写的方便。\n\n```javascript\n\n// 例一\nwith (o) {\n  p1 = 1;\n  p2 = 2;\n}\n\n// 等同于\n\no.p1 = 1;\no.p2 = 2;\n\n// 例二\nwith (document.links[0]){\n  console.log(href);\n  console.log(title);\n  console.log(style);\n}\n\n// 等同于\n\nconsole.log(document.links[0].href);\nconsole.log(document.links[0].title);\nconsole.log(document.links[0].style);\n\n```\n\n注意，with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。\n\n```javascript\n\nvar o = {};\n\nwith (o){\n  x = \"abc\";\n}\n\no.x\n// undefined\n\nx\n// \"abc\"\n\n```\n\n上面代码中，对象o没有属性x，所以with区块内部对x的操作，等于创造了一个全局变量x。正确的写法应该是，先定义对象o的属性x，然后在with区块内操作它。\n\n```javascript\n\nvar o = {};\n\no.x = 1;\n\nwith (o){\n  x = 2;\n}\n\no.x\n// 2\n\n```\n\n这是with语句的一个很大的弊病，就是绑定对象不明确。\n\n```javascript\n\nwith (o) {\n  console.log(x);\n}\n\n```\n\n单纯从上面的代码块，根本无法判断x到底是全局变量，还是o对象的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。\n\n```javascript\n\nwith(o1.o2.o3) {\n  console.log(p1 + p2);\n}\n\n// 可以写成\n\nvar temp = o1.o2.o3;\nconsole.log(temp.p1 + temp.p2);\n\n```\n\nwith语句少数有用场合之一，就是替换模板变量。\n\n```javascript\nvar str = 'Hello <%= name %>!';\n```\n\n上面代码是一个模板字符串，为了替换其中的变量name，可以先将其分解成三部分`'Hello ', name, '!'`，然后进行模板变量替换。\n\n```javascript\n\nvar o = {\n  name: 'Alice'\n};\n\nvar p = [];\nvar tmpl = '';\n\nwith(o){\n  p.push('Hello ', name, '!');\n};\n\np.join('') // \"Hello Alice!\"\n```\n\n上面代码中，with区块内部，模板变量name可以被对象o的属性替换，而p依然是全局变量。事实上，这就是很多模板引擎的实现原理。\n\n## Object 简介\n\nJavaScript原生提供一个Object对象（注意起首的O是大写），所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。\nObject 的每个实例也就是Object原型 prototype 具有下列属性和方法：\n```javascript\nvar o = new Object; // 有效，但不推荐省略圆括号\n```\n* `constructor`：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（`constructor`）就是Object()。\n* `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(\"name\")）。\n* `isPrototypeOf(object)`：用于检查传入的对象是否是传入对象的原型（第5章将讨论原型）。\n* `propertyIsEnumerable(propertyName)`：用于检查给定的属性是否能够使用for-in 语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。\n `propertyIsEnumerable()`方法的返回值为Boolean类型，该值指示指定属性是否为对象的一部分以及该属性是否是可枚举的(只有这两个条件同时满足才返回`true`)。如果propertyName存在于object中且可以使用for...in循环遍历出来，则`propertyIsEnumerable()`方法将返回`true`。如果object不具有所指定名称的属性或者所指定的属性不是可枚举的，则`propertyIsEnumerable()`方法将返回`false`。\n 通常，预定义的属性不是可枚举的，而用户定义的属性总是可枚举的。不过有些属性虽然可以通过`for...in`循环遍历到，但因为它们不是自身属性，而是从原型链上继承的属性，所以该方法也会返回`false`。\n* `toLocaleString()`：返回对象的字符串表示，该字符串与执行环境的地区对应。\n* `toString()`：返回对象的字符串表示。\n* `valueOf()`：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。\n* `__defineGetter__()`\n* `__defineSetter__()`\n* `__lookupGetter__()`\n* `__lookupSetter__()`\n* `get __proto__()` //不可被显示调用(`.`出来)\n* `set __proto__()` //不可被显示调用(`.`出来)\n\n还有一些其他方法据各个浏览器厂商的实现来定，比如firefox还有`toSource()`、`watch()`、 `unwatch()`，这些内容不做过多介绍，毕竟不是标准。后面将会对这些方法做详细介绍。\n> [阮一峰](http://javascript.ruanyifeng.com/)","source":"_posts/好好学学Object-2016-02-03.md","raw":"title: 好好学学Object!\ndate: 2016-02-03 16:09:30\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n## 概述\n\n### 定义方法\n\n对象（object）是JavaScript的核心概念，也是最重要的数据类型。JavaScript的所有数据都可以被视为对象。\n简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。\n<!--more-->\n\n```javascript\nvar o = {\n  'p': 'Hello World'\n};\n```\n\n上面代码中，大括号就定义了一个对象，它被赋值给变量`o`。这个对象内部包含一个键值对（又称为“成员”），`p`是“键名”（成员的名称），字符串“Hello World”是“键值”（成员的值）。键名与键值之间用冒号分隔。如果对象内部包含多个键值对，每个键值对之间用逗号分隔。\n\n### 键名\n\n对象的所有键名都是字符串，所以加不加引号都可以。上面的代码也可以写成下面这样。\n\n```javascript\nvar o = {\n  p: 'Hello World'\n};\n```\n\n但是，如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号。\n\n```javascript\nvar o = {\n  '1p': \"Hello World\",\n  'h w': \"Hello World\",\n  'p+q': \"Hello World\"\n};\n```\n\n上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。\n\n注意，JavaScript的保留字可以不加引号当作键名。\n\n```javascript\nvar obj = {\n  for: 1,\n  class: 2\n};\n```\n\n如果键名是数字，则会默认转为对应的字符串。\n\n```javascript\nvar obj = {\n  1e2: true,\n  1e-2: true,\n  .234: true,\n  0xFF: true,\n};\n\n//Obj =\n// {\n//   100: true,\n//   255: true,\n//   0.01: true,\n//   0.234: true\n// }\n```\n\n上面代码表示，如果键名为数值，则会先转为标准形式的数值，然后再转为字符串。\n\n### 属性\n\n对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。\n\n```javascript\nvar o = {\n  p: function(x) {\n   return 2 * x;\n  }\n};\n\no.p(1)\n// 2\n```\n\n上面的对象就有一个方法`p`，它就是一个函数。\n\n对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。\n\n```javascript\nvar o = {\n  p: 123,\n  m: function () { ... },//这个逗号不能加\n}\n```\n\n上面的代码中m属性后面的那个逗号，有或没有都不算错。但是，ECMAScript 3不允许添加逗号，所以如果要兼容老式浏览器（比如IE 8），那就不能加这个逗号。\n\n### 生成方法\n\n对象的生成方法，通常有三种方法。除了像上面那样直接使用大括号生成（`{}`），还可以用`new`命令生成一个Object对象的实例，或者使用`Object.create`方法生成。\n\n```javascript\nvar o1 = {};\nvar o2 = new Object();// 可以简写为 var o2 = new Object; 但是不推荐\nvar o3 = Object.create(null);\n```\n\n上面三行语句是等价的。一般来说，第一种采用大括号的写法比较简洁，第二种采用构造函数的写法清晰地表示了意图，第三种写法一般用在需要对象继承的场合。关于第二种写法，详见《标准库》一章的Object对象一节，第三种写法详见《面向对象编程》一章。\n\n### 读写属性\n\n**（1）读取属性**\n\n读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。\n\n```javascript\nvar o = {\n  p: 'Hello World'\n};\n\no.p // \"Hello World\"\no['p'] // \"Hello World\"\n```\n\n上面代码分别采用点运算符和方括号运算符，读取属性`p`。\n\n请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。\n\n```javascript\nvar o = {\n  0.7: \"Hello World\"\n};\n\no.['0.7'] // \"Hello World\"\no[0.7] // \"Hello World\"\n```\n\n方括号运算符内部可以使用表达式。\n\n```javascript\no['hello' + ' world']\no[3 + 3]\n```\n\n数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。\n\n```javascript\nobj.0xFF\n// SyntaxError: Unexpected token\nobj[0xFF]\n// true\n```\n\n上面代码的第一个表达式，对数值键名0xFF使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。\n\n**（2）检查变量是否声明**\n\n如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个变量是否被声明。\n\n```javascript\n// 检查a变量是否被声明\n\nif(a) {...} // 报错\n\nif(window.a) {...} // 不报错\nif(window['a']) {...} // 不报错\n```\n\n上面的后两种写法之所以不报错，是因为在浏览器环境，所有全局变量都是window对象的属性。`window.`的含义就是读取window对象的a属性，如果该属性不存在，就返回undefined，并不会报错。需要注意的是，后两种写法有漏洞，如果a属性值是一个空字符串（或其对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。\n正确的写法是使用`in`运算符，或者使用Object原型的方法`hasOwnProperty()`也就是Object原型。\n\n```javascript\nif('a' in window) {\n  ...\n}\n\nif(window.hasOwnProperty(\"a\")) {\n  ...\n}\n```\n\n**（3）写入属性**\n\n点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。\n\n```javascript\no.p = 'abc';\no['p'] = 'abc';\n```\n\n上面代码分别使用点运算符和方括号运算符，对属性p赋值。\n\nJavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。\n\n```javascript\nvar o = { p: 1 };\n\n// 等价于\n\nvar o = {};\no.p = 1;\n```\n\n**（4）查看所有属性**\n\n`Object.keys()` 方法会返回一个由给定对象的所有**可枚举自身属性的属性名组成的数组**，数组中属性名的排列顺序和使用`for-in`循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。\n支持：`IE9+`(包括IE9)。\n\n```javascript\nvar o = {\n  key1: 1,\n  key2: 2\n};\n\nObject.keys(o);\n// ['key1', 'key2']\n```\n兼容处理方案：\n```javascirpt\nif (!Object.keys) {\n    Object.keys = function(o) {\n        if (o !== Object(o)) {\n            throw new TypeError('Object.keys called on a non-object');\n        }\n        var k = [],\n            p;\n        for (p in o) {\n            if (Object.prototype.hasOwnProperty.call(o, p)) {\n                k.push(p);\n            }\n        }\n        return k;\n    }\n}\n```\n\n### 属性的删除\n\n删除一个属性，需要使用`delete`命令。\n\n```javascript\nvar o = {p: 1};\nObject.keys(o) // [\"p\"]\n\ndelete o.p // true\no.p // undefined\nObject.keys(o) // []\n```\n\n上面代码表示，一旦使用`delete`命令删除某个属性，再读取该属性就会返回`undefined`，而且`Object.keys`方法返回的该对象的所有属性中，也将不再包括该属性。\n\n<span style=\"color: red;\">麻烦的是，如果删除一个不存在的属性，delete不报错，而且返回true。</span>\n\n```javascript\nvar o = {};\ndelete o.p // true\n```\n\n上面代码表示，delete命令只能用来保证某个属性的值为undefined，而无法保证该属性是否真的存在。\n\n只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。\n\n```javascript\n\nvar o = Object.defineProperty({}, \"p\", {\n        value: 123,\n        configurable: false\n});\n\no.p // 123\ndelete o.p // false\n\n```\n\n上面代码之中，o对象的p属性是不能删除的，所以delete命令返回false（关于Object.defineProperty方法的介绍，请看《标准库》一章的Object对象章节）。\n\n另外，需要注意的是，delete命令只能删除对象本身的属性，不能删除继承的属性（关于继承参见《面向对象编程》一节）。delete命令也不能删除var命令声明的变量，只能用来删除属性。\n\n#### 以下这些都不能delete\n* ```javascript\n  function func() {\n    console.log(delete arguments);//false\n    console.log(Object.getOwnPropertyDescriptor(func,\"arguments\"));//{writable: false, enumerable: false, configurable: false}\n  }\n  func(1);\n  ```\n* var 声明的变量。\n* ```javascript\n  function func() {\n\n  }\n  delete func//false\n  Object.getOwnPropertyDescriptor(window,\"func\"); // {writable: true, enumerable: true, configurable: false}\n  ```\n* delete不能删除对象继承来自原型上的属性\n总结下：\n 1. 内置对象的属性及方法多数不能delete，保护该语言最核心API，这些API被delete了，基本上就废了。如delete Object.prototype。\n 2. 对象继承于原型的属性和方法不能delete是出于保护原型，否则 “类A的对象delete了原型上的属性，那么继承于A的都将丢失该属性”\n\n### 对象的引用\n\n如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。\n\n```javascript\nvar o1 = {};\nvar o2 = o1;\n\no1.a = 1;\no2.a // 1\n\no2.b = 2;\no1.b // 2\n```\n\n上面代码中，`o1`和`o2`指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。\n\n此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。\n\n```javascript\nvar o1 = {};\nvar o2 = o1;\n\no1 = 1;\no2 // {}\n```\n\n上面代码中，`o1`和`o2`指向同一个对象，然后`o1`的值变为1，这时不会对`o2`产生影响，`o2`还是指向原来的那个对象。\n\n但是，这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。\n\n```javascript\nvar x = 1;\nvar y = x;\n\nx = 2;\ny // 1\n```\n\n上面的代码中，当`x`的值发生变化后，`y`的值并不变，这就表示`y`和`x`并不是指向同一个内存地址。\n\n### `in`运算符\n\n1. in操作符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。\n\n```javascript\nvar o = { p: 1 };\n'p' in o // true\n```\n\n2. 在JavaScript语言中，所有全局变量都是顶层对象（浏览器的顶层对象就是`window`对象）的属性，因此可以用`in`运算符判断，一个全局变量是否存在。\n\n```javascript\n// 假设变量x未定义\n\n// 写法一：报错\nif (x) { return 1; }\n\n// 写法二：不正确\nif (window.x) { return 1; }\n\n// 写法三：正确\nif ('x' in window) { return 1; }\nif ( x in window) { return 1; } // 注意x要用引号包括起来，是字符串\n\n// 写法四： 正确\nif (window.hasOwnProperty('x')) { return 1; } // 注意x要用引号包括起来，是字符串\n```\n\n上面三种写法之中，如果`x`不存在，第一种写法会报错；如果`x`的值对应布尔值`false`（比如`x`等于空字符串），第二种写法无法得到正确结果；只有第三种、第四种写法，才能正确判断变量`x`是否存在。\n\n<span style=\"color: red;\">`in`运算符的一个问题是，它不能区分对象继承的属性。</span>\n\n```javascript\nvar o = new Object();\no.hasOwnProperty('toString') // false\n\n'toString' in o // true\n```\n\n上面代码中，`toString`方法不是对象`o`自身的属性，而是继承的属性，`hasOwnProperty`方法可以说明这一点。但是，`in`运算符不能区分，对继承的属性也返回`true`。\n3. in的右边必须是一个对象\n```javascript\nvar color1 = new String(\"green\");\n\"length\" in color1 // return true\nvar color2 = \"coral\";\n\"length\" in color2 // Uncaught TypeError: Cannot use 'in' operator to search for 'length' in coral(…)\n```\n4. 检验数组指定角标是否越界。\n```javascript\nvar trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");\n0 in trees        // returns true\n3 in trees        // returns true\n6 in trees        // returns false\n\"bay\" in trees    // returns false (you must specify the index number, not the value at that index)\n\"length\" in trees // returns true (length is an Array property)\n```\n5. 如果你使用`delete`操作符删除了一个属性，再次用in检查时，会返回false，如：\n```javascript\nvar mycar = {make: \"Honda\", model: \"Accord\", year: 1998};\nmycar.make = undefined;\n\"make\" in mycar;  // return true\ndelete mycar.Accord;\n\"Accord\" in mycar;  // return false\n \n\nvar trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");\ntrees[3] = undefined;\n3 in trees; // return true\ndelete trees[2];\n2 in trees; // return false\n```\n6. 如果一个属性是从原型链上继承来的，in 运算符也会返回 true。\n```javascript\n\"toString\" in {}; // 返回true\n```\n### for...in循环\nfor...in 循环不遍历不可枚举属性。使用内建构造器例如 Array 和 Object 创建的对象拥有从 Object.prototype 和 String.prototype 继承的不可枚举属性，例如 String 的 indexOf()  方法或者 Object 的 toString 方法。循环将迭代对象的所有可枚举属性，包括从它的构造函数的 prototype 继承而来的（包括被覆盖的内建属性）。\n** 删除，添加或者修改属性 **\nfor...in 循环以任意序迭代一个对象的属性。通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。\n\n** Array 迭代和 for...in **\n数组索引仅是可枚举的整数名，其他方面和别的普通对象属性没有什么区别。for...in 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的。因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。 因此当迭代那些访问次序重要的 arrays 时用整数索引去进行 for 循环 (或者使用 Array.prototype.forEach() 或 for...of 循环) 。\n\n** 仅迭代自身的属性 **\n如果你只要考虑对象本身的属性，而不是它的原型，那么使用 `getOwnPropertyNames()`(自身的可枚举和不可枚举属性都能获得) 或执行  `hasOwnProperty()` 来确定某属性是否是对象本身的属性 (也能使用`propertyIsEnumerable`)。另外，如果你知道外部不存在任何的干扰代码，你可以扩展内置原型与检查方法。\n```javascript\nvar o = {a: 1, b: 2, c: 3};\n\nfor (i in o){\n  console.log(o[i]);\n}\n// 1\n// 2\n// 3\n```\n\n下面是一个使用`for...in`循环，进行数组赋值的例子。\n\n```javascript\nvar props = [], i = 0;\n\nfor (props[i++] in {x: 1, y: 2});//循环执行的时候会给每一个变量(`props[i++]`)赋`{x: 1, y: 2}`的属性值。\n\nprops // ['x', 'y']\n```\n\n注意，`for...in`循环遍历的是对象所有可`enumberable`的属性(属性特性`[[enumberable]]`为`true`)，其中不仅包括定义在对象本身的属性，还包括对象继承的属性。\n> 属性特性 `enumerable` 定义了对象的属性是否可以在 `for...in` 循环和 `Object.keys()` 中被枚举。\n```javascript\n// name 是 Person 本身的属性\nfunction Person(name) {\n  this.name = name;\n}\n\n// describe是Person.prototype的属性\nPerson.prototype.describe = function () {\n  return 'Name: '+this.name;\n};\n\nvar person = new Person('Jane');\n\n// for...in循环会遍历实例自身的属性（name），\n// 以及继承的属性（describe）\nfor (var key in person) {\n  console.log(key);\n}\n// name\n// describe\n```\n\n上面代码中，`name`是对象本身的属性，`describe`是对象继承的属性，`for...in`循环的遍历会包括这两者。\n\n如果只想遍历对象本身的属性，可以使用hasOwnProperty方法，在循环内部做一个判断。\n\n```javascript\nfor (var key in person) {\n  if (person.hasOwnProperty(key)) {\n    console.log(key);\n  }\n}\n// name\n```\n\n为了避免这一点，可以新建一个继承`null`的对象。由于`null`没有任何属性，所以新对象也就不会有继承的属性了。\n\n## with语句\n\nwith语句的格式如下：\n\n```javascript\n\nwith (object)\n  statement\n\n```\n\n它的作用是操作同一个对象的多个属性时，提供一些书写的方便。\n\n```javascript\n\n// 例一\nwith (o) {\n  p1 = 1;\n  p2 = 2;\n}\n\n// 等同于\n\no.p1 = 1;\no.p2 = 2;\n\n// 例二\nwith (document.links[0]){\n  console.log(href);\n  console.log(title);\n  console.log(style);\n}\n\n// 等同于\n\nconsole.log(document.links[0].href);\nconsole.log(document.links[0].title);\nconsole.log(document.links[0].style);\n\n```\n\n注意，with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。\n\n```javascript\n\nvar o = {};\n\nwith (o){\n  x = \"abc\";\n}\n\no.x\n// undefined\n\nx\n// \"abc\"\n\n```\n\n上面代码中，对象o没有属性x，所以with区块内部对x的操作，等于创造了一个全局变量x。正确的写法应该是，先定义对象o的属性x，然后在with区块内操作它。\n\n```javascript\n\nvar o = {};\n\no.x = 1;\n\nwith (o){\n  x = 2;\n}\n\no.x\n// 2\n\n```\n\n这是with语句的一个很大的弊病，就是绑定对象不明确。\n\n```javascript\n\nwith (o) {\n  console.log(x);\n}\n\n```\n\n单纯从上面的代码块，根本无法判断x到底是全局变量，还是o对象的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。\n\n```javascript\n\nwith(o1.o2.o3) {\n  console.log(p1 + p2);\n}\n\n// 可以写成\n\nvar temp = o1.o2.o3;\nconsole.log(temp.p1 + temp.p2);\n\n```\n\nwith语句少数有用场合之一，就是替换模板变量。\n\n```javascript\nvar str = 'Hello <%= name %>!';\n```\n\n上面代码是一个模板字符串，为了替换其中的变量name，可以先将其分解成三部分`'Hello ', name, '!'`，然后进行模板变量替换。\n\n```javascript\n\nvar o = {\n  name: 'Alice'\n};\n\nvar p = [];\nvar tmpl = '';\n\nwith(o){\n  p.push('Hello ', name, '!');\n};\n\np.join('') // \"Hello Alice!\"\n```\n\n上面代码中，with区块内部，模板变量name可以被对象o的属性替换，而p依然是全局变量。事实上，这就是很多模板引擎的实现原理。\n\n## Object 简介\n\nJavaScript原生提供一个Object对象（注意起首的O是大写），所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。\nObject 的每个实例也就是Object原型 prototype 具有下列属性和方法：\n```javascript\nvar o = new Object; // 有效，但不推荐省略圆括号\n```\n* `constructor`：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（`constructor`）就是Object()。\n* `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(\"name\")）。\n* `isPrototypeOf(object)`：用于检查传入的对象是否是传入对象的原型（第5章将讨论原型）。\n* `propertyIsEnumerable(propertyName)`：用于检查给定的属性是否能够使用for-in 语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。\n `propertyIsEnumerable()`方法的返回值为Boolean类型，该值指示指定属性是否为对象的一部分以及该属性是否是可枚举的(只有这两个条件同时满足才返回`true`)。如果propertyName存在于object中且可以使用for...in循环遍历出来，则`propertyIsEnumerable()`方法将返回`true`。如果object不具有所指定名称的属性或者所指定的属性不是可枚举的，则`propertyIsEnumerable()`方法将返回`false`。\n 通常，预定义的属性不是可枚举的，而用户定义的属性总是可枚举的。不过有些属性虽然可以通过`for...in`循环遍历到，但因为它们不是自身属性，而是从原型链上继承的属性，所以该方法也会返回`false`。\n* `toLocaleString()`：返回对象的字符串表示，该字符串与执行环境的地区对应。\n* `toString()`：返回对象的字符串表示。\n* `valueOf()`：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。\n* `__defineGetter__()`\n* `__defineSetter__()`\n* `__lookupGetter__()`\n* `__lookupSetter__()`\n* `get __proto__()` //不可被显示调用(`.`出来)\n* `set __proto__()` //不可被显示调用(`.`出来)\n\n还有一些其他方法据各个浏览器厂商的实现来定，比如firefox还有`toSource()`、`watch()`、 `unwatch()`，这些内容不做过多介绍，毕竟不是标准。后面将会对这些方法做详细介绍。\n> [阮一峰](http://javascript.ruanyifeng.com/)","slug":"好好学学Object","published":1,"updated":"2016-06-11T04:18:07.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7r6000s543vyu7wcyaz"},{"title":"严格模式","date":"2016-01-21T05:55:51.000Z","comments":1,"_content":"# 概述\nECMAScript 5 的严格模式是JavaScript中的一种限制性更强的变种方式。严格模式不是一个子集：它在语义上与正常代码有着明显的差异。不支持严格模式的浏览器与同支持严格模式的浏览器行为上也不一样， 所以不要在未经严格模式特性测试情况下使用严格模式。严格模式可以与非严格模式共存，所以脚本可以逐渐的选择性加入严格模式。\n支持情况：IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱。（github上面好多项目都是用的严格模式）\n严格模式在语义上与正常的JavaScript有一些不同。\n* 首先，严格模式会将JavaScript陷阱直接变成明显的错误。\n* 其次，严格模式修正了一些引擎难以优化的错误：同样的代码有些时候严格模式会比非严格模式下更快。\n* 第三，严格模式禁用了一些有可能在未来版本中定义的语法。\n<!--more-->\n# 开启严格模式\n严格模式可以应用到整个script标签或某个别函数中。不要在封闭大括弧（ {} ）内这样做，在这样的上下文中这么做是没有效果的。\n## 为某个script标签开启严格模式\n为整个script标签开启严格模式, 需要在所有语句之前放一个特定语句 `\"use strict\";` （或 `'use strict';`）。\n\n```javascript\n// 整个语句都开启严格模式的语法\n\"use strict\";\nvar v = \"Hi!  I'm a strict mode script!\";\n```\n如果你想定义一个模块或者一个小库，自然采用一个匿名函数自执行是不错的选择。同时解决了代码压缩产生的 `\"use strict\"`压缩后不在第一行的问题。\n\n```javascript\n~function() {\n    \"use strict\";    \n    // Define your library strictly...\n}();\n```\n`\"use strict\"` 的位置是很讲究的，必须在首部。首部指其前面没有任何有效js代码。以下都是无效的，将不会触发严格模式。\n* “use strict” 前有代码\n* “use strict” 前有个空语句都不行\n ```javascript\n    ;//空语句\n    'use strict'\n    globalVar = 100\n ```\n当然，“use strict”前加注释是可以的\n\n## 为某个函数开启严格模式\n      function strict() {\n        // 函数级别严格模式语法\n        'use strict';\n        function nested() {\n          return \"And so am I!\";\n        }\n        return \"Hi!  I'm a strict mode function!  \" + nested();\n      }\n## Chrome中调试严格模式\n我有这么一段代码：\n```javascript\n'use strict'\nname = \"reeoo\";\nconsole.log(name)\n```\n把这段代码直接粘贴到Chrome的控制台中执行，正常情况下应该报错，但是并没有报错。\n{% asset_img stracit.png %}\n很显然，严格模式下变量不适用var声明是不合法的，但是为什么没有报错？这是什么鬼，难道Chrome不支持严格模式？开什么玩笑。。。\n网上搜了一下，原来Chrome的控制台的代码是运行在eval之中的，你没法对eval函数使用严格模式（应该也不完全对，但是具体Chrome做了什么，不得而知），总之要想在Chrome浏览器中对严格模式正常报错，需要在代码外层套一个立即执行函数，或者其它类似的措施。\n```javascript\n(function(){\n    'use strict'\n    name = \"reeoo\";\n    console.log(name) \n})()\n```\n\n# 严格模式有哪些不同？\n* 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;(将问题直接转化为错误,如语法错误或运行时错误)。\n* 提高编译器效率，增加运行速度。\n* 消除代码运行的一些不安全之处，保证代码运行的安全。\n* 为未来新版本的Javascript做好铺垫。\n\n# 代码在严格模式下受到的限制\n## 全局变量显式声明\n在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n\n      \"use strict\";\n      mistypedVaraible = 17; // 报错，mistypedVaraible未声明\n## 静态绑定\nJavascript语言的一个特点，就是允许\"动态绑定\"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。\n具体来说，涉及以下几个方面。\n### 禁止使用with语句\n因为with语句无法在编译时就确定，属性到底归属哪个对象。\n\n    \"use strict\";\n    var x = 17;\n    with (obj) // !!! 语法错误\n    {\n      // 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？\n      // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\n      x;\n    }\n### 创设eval作用域\n正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。\n严格模式创设了第三种作用域：eval作用域。\n正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。\n严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。\n\n    \"use strict\";\n    eval(\"var testvar = 10\");\n    console.log(testvar);//在严格模式下报错，在非严格模式下 打印 10\n## 禁止删除变量\n严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。\n\n    \"use strict\";\n    var x;\n    delete x; // 语法错误\n\n    eval(\"var x; delete x;\"); // !!! 语法错误\n\n    var o = Object.create(null, {'x': {\n        value: 1,\n        configurable: true\n    }});\n    delete o.x; // 删除成功\n## 增强的安全措施\n### 禁止this关键字指向全局对象，默认值undefined\n\n    function f(){\n    　　return !this;\n    }\n    // 返回false，因为\"this\"指向全局对象，\"!this\"就是false\n    function f(){\n    　　\"use strict\";\n    　　return !this;\n    }\n    // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\n### caller/callee 被禁用\n\n    function parentCheck() {\n        check(\"\");\n        function check() {\n            subCheck();\n            function subCheck() {\n                console.log(arguments.caller);\n                // ECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined。定义这个属性是为了分清arguments.caller 和函数的caller 属性。\n                console.log(arguments.callee);\n                console.log(subCheck.caller);\n                console.log(subCheck.caller.caller);\n            }\n        }\n    }\n    parentCheck();\n    \n### 显式报错\nNaN 是一个不可写的全局变量. 在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常\n\n    \"use strict\";\n    NaN = 2;//报错\n正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.defineProperty(o, \"v\", {\n        value: 1,\n        writable: false\n    });　　\n    o.v = 2; // 报错\n严格模式下，对一个只有getter方法的属性进行赋值，会报错。\n\n    \"use strict\";\n    　\n    var o = {\n        　get v() {return 1; }　　\n    };　　\n    o.v = 2; // 报错\n\n如果有setter 则不会报错。\n\n    \"use strict\";　\n    var o = {\n    　　get v() {\n            return this.aa; \n        },\n        set v(a){\n            this.aa = a;\n        }    　\n    };　　\n    o.v = 2; // 不会报错\n    console.log(o.v);\n    \n严格模式下，对禁止扩展的对象添加新属性，会报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.preventExtensions(o);　　\n    o.v = 1; // 报错\n严格模式下，删除一个不可删除的属性，会报错。\n\n    \"use strict\";　　\n    delete Object.prototype; // 报错\n## 重名错误\n### 对象不能有重名的属性\n正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    var o = {　　　　\n        p: 1,\n        p: 2　　\n    }; // 语法错误\n### 函数不能有重名的参数\n正常模式下，如果函数有多个重名的形参，不会报错，在严格模式下，这属于语法错误。\n\n    ```javascript\n    \"use strict\";　　\n    function f(a, a, b) {\n        console.log(a,a,b);\n        // Duplicate parameter name not allowed in this context　\n        //正常模式 输出 1 2 3\n    }\n    f(1,2,3);\n    ```\n## 禁止八进制表示法\n正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。\n\n    \"use strict\";　　\n    var n = 0100; // 语法错误\n## eval和arguments对象的限制\n### 赋值和绑定\n首先, arguments, eval这两个在严格模式下不能做标识符或属性名\n\n    \"use strict\";\n    eval = 17;\n    arguments++;\n    ++eval;\n    var obj = { set p(arguments) { } };\n    var eval;\n    try { } catch (arguments) { }\n    function x(eval) { }\n    function arguments() { }\n    var y = function eval() { };\n    var f = new Function(\"arguments\", \"'use strict'; return 17;\");\n### arguments不再追踪参数的变化\n\n    function f(a) {　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 正常模式为[2,2]\n    　　\n    function f(a) {　　　　\n        \"use strict\";　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 严格模式为[2,1]\n### 禁止使用arguments.callee\n这意味着，你无法在匿名函数内部调用自身了，可以用命名函数表达式解决这个问题。\n\n    \"use strict\";　　\n    var f = function() {\n        return arguments.callee;\n    };　　\n    f(); // 报错\n## 函数必须声明在顶层\n将来Javascript的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n\n    \"use strict\";　　\n    if (true) {　　　　\n        function f() {} // 语法错误\n            　　\n    }　　\n    for (var i = 0; i < 5; i++) {　　　　\n        function f2() {} // 语法错误\n            　　\n    }\n\n## 保留字\n为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n使用这些词作为变量名将会报错。此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。\n\n# 向严格模式过度\n## 逐步过渡\n严格模式被仔细设计过，因此可以逐渐地进行迁移。你可以分别改变各个文件，甚至以函数级的粒度迁移至严格模式。\n## 过程\n如果代码中使用\"use strict\"开启了严格模式,则下面的情况都会在脚本运行之前抛出`SyntaxError`异常:\n### 语法错误\n\n* 八进制语法:var n = 023和var s = \"\\047\"\n* with语句\n* 使用delete删除一个变量名(而不是属性名):delete myVariable\n* 使用eval或arguments作为变量名或函数名\n* 使用未来保留字(也许会在ECMAScript 6中使用):implements, interface, let, package, private, protected, public, static,和yield作为变量名或函数名\n* 在语句块中使用函数声明:if(a<b){ function f(){} }\n* 其他错误:\n* * 对象子面量中使用两个相同的属性名:{a: 1, b: 3, a: 7}\n* * 函数形参中使用两个相同的参数名:function f(a, b, b){}\n\n这些错误是有利的，因为可以揭示简陋的错误和坏的实践，这些错误会在代码运行前被抛出。\n\n### 运行时错误\nJavaScript曾经会在一些上下文的某些情况中静默的失败，严格模式会在这些情况下抛出错误。如果你的代码包含这样的场景，请务必测试以确保没有代码受到影响。再说一次，严格模式是可以设置在代码粒度下的。\n\n1. 给一个未声明的变量赋值\n2. 改变一个全局对象的值可能会造成不可预期的后果。如果你真的想设置一个全局对象的值，把他作为一个参数并且明确的把它作为一个属性。\n          var global = this; // in the top-level context, \"this\" always refers the global object\n          function f() {\n              \"use strict\";\n              var a = 12;\n              global.b = a + x * 35;\n          }\n          f();\n·\n3. 尝试删除一个不可配置的属性。\n          \"use strict\";\n          delete Object.prototype; // error!\n   在非严格模式中,这样的代码只会静默失败,这样可能会导致用户误以为删除操作成功了.\n\n4. `arguments`对象和函数属性\n\n在严格模式下,访问`arguments.callee`, `arguments.caller`, `anyFunction.caller`以及`anyFunction.arguments`都会抛出异常.唯一合法的使用应该是在其中命名一个函数并且重用之\n\n### 语义差异\n1. 函数调用中的this\n在普通的函数调用f()中，this的值会指向全局对象。在严格模式中，this的值会指向undefined。当函数通过call和apply调用时，如果传入的\"thisvalue\"参数是一个null和undefined除外的原始值(字符串，数字，布尔值)，则this的值会成为那个原始值对应的包装对象，如果\"thisvalue\"参数的值是undefined或null，则this的值会指向全局对象。在严格模式中，this的值就是thisvalue参数的值，没有任何类型转换。\n2. arguments对象属性不与对应的形参变量同步更新\n在非严格模式中，修改arguments对象中某个索引属性的值，和这个属性对应的形参变量的值也会同时变化，反之亦然.这会让JavaScript的代码混淆引擎让代码变得更难读和理解。在严格模式中arguments 对象会以形参变量的拷贝的形式被创建和初始化，因此 arguments 对象的改变不会影响形参。\n3. eval相关的区别\n在严格模式中，eval不会在当前的作用域内创建新的变量。另外，传入eval的字符串参数也会按照严格模式来解析。你需要全面测试来确保没有代码收到影响。另外，如果你并不是为了解决一个非常实际的解决方案中，尽量不要使用eval。\n\n## 严格中立的代码\n迁移严格代码至严格模式的一个潜在消极面是，在遗留的老版本浏览器上，由于没有实现严格模式，javascript语义可能会有所不同。在一些罕见的机会下（比如差劲的关联关系或者代码最小化），你的代码可能不能按照你书写或者测试里的模式那样运行。这里有一些让你的代码保持中立的规范：\n1. 按照严格模式书写你的代码，并且确保你的代码不会发生仅仅在严格模式下发生的错误（比如上文所说的运行时错误）。\n2. 原理语义的歧义：\n * eval: 仅仅在你知道你在干什么的情况下使用它\n * arguments: 总是通过他们的名字访问函数的参数，或者作为参数对象的拷贝来使用: `var args = Array.prototype.slice.call(arguments)`，并且这样的代码应该在你的函数第一行\n * this: 只在它指向你之前创建的对象的情况下使用 this  \n\n>摘自：[MDN-严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)\n>摘自：[MDN-向严格模式过渡](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode)\n","source":"_posts/严格模式-2016-01-21.md","raw":"title: 严格模式\ndate: 2016-01-21 13:55:51\ntags:\n- jQuery\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# 概述\nECMAScript 5 的严格模式是JavaScript中的一种限制性更强的变种方式。严格模式不是一个子集：它在语义上与正常代码有着明显的差异。不支持严格模式的浏览器与同支持严格模式的浏览器行为上也不一样， 所以不要在未经严格模式特性测试情况下使用严格模式。严格模式可以与非严格模式共存，所以脚本可以逐渐的选择性加入严格模式。\n支持情况：IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱。（github上面好多项目都是用的严格模式）\n严格模式在语义上与正常的JavaScript有一些不同。\n* 首先，严格模式会将JavaScript陷阱直接变成明显的错误。\n* 其次，严格模式修正了一些引擎难以优化的错误：同样的代码有些时候严格模式会比非严格模式下更快。\n* 第三，严格模式禁用了一些有可能在未来版本中定义的语法。\n<!--more-->\n# 开启严格模式\n严格模式可以应用到整个script标签或某个别函数中。不要在封闭大括弧（ {} ）内这样做，在这样的上下文中这么做是没有效果的。\n## 为某个script标签开启严格模式\n为整个script标签开启严格模式, 需要在所有语句之前放一个特定语句 `\"use strict\";` （或 `'use strict';`）。\n\n```javascript\n// 整个语句都开启严格模式的语法\n\"use strict\";\nvar v = \"Hi!  I'm a strict mode script!\";\n```\n如果你想定义一个模块或者一个小库，自然采用一个匿名函数自执行是不错的选择。同时解决了代码压缩产生的 `\"use strict\"`压缩后不在第一行的问题。\n\n```javascript\n~function() {\n    \"use strict\";    \n    // Define your library strictly...\n}();\n```\n`\"use strict\"` 的位置是很讲究的，必须在首部。首部指其前面没有任何有效js代码。以下都是无效的，将不会触发严格模式。\n* “use strict” 前有代码\n* “use strict” 前有个空语句都不行\n ```javascript\n    ;//空语句\n    'use strict'\n    globalVar = 100\n ```\n当然，“use strict”前加注释是可以的\n\n## 为某个函数开启严格模式\n      function strict() {\n        // 函数级别严格模式语法\n        'use strict';\n        function nested() {\n          return \"And so am I!\";\n        }\n        return \"Hi!  I'm a strict mode function!  \" + nested();\n      }\n## Chrome中调试严格模式\n我有这么一段代码：\n```javascript\n'use strict'\nname = \"reeoo\";\nconsole.log(name)\n```\n把这段代码直接粘贴到Chrome的控制台中执行，正常情况下应该报错，但是并没有报错。\n{% asset_img stracit.png %}\n很显然，严格模式下变量不适用var声明是不合法的，但是为什么没有报错？这是什么鬼，难道Chrome不支持严格模式？开什么玩笑。。。\n网上搜了一下，原来Chrome的控制台的代码是运行在eval之中的，你没法对eval函数使用严格模式（应该也不完全对，但是具体Chrome做了什么，不得而知），总之要想在Chrome浏览器中对严格模式正常报错，需要在代码外层套一个立即执行函数，或者其它类似的措施。\n```javascript\n(function(){\n    'use strict'\n    name = \"reeoo\";\n    console.log(name) \n})()\n```\n\n# 严格模式有哪些不同？\n* 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;(将问题直接转化为错误,如语法错误或运行时错误)。\n* 提高编译器效率，增加运行速度。\n* 消除代码运行的一些不安全之处，保证代码运行的安全。\n* 为未来新版本的Javascript做好铺垫。\n\n# 代码在严格模式下受到的限制\n## 全局变量显式声明\n在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n\n      \"use strict\";\n      mistypedVaraible = 17; // 报错，mistypedVaraible未声明\n## 静态绑定\nJavascript语言的一个特点，就是允许\"动态绑定\"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。\n具体来说，涉及以下几个方面。\n### 禁止使用with语句\n因为with语句无法在编译时就确定，属性到底归属哪个对象。\n\n    \"use strict\";\n    var x = 17;\n    with (obj) // !!! 语法错误\n    {\n      // 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？\n      // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\n      x;\n    }\n### 创设eval作用域\n正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。\n严格模式创设了第三种作用域：eval作用域。\n正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。\n严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。\n\n    \"use strict\";\n    eval(\"var testvar = 10\");\n    console.log(testvar);//在严格模式下报错，在非严格模式下 打印 10\n## 禁止删除变量\n严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。\n\n    \"use strict\";\n    var x;\n    delete x; // 语法错误\n\n    eval(\"var x; delete x;\"); // !!! 语法错误\n\n    var o = Object.create(null, {'x': {\n        value: 1,\n        configurable: true\n    }});\n    delete o.x; // 删除成功\n## 增强的安全措施\n### 禁止this关键字指向全局对象，默认值undefined\n\n    function f(){\n    　　return !this;\n    }\n    // 返回false，因为\"this\"指向全局对象，\"!this\"就是false\n    function f(){\n    　　\"use strict\";\n    　　return !this;\n    }\n    // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\n### caller/callee 被禁用\n\n    function parentCheck() {\n        check(\"\");\n        function check() {\n            subCheck();\n            function subCheck() {\n                console.log(arguments.caller);\n                // ECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined。定义这个属性是为了分清arguments.caller 和函数的caller 属性。\n                console.log(arguments.callee);\n                console.log(subCheck.caller);\n                console.log(subCheck.caller.caller);\n            }\n        }\n    }\n    parentCheck();\n    \n### 显式报错\nNaN 是一个不可写的全局变量. 在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常\n\n    \"use strict\";\n    NaN = 2;//报错\n正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.defineProperty(o, \"v\", {\n        value: 1,\n        writable: false\n    });　　\n    o.v = 2; // 报错\n严格模式下，对一个只有getter方法的属性进行赋值，会报错。\n\n    \"use strict\";\n    　\n    var o = {\n        　get v() {return 1; }　　\n    };　　\n    o.v = 2; // 报错\n\n如果有setter 则不会报错。\n\n    \"use strict\";　\n    var o = {\n    　　get v() {\n            return this.aa; \n        },\n        set v(a){\n            this.aa = a;\n        }    　\n    };　　\n    o.v = 2; // 不会报错\n    console.log(o.v);\n    \n严格模式下，对禁止扩展的对象添加新属性，会报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.preventExtensions(o);　　\n    o.v = 1; // 报错\n严格模式下，删除一个不可删除的属性，会报错。\n\n    \"use strict\";　　\n    delete Object.prototype; // 报错\n## 重名错误\n### 对象不能有重名的属性\n正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    var o = {　　　　\n        p: 1,\n        p: 2　　\n    }; // 语法错误\n### 函数不能有重名的参数\n正常模式下，如果函数有多个重名的形参，不会报错，在严格模式下，这属于语法错误。\n\n    ```javascript\n    \"use strict\";　　\n    function f(a, a, b) {\n        console.log(a,a,b);\n        // Duplicate parameter name not allowed in this context　\n        //正常模式 输出 1 2 3\n    }\n    f(1,2,3);\n    ```\n## 禁止八进制表示法\n正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。\n\n    \"use strict\";　　\n    var n = 0100; // 语法错误\n## eval和arguments对象的限制\n### 赋值和绑定\n首先, arguments, eval这两个在严格模式下不能做标识符或属性名\n\n    \"use strict\";\n    eval = 17;\n    arguments++;\n    ++eval;\n    var obj = { set p(arguments) { } };\n    var eval;\n    try { } catch (arguments) { }\n    function x(eval) { }\n    function arguments() { }\n    var y = function eval() { };\n    var f = new Function(\"arguments\", \"'use strict'; return 17;\");\n### arguments不再追踪参数的变化\n\n    function f(a) {　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 正常模式为[2,2]\n    　　\n    function f(a) {　　　　\n        \"use strict\";　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 严格模式为[2,1]\n### 禁止使用arguments.callee\n这意味着，你无法在匿名函数内部调用自身了，可以用命名函数表达式解决这个问题。\n\n    \"use strict\";　　\n    var f = function() {\n        return arguments.callee;\n    };　　\n    f(); // 报错\n## 函数必须声明在顶层\n将来Javascript的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n\n    \"use strict\";　　\n    if (true) {　　　　\n        function f() {} // 语法错误\n            　　\n    }　　\n    for (var i = 0; i < 5; i++) {　　　　\n        function f2() {} // 语法错误\n            　　\n    }\n\n## 保留字\n为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n使用这些词作为变量名将会报错。此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。\n\n# 向严格模式过度\n## 逐步过渡\n严格模式被仔细设计过，因此可以逐渐地进行迁移。你可以分别改变各个文件，甚至以函数级的粒度迁移至严格模式。\n## 过程\n如果代码中使用\"use strict\"开启了严格模式,则下面的情况都会在脚本运行之前抛出`SyntaxError`异常:\n### 语法错误\n\n* 八进制语法:var n = 023和var s = \"\\047\"\n* with语句\n* 使用delete删除一个变量名(而不是属性名):delete myVariable\n* 使用eval或arguments作为变量名或函数名\n* 使用未来保留字(也许会在ECMAScript 6中使用):implements, interface, let, package, private, protected, public, static,和yield作为变量名或函数名\n* 在语句块中使用函数声明:if(a<b){ function f(){} }\n* 其他错误:\n* * 对象子面量中使用两个相同的属性名:{a: 1, b: 3, a: 7}\n* * 函数形参中使用两个相同的参数名:function f(a, b, b){}\n\n这些错误是有利的，因为可以揭示简陋的错误和坏的实践，这些错误会在代码运行前被抛出。\n\n### 运行时错误\nJavaScript曾经会在一些上下文的某些情况中静默的失败，严格模式会在这些情况下抛出错误。如果你的代码包含这样的场景，请务必测试以确保没有代码受到影响。再说一次，严格模式是可以设置在代码粒度下的。\n\n1. 给一个未声明的变量赋值\n2. 改变一个全局对象的值可能会造成不可预期的后果。如果你真的想设置一个全局对象的值，把他作为一个参数并且明确的把它作为一个属性。\n          var global = this; // in the top-level context, \"this\" always refers the global object\n          function f() {\n              \"use strict\";\n              var a = 12;\n              global.b = a + x * 35;\n          }\n          f();\n·\n3. 尝试删除一个不可配置的属性。\n          \"use strict\";\n          delete Object.prototype; // error!\n   在非严格模式中,这样的代码只会静默失败,这样可能会导致用户误以为删除操作成功了.\n\n4. `arguments`对象和函数属性\n\n在严格模式下,访问`arguments.callee`, `arguments.caller`, `anyFunction.caller`以及`anyFunction.arguments`都会抛出异常.唯一合法的使用应该是在其中命名一个函数并且重用之\n\n### 语义差异\n1. 函数调用中的this\n在普通的函数调用f()中，this的值会指向全局对象。在严格模式中，this的值会指向undefined。当函数通过call和apply调用时，如果传入的\"thisvalue\"参数是一个null和undefined除外的原始值(字符串，数字，布尔值)，则this的值会成为那个原始值对应的包装对象，如果\"thisvalue\"参数的值是undefined或null，则this的值会指向全局对象。在严格模式中，this的值就是thisvalue参数的值，没有任何类型转换。\n2. arguments对象属性不与对应的形参变量同步更新\n在非严格模式中，修改arguments对象中某个索引属性的值，和这个属性对应的形参变量的值也会同时变化，反之亦然.这会让JavaScript的代码混淆引擎让代码变得更难读和理解。在严格模式中arguments 对象会以形参变量的拷贝的形式被创建和初始化，因此 arguments 对象的改变不会影响形参。\n3. eval相关的区别\n在严格模式中，eval不会在当前的作用域内创建新的变量。另外，传入eval的字符串参数也会按照严格模式来解析。你需要全面测试来确保没有代码收到影响。另外，如果你并不是为了解决一个非常实际的解决方案中，尽量不要使用eval。\n\n## 严格中立的代码\n迁移严格代码至严格模式的一个潜在消极面是，在遗留的老版本浏览器上，由于没有实现严格模式，javascript语义可能会有所不同。在一些罕见的机会下（比如差劲的关联关系或者代码最小化），你的代码可能不能按照你书写或者测试里的模式那样运行。这里有一些让你的代码保持中立的规范：\n1. 按照严格模式书写你的代码，并且确保你的代码不会发生仅仅在严格模式下发生的错误（比如上文所说的运行时错误）。\n2. 原理语义的歧义：\n * eval: 仅仅在你知道你在干什么的情况下使用它\n * arguments: 总是通过他们的名字访问函数的参数，或者作为参数对象的拷贝来使用: `var args = Array.prototype.slice.call(arguments)`，并且这样的代码应该在你的函数第一行\n * this: 只在它指向你之前创建的对象的情况下使用 this  \n\n>摘自：[MDN-严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)\n>摘自：[MDN-向严格模式过渡](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode)\n","slug":"严格模式","published":1,"updated":"2016-06-07T14:48:37.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7rb000v543vr5r2t1q6"},{"title":"webkit的预加载扫描器","date":"2016-01-19T12:33:09.000Z","comments":1,"_content":"在WebKit中，预加载扫描器指的是一个副解析器，当HTML主解析器被一个同步的script标签阻塞时，预加载扫描器就会启动.然后，它会马上找出接下来即将需要获取的资源(比如样式表，脚本，图片等资源)的URL，然后尽可能早的发起网络请求，而不用等到主解析器恢复运行，从而提高了整体的加载时间。那么，除了HTML文件中的依赖资源，还有样式表中的呢?幸运的是，WebKit已经有了一个叫CSS预加载扫描器的东西了。\n<!--more-->\n在WebKit实现符合HTML5标准的解析器的时候，预加载扫描器被分成了两部分。其中大部分代码分出来成为了HTML预加载扫描器，剩下的一小部分成为了独立的CSS预加载扫描器。CSS预加载扫描器的任务是扫描并尽早加载样式表(且只能是style标签中内联的样式表)中的外部资源。目前，它只能扫描到@import规则中用到的外部资源。\n\n让我们看看下面这个示例，在这个代码片段中(只为演示使用，代码并不符合最佳实践)，有一个script标签和一个style标签:\n\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <script>\n    setTimeout(function () {\n        document.title = document.title\n    }， 1000);\n    </script>\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <style>\n    @import url(\"another-style.css\");\n    body {\n        background-color: white\n    }\n    </style>\n\n当执行到那个同步的script标签时，WebKit解析器会就会启动CSS预加载扫描器.预加载扫描器会快速的找到@import后面的URL，然后下载这个another-style.css文件。\n\nCSS预加载扫描器是非常简单的，因为它不需要解析所有的CSS语法，其中还有一个专门的代码优化，就是如果发现没有@import，扫描器会尽快跳出这个样式表，这样就能在CSS文件很大的时候节约对CPU的消耗。\n\n很多人不推荐使用@import(比如Steve Souder的不要使用@import一文)。随着现在以及未来对浏览器引擎的不断改进，这条最佳实践应该时不时的被重新考量了。当然，我并不推荐在你的网站上到处乱用@import.使用一些调试工具来分析页面的网络性能，然后你就能得出一个明智的决定。\n\n**注:**特别感谢Google的Ilya Grigorik帮我审查这篇文章。\n\n引自：[紫云飞](http://www.cnblogs.com/ziyunfei/archive/2013/04/11/3014430.html?utm_source=tuicool&utm_medium=referral)\n","source":"_posts/webkit的预加载扫描器-2016-01-19.md","raw":"title: webkit的预加载扫描器\ndate: 2016-01-19 20:33:09\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n在WebKit中，预加载扫描器指的是一个副解析器，当HTML主解析器被一个同步的script标签阻塞时，预加载扫描器就会启动.然后，它会马上找出接下来即将需要获取的资源(比如样式表，脚本，图片等资源)的URL，然后尽可能早的发起网络请求，而不用等到主解析器恢复运行，从而提高了整体的加载时间。那么，除了HTML文件中的依赖资源，还有样式表中的呢?幸运的是，WebKit已经有了一个叫CSS预加载扫描器的东西了。\n<!--more-->\n在WebKit实现符合HTML5标准的解析器的时候，预加载扫描器被分成了两部分。其中大部分代码分出来成为了HTML预加载扫描器，剩下的一小部分成为了独立的CSS预加载扫描器。CSS预加载扫描器的任务是扫描并尽早加载样式表(且只能是style标签中内联的样式表)中的外部资源。目前，它只能扫描到@import规则中用到的外部资源。\n\n让我们看看下面这个示例，在这个代码片段中(只为演示使用，代码并不符合最佳实践)，有一个script标签和一个style标签:\n\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <script>\n    setTimeout(function () {\n        document.title = document.title\n    }， 1000);\n    </script>\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <style>\n    @import url(\"another-style.css\");\n    body {\n        background-color: white\n    }\n    </style>\n\n当执行到那个同步的script标签时，WebKit解析器会就会启动CSS预加载扫描器.预加载扫描器会快速的找到@import后面的URL，然后下载这个another-style.css文件。\n\nCSS预加载扫描器是非常简单的，因为它不需要解析所有的CSS语法，其中还有一个专门的代码优化，就是如果发现没有@import，扫描器会尽快跳出这个样式表，这样就能在CSS文件很大的时候节约对CPU的消耗。\n\n很多人不推荐使用@import(比如Steve Souder的不要使用@import一文)。随着现在以及未来对浏览器引擎的不断改进，这条最佳实践应该时不时的被重新考量了。当然，我并不推荐在你的网站上到处乱用@import.使用一些调试工具来分析页面的网络性能，然后你就能得出一个明智的决定。\n\n**注:**特别感谢Google的Ilya Grigorik帮我审查这篇文章。\n\n引自：[紫云飞](http://www.cnblogs.com/ziyunfei/archive/2013/04/11/3014430.html?utm_source=tuicool&utm_medium=referral)\n","slug":"webkit的预加载扫描器","published":1,"updated":"2016-01-19T13:00:03.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7ri000z543ves8o0xxh"},{"title":"javascript:void(0);到底是什么鬼?","date":"2016-01-29T07:03:57.000Z","comments":1,"_content":"## 疑问？\n我们经常看见`<a href=\"javascript:void(0);\">超链接</a>`的`href`里填写`javascript:void(0);`，取消点击跳转，可是为啥这么搞？\n<!--more-->\n## 规范是这么说的\n> The void Operator\n> \n> The production UnaryExpression : void UnaryExpression is evaluated as follows:\n \n> * Let expr be the result of evaluating UnaryExpression.\n> * Call GetValue(expr).\n> * Return undefined.\n> NOTE: GetValue must be called even though its value is not used because it may have observable side-effects\n\n搬译一下：\n\n> void操作符\n\n> 产生式 UnaryExpression : void UnaryExpression 按如下流程解释:\n\n> * 令 expr 为解释执行UnaryExpression的结果。\n> * 调用 GetValue(expr).\n> * 返回 undefined.\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n重点在于：无论void后的表达式是什么，void操作符都会返回undefined。\n\n## 用处\n### 替换`undefined`\n\n因为undefined在javascript中不是保留字。换言之，你可以写出：\n\n    {% codeblock lang:javascript %}\n    function joke() {\n        var undefined = \"hello world\";\n        console.log(undefined); //会输出\"hello world\"\n    }\n    joke()\n    {% endcodeblock %}\n对的，你可以在一个函数上下文内以undefined做为变量名，于是在这个上下文写的代码便只能通过从全局作用域来取到undefined，如：\n    \n    {% codeblock lang:javascript %}\n    window.undefined //浏览器环境\n    GLOBAL.undefined //Node环境\n    {% endcodeblock %}\n    \n但要注意的是，即便window, GLOBAL仍然可以在函数上下文被定义，故从window/GLOBAL上取undefined并不是100%可靠的做法。如：\n\n    {% codeblock lang:javascript %}\n    function x() {\n       var undefined = 'hello world',\n           f = {},\n           window = {\n               'undefined': 'joke'\n           };\n       console.log(undefined);// hello world\n       console.log(window.undefined); //joke\n       console.log(f.a === undefined); //false\n       console.log(f.a === void 0); //true\n    }\n    x();\n    {% endcodeblock %}\n\n于是，采用void方式获取undefined便成了通用准则。如underscore.js里的isUndefined便是这么写的：\n\n    {% codeblock lang:javascript %}\n    _.isUndefined = function(obj) {\n        return obj === void 0;\n    }\n    {% endcodeblock %}\n    \n除了采用void能保证取到undefined值以外，还有其它方法吗？有的，还有一种方式是通过函数调用。如AngularJS的源码里就用这样的方式：\n    \n    {% codeblock lang:javascript %}\n    (function(window, document, undefined) {\n        //.....\n    })(window, document);\n    {% endcodeblock %}\n\n通过不传参数，确保了undefined参数的值是一个undefined。\n\n### 填充a标签href、image标签的src\n\n* `<a href=\"javascript:void(0)\">test</a>`\n* `<image src=\"javascript:void(0)\">` \n\n## GetValue 是什么鬼？\n\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n(关于js中void，既然返回永远是undefined，那么GetValue有啥用？)[https://www.zhihu.com/question/22210634]\n\n    {% codeblock lang:javascript %}\n    var happiness = 10;\n    var girl = {\n        get whenMarry() {\n            happiness--;\n            return 1/0; //Infinity\n        },\n        get happiness() {\n            return happiness;\n        }\n    };\n    \n    console.log(girl.whenMarry); //调用了whenMarry的get方法\n    console.log(girl.happiness); // 9\n    \n    void girl.whenMarry; //调用了whenMarry的get方法\n    console.log(girl.happiness); // 8\n    \n    delete girl.whenMarry; //没有调用whenMarry的get方法\n    console.log(girl.happiness); //还是8\n    {% endcodeblock %}\n    \n上述代码定义了一个大龄文艺女青年，每被问到什么时候结婚呀(whenMarry)，happiness都会减1。从执行情况可以看出，无论是普通访问girl.whenMarry，还是void girl.whenMarry都会使她的happiness--。而如果把void换成delete操作符写成delete girl.whenMarry，她的happiness就不会减了，因为delete操作符不会对girl.whenMarry求值。\n\n## 总结\nvoid(0) 有如下作用：\n\n* 通过采用void 0取undefined比采用字面上的undefined更靠谱更安全，应该优先采用void 0这种方式。\n* 填充<a>的href确保点击时不会产生页面跳转; 填充<image>的src，确保不会向服务器发出垃圾请求。\n\n转自：[谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)","source":"_posts/void-0-2016-01-29.md","raw":"title: javascript:void(0);到底是什么鬼?\ndate: 2016-01-29 15:03:57\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n## 疑问？\n我们经常看见`<a href=\"javascript:void(0);\">超链接</a>`的`href`里填写`javascript:void(0);`，取消点击跳转，可是为啥这么搞？\n<!--more-->\n## 规范是这么说的\n> The void Operator\n> \n> The production UnaryExpression : void UnaryExpression is evaluated as follows:\n \n> * Let expr be the result of evaluating UnaryExpression.\n> * Call GetValue(expr).\n> * Return undefined.\n> NOTE: GetValue must be called even though its value is not used because it may have observable side-effects\n\n搬译一下：\n\n> void操作符\n\n> 产生式 UnaryExpression : void UnaryExpression 按如下流程解释:\n\n> * 令 expr 为解释执行UnaryExpression的结果。\n> * 调用 GetValue(expr).\n> * 返回 undefined.\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n重点在于：无论void后的表达式是什么，void操作符都会返回undefined。\n\n## 用处\n### 替换`undefined`\n\n因为undefined在javascript中不是保留字。换言之，你可以写出：\n\n    {% codeblock lang:javascript %}\n    function joke() {\n        var undefined = \"hello world\";\n        console.log(undefined); //会输出\"hello world\"\n    }\n    joke()\n    {% endcodeblock %}\n对的，你可以在一个函数上下文内以undefined做为变量名，于是在这个上下文写的代码便只能通过从全局作用域来取到undefined，如：\n    \n    {% codeblock lang:javascript %}\n    window.undefined //浏览器环境\n    GLOBAL.undefined //Node环境\n    {% endcodeblock %}\n    \n但要注意的是，即便window, GLOBAL仍然可以在函数上下文被定义，故从window/GLOBAL上取undefined并不是100%可靠的做法。如：\n\n    {% codeblock lang:javascript %}\n    function x() {\n       var undefined = 'hello world',\n           f = {},\n           window = {\n               'undefined': 'joke'\n           };\n       console.log(undefined);// hello world\n       console.log(window.undefined); //joke\n       console.log(f.a === undefined); //false\n       console.log(f.a === void 0); //true\n    }\n    x();\n    {% endcodeblock %}\n\n于是，采用void方式获取undefined便成了通用准则。如underscore.js里的isUndefined便是这么写的：\n\n    {% codeblock lang:javascript %}\n    _.isUndefined = function(obj) {\n        return obj === void 0;\n    }\n    {% endcodeblock %}\n    \n除了采用void能保证取到undefined值以外，还有其它方法吗？有的，还有一种方式是通过函数调用。如AngularJS的源码里就用这样的方式：\n    \n    {% codeblock lang:javascript %}\n    (function(window, document, undefined) {\n        //.....\n    })(window, document);\n    {% endcodeblock %}\n\n通过不传参数，确保了undefined参数的值是一个undefined。\n\n### 填充a标签href、image标签的src\n\n* `<a href=\"javascript:void(0)\">test</a>`\n* `<image src=\"javascript:void(0)\">` \n\n## GetValue 是什么鬼？\n\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n(关于js中void，既然返回永远是undefined，那么GetValue有啥用？)[https://www.zhihu.com/question/22210634]\n\n    {% codeblock lang:javascript %}\n    var happiness = 10;\n    var girl = {\n        get whenMarry() {\n            happiness--;\n            return 1/0; //Infinity\n        },\n        get happiness() {\n            return happiness;\n        }\n    };\n    \n    console.log(girl.whenMarry); //调用了whenMarry的get方法\n    console.log(girl.happiness); // 9\n    \n    void girl.whenMarry; //调用了whenMarry的get方法\n    console.log(girl.happiness); // 8\n    \n    delete girl.whenMarry; //没有调用whenMarry的get方法\n    console.log(girl.happiness); //还是8\n    {% endcodeblock %}\n    \n上述代码定义了一个大龄文艺女青年，每被问到什么时候结婚呀(whenMarry)，happiness都会减1。从执行情况可以看出，无论是普通访问girl.whenMarry，还是void girl.whenMarry都会使她的happiness--。而如果把void换成delete操作符写成delete girl.whenMarry，她的happiness就不会减了，因为delete操作符不会对girl.whenMarry求值。\n\n## 总结\nvoid(0) 有如下作用：\n\n* 通过采用void 0取undefined比采用字面上的undefined更靠谱更安全，应该优先采用void 0这种方式。\n* 填充<a>的href确保点击时不会产生页面跳转; 填充<image>的src，确保不会向服务器发出垃圾请求。\n\n转自：[谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)","slug":"void-0","published":1,"updated":"2016-01-29T07:40:34.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7rp0012543vq23iypo9"},{"title":"numberInJavaScript","date":"2016-06-19T13:51:58.000Z","comments":1,"_content":"# 思考\n先想几个问题吧：\n1. JavaScript的数字为什么有0和-0？\n2. JavaScript中的NaN为什么互不相等？\n3. JavaScript中的数字真的只有一种类型吗？\n4. JavaScript中常被诟病的0.3 - 0.2 == 0.1原因是什么？\n5. 数组的最大长度是多少？为什么是这个值？\n\n上述问题，只有在JavaScript中有吗？\n<!--more-->\n当下，计算机如此普及，我相信，即便非程序员也了解：计算机的世界只有`0`和`1`。而一个程序员应该了解：`0/1`组成的东西叫机器码，有原码, 反码, 补码等。而一个JS程序员应该了解：JS中的数字是不分类型的，也就是没有`byte/int/float/doubl`e等的差异。而一个稍微研究ES规范的JS程序员应该了解：JS的`number`是IEEE 754标准下64-bits的双精度数值，而且ES中有`ToInteger/ToInt32/ToUint32/ToUint16`等`Type Conversion`。下面，我们就尝试着讨论一下这些。\n# 码\n从硬件的角度上讲，维护两个状态是相对容易的，比如一个二极管的导通或者截止，一个电脉冲的高或者低，从而在实现集成电路时候可以更加简单高效，所以计算机普遍使用0和1来存储和计算。那么，只有`0`和`1`，如何表示1234567890呢？这就涉及到`机器码`和`真值`。\n## 机器码和真值\n* 所谓`机器码`是指，整数在计算机中二进制形式。规则很简单，机器码的最高位（左第一位）表示数字的正负，`0`表示正数，`1`表示负数，其余位按照进制转换的规则表示具体数字。\n* 所谓`真值`是指，机器码按照上述转换规则还原的带有正负的实际整数。\n\n举例而言，用8-bits表示一个整数，则十进制的整数`+6`可表示为：`00000110`；十进制的数字`-5`可表示为`10000101`。这里说的+6和-5便是真值，而表示它们的二进制数便是机器码。再次注意，最高位只用于表示正负，比如`10000101`的真值是`-5`而非`133`，以及我们关于机器码和真值的讨论是基于整数范围的，浮点数在计算机中的存储方式与整数有很大差值，将另作讨论。\n\n有了机器码，我们便可以在计算机中使用机器码存储和计算真值，那么机器码在计算机中是如何计算的呢？\n## 原码、反码、补码\n机器码分为多种，主要包括`原码、反码、补码、移`码等，今天我们主要总结一下前三个，而移码非常简单，且多用于比较，不做详细说明。另外需要补充一点，我们在此区分机器码的这么多种形式，主要是针对的有符号数，而无符号数，不需要使用最高位来表示正负，也就不需要这么多种编码方式。\n\n### 原码\n最高位表示正负，其它位表示真值的绝对值。其中，最高位为`0`表示`正数`或者`0`，为`1`表示负数。\n比如，同样以8bits长度的数串表示`+7`的原码为`0000 0111`，-7的原码为`10000111`。以后，我们会这样表示：\n```javascript\n  [+7] = [00000111]原\n  [-7] = [10000111]原\n```\n很明显，8-bits的原码能记录的范围为：`[-127,+127]`。\n原码的好处在于，易于理解，相对直观，方便人脑识别和计算。\n对于原码，人脑使用，可以直接计算出其真值然后可以进行后续操作。但对于计算机，\n首先，因为最高位用于表示正负，所以不能直接参与运算，需要识别然后做特殊处理；\n其次，具体计算使用绝对值进行操作，所以两个操作数正负的异同会影响操作符，比如两个异号相加实际要做减法操作，甚至异号相减还需要判断绝对值大小然后决定结果正负。\n如此，我们计算机的运算器设计将会变得异常复杂。下面，我们将了解如何使用反码和补码将符号位参与运算，从而使加减法统一简单高效地处理，这也是反码和补码出现的原因。\n### 反码\n正数的反码等于其原码，而`负数的反码则是对其原码进行符号位不变，其它位逐一取反的结果`。\n比如，同样以8-bits长度的数串表示`+7`，那么有如下：\n```javascript\n  [+7] = [00000111]原 = [00000111]反\n  [-7] = [10000111]原 = [11111000]反\n```\n同样，8-bits的反码能记录的范围为：`[-127,+127]`。\n在按位取反之后，我们可以有下面的操作：\n```javascript\n  2 - 3 = 2 + (-3) \n      = [00000010]原 + [10000011]原 \n      = [00000010]反 + [11111100]反 \n      = [11111110]反 \n      = [10000001]原 \n      = -1\n```\n上面，我们将减法通过反码转化为了加法，如此，我们的运算将会简单很多，但是反码的方式同样存在一些问题：\n```javascript\n  3 - 3 = 3 + (-3) \n      = [00000011]原 + [10000011]原 \n      = [00000011]反 + [11111100]反 \n      = [11111111]反 \n      = [10000000]原 \n      = -0\n```\n出现了`-0`，这个值是没有意义的。另外，按照`反码加法法则，如果最高位有进位，需要在最低位上+1`，那么会出现：\n```javascript\n  3 - 2 = 3 + (-2) \n      = [00000011]原 + [10000010]原 \n      = [00000011]反 + [11111101]反 (这里最高位有进位，需要在最低位+1) \n      = [00000001]反 \n      = [00000001]原 \n      = 1\n```\n这种情况，又增加了反码运算的复杂性，影响效率，为解决上面的问题，出现了补码。\n### 补码\n正数的补码等于其原码，而负数的补码则是对其反码进行末位加1的结果。\n```javascript\n  [+7] = [00000111]原 = [00000111]反 = [00000111]补\n  [-7] = [10000111]原 = [11111000]反 = [11111001]补\n```\n使用补码，继续做之前的操作：\n```javascript\n  2 - 3 = 2 + (-3) \n      = [00000010]原 + [10000011]原 \n      = [00000010]反 + [11111100]反 \n      = [00000010]补 + [11111101]补 \n      = [11111111]补 \n      = [11111110]反 \n      = [10000001]原 \n      = -1\n```\n那么，如果是`3-3`呢？\n```javascript\n  3 - 3 = 3 + (-3) \n      = [00000011]原 + [10000011]原 \n      = [00000011]反 + [11111100]反 \n      = [00000011]补 + [11111101]补 \n      = [00000000]补 \n      = [00000000]原 \n      = 0\n```\n是否还需要做额外的加法操作？\n```javascript\n  3 - 2 = 3 + (-2) \n      = [00000011]原 + [10000010]原 \n      = [00000011]反 + [11111101]反 \n      = [00000011]补 + [11111110]补 \n      = [00000001]补 \n      = [00000001]原 \n      = 1\n```\n这样，我们便可以完美的将减法统一到加法之上，而且不需要繁琐的正负判断，进位控制，甚至可以节约一个位置。\n那么，这个位置，也就是`10000000`如何处理呢？\n`按照规定，10000000用来表示-128`，正数的补码/反码/原码相同，而负数的补码只是占用了-0的`[10000000]原`和`[11111111]反`转换后得到的`[10000000]补`表示-128，但是这个只是帮助理解，不能反向回推得到`-128`的原码和补码。\n所以，8bits的补码能记录的范围为：`[-128,+127]`。\n至此，我们已经了解了，计算机中主要使用的存储和计算整数的方式，鉴于现代计算机主要使用补码方式，自然能很容易理解各种数字类型的表示范围，比如32bits的int范围为：`[-231,231-1]`。这对于我们后面理解一些JavaScript中的极端情况至关重要。\n\n#### 补码10000000为什么可以表示-128？\n有知乎大神这么理解：\n作者：fhylhl 链接：http://www.zhihu.com/question/28685048/answer/41735701 来源：知乎\n> 很多人并不理解补码。补码就是同余啊。1000000是正128你知道吧，正负128模256是同余的。加减乘可以直接算也是同余的定理决定的，而不是凑出来的巧合，哪可能凑出这种东西？\n  8位只能表示256个数，0到255，但我还想表示一些负数怎么办呢？就用与该负数同余的正数来表示呗。-1=255，-2=254，等等。\n  建议脱离算数的思维方式，这其实就是一个环。模任何一个正整数（如256），可以把所有整数分类，比如模256可分256类，0 256 -256...是一类（余0类），1 257 -255...是一类（余1类），等等，这256类可看作环的元素，你看-128和128是同一个类里的（余128类），用一个代表另一个罢了。补码和普通的unsigned integers都是在每类中选一个数，unsigned integers选0到255，补码表示的有符号整数选-128到127，都是一个数恰好对应一个类。当你明白这一切后，补码就是顺理成章的事。\n\n>> 同余:数论中的重要概念。给定一个正整数m，如果两个整数a和b满足（a-b）能够整除m，即（a-b）/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系。\n\n## IEEE 754标准\n作为一个JavaScript程序员，我们只有一个Number，所以我们从一开始就习惯了：\n```javascript\n  var num1 = 123;\n  var num2 = 1.23;\n```\n但是，你知道JS的number是`IEEE 754`标准的64-bits的双精度数值吗？这是一个什么样的标准？使用这个标准的64-bits双精度意味着什么？所以，要掌握JavaScript中的数字，我们首先得了解`IEEE 754`标准。下面，我将尝试说明一下这个标准，为我们最后学习JavaScript中的数字做铺垫。\n\n## 标准的基本原理：\n我们知道，对于计算机而言，数字没有小数和整数的差别，也就是计算机中没有小数点的存在。通过前文的讨论，我们已经找到了很完美的整数存储计算的方案，但是当涉及到小数，我们很容易发现，现有的方案无法解决我们的需求。然后，计算机科学家们便尝试了多种方案，主要便是`定点数`和`浮点数`两种。\n* 所谓定点数，是指小数点位置固定在数串中间的某个特定位置，点两侧分别为数字的整数和小数部分。比如用8-bits字长的数串，小数点固定在正中间位置，那么`11001001`和`00110101`分别表示`1100.1001`和`11.0101`两个数字。这种方案简单直观易理解，但是存在严重的空间浪费，以及容易溢出的问题。\n* 所谓浮点数，是指小数点的位置是不固定的，通过科学计数法(这个应该不需要解释吧)的方式控制小数点的位置，表示不同的数字。这个表示方案便是IEEE 754标准使用的方案。IEEE 754标准是目前使用最广泛的浮点数运算标准。下面我们将主要讨论一下此方案。\n\n现在，让我们想一下小时候学习的科学计数法，比如`-123.456`这个数字，转换成科学计数法应该是：`-1.23456 × 10^2`。这里面已经包含了IEEE 754标准的主要元素。我们梳理一下：第一个，自然是正负号的问题，需要一个标志；然后，需要一个具体的数字，表示有效数字或者精度，如上例的`1.23456`；再然后，需要一个控制小数点位置的数字，如上例的`10^2`，回忆一下，我们学习科学计数法的时候，要求前面的数字的绝对值大于1而小于10，也就是小于10^2中的底数(Base)，进制固定之后，底数应该是固定的，所以这里起决定作用的是指数，也就是上例中的2。那么，有了这三个元素，我们便可以很轻松的表示出一个数字，并且灵活的调节小数点位置从而控制数字正负、精度和大小。\n\n上面的要素，转换成标准语言描述，我们称表示正负的标志叫`符号(Sign)`，表示精度的数字为`尾数(Mantissa)`或者`有效数字(Significand)`，而控制小数点位置的指数就叫`指数(Exponent)`，指数和`基数(Base)`共同作用参与计算。下图取自wikipedia，我们直观地感受下这三个要素在一个数串中的相对关系（fraction区域即等同于前面说的有效数字区域）：\n{% asset_img 123.png %}\n了解最基本的原理后，我们来大致看一下`IEEE 754`标准做了什么。\n首先做的事情就是规定这三个要素在一个数串中占有的位数，试想一下，如果各个实现的位数不确定，那么我们是不是很难正确的还原出原始数字？`IEEE 754`标准规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80比特实做）。只有32位模式有强制要求，其他都是选择性的。而现在主流的语言，多提供了单精度和双精度的实现，我们在此主要比较一下这两者，如图是它们各个部分对应上图，所使用的位数如下：\n{% asset_img 456.png %}\n{% asset_img 789.png %}\n补充一点的是，无论是科学计数法还是标准的规定，都要求有效数字（不考虑符号位）必须`>=1 && <Base`。所以，有效数字其实是一个定点数，小数点的位置固定在有效数字域的最高位和次高位之间。那么，按照上述规定，在二进制中，最高位只能是`1`，所以标准要求省略其最高位，于是精度提高一位。比如，`32-bits`的单精度有效数字区域只有23位，但是精度却是24位；`64-bits`的双精度，拥有52位的有效数字域却是53位精度的。\n\n然后，还有一个问题，如果按照先有的约定，`是不是无法表示小于1的实数？`因为，`指数一定>=0，有效数字一定>1`。于是，`IEEE 754`标准提出了一个很重要的指数偏移值。它是说明指数域(Exponent占用的区域)的编码值为指数的实际值加上某个固定的值，换言之便是，如果我们根据指数域计算出的指数是`N`，那么参与计算实际浮点数的指数应该是`N-指数偏移值`。根据IEEE 754标准的规定，该固定值为`2^(e-1) - 1`，其中的`e`为存储指数的比特的长度。比如，从上图中我们看到，`32-bits`的单精度是以`8-bits表示一个指数域`，那么偏移值应该是`2^(8-1) - 1 = 128−1 = 127`。所以，容易得出，单精度浮点数的指数部分实际取值是`全零00000000 0-127=-127`到`全零11111111 256-127=128`就是`[-127,128]`。比如，某个`32-bits`单精度的指数为十进制的`1`，那么指数域的编码应该是`10000001`，某个32-bits单精度的指数域编码是`00000001`，那么该指数的实际值应该是十进制的`-126`。这样，我们就能通过偏移值将正指数转换为负指数，从而`使浮点数能逼近0`。浮点数的指数计算跟前面讨论的机器码恰好相反，`正数的最高位都是1，而负数的最高位都是0`。\n\n以上的描述，便是IEEE 754标准最需要我们了解的原理部分，但是，作为一个广泛使用的工业标准，规定这些还是远远不够的。\nwikipedia(维基百科)对IEEE 754标准有如下描述：\n>这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number）），一些特殊数值（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。\n\n下面，补充几个，我认为与本文后续讨论相关的或者可以帮助大家理解极端现象的定义：\n`规约形式的浮点数`:如果浮点数中指数部分的编码值在`0 < exponent < 2^(e-1)`之间，且尾数部分最高有效位（即整数）是1，那么这个浮点数将被称为规约形式的浮点数。也就是，严格按照我们上文描述编码的数字。\n`非规约形式的浮点数`:如果浮点数的指数部分的编码值是`0`，尾数为非零，那么这个浮点数将被称为非规约形式的浮点数。`IEEE 754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值大1`。例如，最小的规约形式的单精度浮点数的指数部分编码值为`1`，指数的实际值为`-126`；而非规约的单精度浮点数的指数域编码值为`0`，对应的指数实际值也是`-126`而不是`-127`。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近0。规约浮点数的尾数大于等于`1`且小于`2`，而非规约浮点数的尾数小于`1`且大于`0`。\n上面的两个概念，几乎是直接从wikipedia上扒下来的，·非规约形式的浮点数·出现的意义是避免突然式下溢出（abrupt underflow），而采用渐进式下溢出。这已经是上世纪70年代的事情了，差不多是我的年龄的两倍了。这个是一些非常极端的情况，在此我尝试最简单地描述一下`非规约形式的浮点数`出现的意义，知道有这么回事便可：下面，以单精度为例，如果没有`非规约形式的浮点数`，那么绝对值最小的两个相邻的浮点数之间的差值将是绝对值最小的浮点数的2^23分之一，大家想一下，绝对值次小的浮点数减去绝对值最小的浮点数的值是多少？\n\n```javascript\n  1.00...01 × 2^(-126) - 1.00...00 × 2^(-126) = 0.00..01 × 2^(-126) \n                                              = 1 × 2^(-126-23)\n                                              = 2^(-149)\n```\n很明显，绝对值最小的`规约数`无法表达其和次小的`规约数`的差值，所以很容易导致有若干数字之间的差值下溢，可能会触发意料之外的后果。而如果采用非规约形式的浮点数，指数全0，偏移值比规约数偏移值大1（`-126`比`-127`大1），尾数小于`1`，那么非规约数能表达的最小值便是：\n```javascript\n  0.00..01 × 2^(-126) = 1 × 2^(-126-23)\n                    = 2^(-149)\n```\n所以，`非规约形式的浮点`数解决了前述的`突然式下溢出（abrupt underflow）`而被标准采纳。\n`IEEE 754`标准还规定了三个特殊值：\n* 指数全0且尾数小数部分全0，则这个数字为±0。（符号位决定正负）\n* 指数为2^e - 1且尾数的小数部分全0，这个数字是±∞。（符号位决定正负）\n* 指数为2^e - 1且尾数的小数部分非0，这个数字是NaN。\n结合前面的规约数，非规约数以及三个特殊值，可以得到如下总结：\n{% asset_img 10.png %}\n现在，让我们回忆一下，各种语言中普遍描述的双精度浮点数的范围：`[-1.7 × 10^(-308),1.7 × 10^308]`。打个岔，想象一个有300多位的十进制数字的适用情形，私以为远超过普通人想象力的边界。这个范围为什么是这个范围呢？我觉得，通过上面的讨论，大家应该能清晰，1.7/308这些数字出现的必然原因。\n首先，我们应该很容易根据偏移量得出双精度浮点数的计算公式：\n{% asset_img 11.png %}\n然后，以正数为例，按照上述特殊值中`±∞`和`NaN`的约定，指数的最大值应该满足指数取规约数的指数范围的最大值，然后小数部分取小数部分的最大值，可以得出这个二进制的数字应该是：\n    0 11111111110 11..11(52个)\n转换为16进制表示：\n0x7fef ffff ffff ffff\n那么，根据前述规约数的原理，反编码便得到十进制的：`1.7976931348623157 x 10^308`。类似的道理，Sign位取反，便是范围的下限。\n到此为止吧，我对`IEEE 754`标准也是最近几天稍加学习，再说多了就误导大家了。通过这几天的学习，我感觉，我们在理解的IEEE 754标准及浮点数的时候，要特别注意将精度和范围两个概念分别开来。范围只是一个模糊的界限，精度才是能准确表达的数字。\n\n## 回到JavaScript\n在上面的讨论中，我们很少提及JavaScript，似乎有点背离今天的主题了，但是，在了解了前述的原理之后，我们对JavaScript中数字的把握将”水到渠成”。这终将是一次，铺垫多于正文，开胃菜多于正餐的讨论。嗯，快喊小伙伴，正餐开始了！\n### ES的”The Number Type”：\n现在，我们打开ES规范的[The Number Type](http://es5.github.io/#x8.5) 是不是基本通读下来了？\n比如：\n> The Number type has exactly 18437736874454810627 (that is, 2^64 − 2^53 + 3) values…\n为什么是这个数字？因为，我们说JavaScript中的数字是`64-bits`的双精度，所以首先有`2^64`中可能的组合，然后，按照前述的`IEEE 754`标准的标准中的特殊值中的部分，`NaN`和`±∞`占用了`2^53`个数值，但是表示了三个直观的量，所以，加减一下，自然就是`18437736874454810627` `(that is, 2^64 − 2^53 + 3)` values。\n> …the 9007199254740990 (that is, 2^53−2) distinct “Not-a-Number” values…\n为什么这么多`NaN`？同样，按照前述的`IEEE 754`标准的标准中的特殊值中的部分，`NaN`使用了`Significand非零`、`指数是特定2^e-1且Sign无要求的所有可能`，即`2^53`减去`±∞`两种情况。\n>…e is an integer ranging from −1074 to 971…\n为什么指数的范围是这个呢？而不是`-1022到+1022`呢？因为，ES演化了一下公式，对比一下我们之前演示`64-bits`的公式，关于参与计算的`mantissa`，我们按照`IEEE 754`标准在演示的时候中使用的是`1.m`，而ES规范中使用的是`m`，当然会有尾数域bit长度的差异了。\n\n到这里，关于数字，大概就可以结束了。开篇的几个问题，相信读到这里的同学，都能有答案了。但是，还有一个问题，JavaScript中的数字真的只有一种类型吗？，而且貌似到现在与我们的初衷，理解`>>>`有点偏离了。不过，世界上很多事情往往都是这样，解释原理需要到口干舌燥，而用原理去解释现象却只需要三言两语。\n\n### JavaScript不是只有64-bits的双精度\n是的，小标题已经回答了我们的问题，JavaScript不是只有`64-bits`的双精度。我们通篇都在说JavaScript中数字的各种，一直按照`64-bits`的双精度来描述，但是，如之前所说，ES中有`ToInteger/ToInt32/ToUint32/ToUint16`等Type Conversion。这些Type Conversion不是我们直接调用的API，而是语言引擎在进行某些特定操作的时候，替我们做的。这种“隐形的操作”，只有在一些极端的情况下，会表现出来。现在，我们可以到`“ToInt32”/“ToUint32”/“ToInt16”`三个地方看一下，稍作比较便能发现，他们的差异很小，只是在特定的步骤中存在差异。比如，`ToUint32和ToUint16`的差异仅仅操作的最后一步存在差异，按顺序列出比较一下：\n\n> Let int32bit be posInt modulo 2^32; that is, a finite integer value k of Number type with positive sign and less than 2^32 in magnitude such that the > mathematical difference of posInt and k is mathematically an integer multiple of 2^32.\n> \n>Return int32bit.\nvs\n> Let int16bit be posInt modulo 2^16; that is, a finite integer value k of Number type with positive sign and less than 2^16 in magnitude such that the mathematical difference of posInt and k is mathematically an integer multiple of 2^16.\n>\n>Return int16bit.\n\n比较一下，不难发现，仅仅是`2^32`和`2^16`的差异，而关键点恰是`modulo`操作的时候，按照我们之前讨论的原理，很容易理解这个操作决定了可能出现的最大数。这样的比较，有一好处，能提高我们阅读标准的速度，而且加深理解，对掌握标准很有帮助。\n总结一下这三个操作的范围：\n\n* ToInt32的范围便是其它强类型语言中的[-2^31, -2^31 - 1]。\n\n* ToUint32的范围便是其它强类型语言中的[0, -2^32 - 1]。\n\n* ToUint16的范围便是其它强类型语言中的[0, -2^16 - 1]。\n通过搜索，很容易能找到，JavaScript中那些操作中使用了上述相关的操作。其中，`ToUint16`仅仅在`String.fromCharCode`中有使用，我们不做讨论了。`ToInt32`有在多个位运算符中使用，比如`~` `/` `<<` `/` `>>`，以及在`parseIn`t也有使用。而`ToUint32`的使用则出现在了大量的地方，主要分布在`，数组相关的操作，位运算的操作`两个区域。\n我们就借`ToUint32`的这些使用，回到开篇讨论的那个地方吧：\n首先，来到这里[>>>](http://es5.github.io/#x11.7.3)，看到操作如下：\n> 1. Let lref be the result of evaluating ShiftExpression.\n> \n> 2. Let lval be GetValue(lref).\n> \n> 3. Let rref be the result of evaluating AdditiveExpression.\n>\n> 4. Let rval be GetValue(rref).\n>\n> 5. Let lnum be ToUint32(lval).\n> \n> 6. Let rnum be ToUint32(rval).\n> \n> 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.\nReturn the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.\n>\n再看new Array (len)，有一句：\n> If the argument len is a Number and ToUint32(len) is equal to len, then the length property of the newly constructed object is set to ToUint32(len). If the argument len is a Number and ToUint32(len) is not equal to len, a RangeError exception is thrown.\n对比不难发现，`>>>`的返回值和`array.length`的取值范围，无差异，经过`>>>`操作后的数字，一定是一个合法的`array.length`。解释原理总是那么复杂，可是用原理解释现象总是那么简单。\n\n## 将实数转换成浮点数\n\n### 浮点数的规范化\n同样的数值可以有多种浮点数表达方式，比如上面例子中的 123.45 可以表达为 12.345 × 101，0.12345 × 103 或者 1.2345 × 102。因为这种多样性，有必要对其加以规范化以达到统一表达的目标。规范的（Normalized）浮点数表达方式具有如下形式：`±d.dd...d × βe , (0 ≤ d i < β)`。\n其中 d.dd...d 即尾数，β 为基数，e 为指数。尾数中数字的个数称为精度，在本文中用 p 来表示。每个数字 d 介于 0 和基数之间，包括 0。小数点左侧的数字不为 0。\n基于规范表达的浮点数对应的具体值可由下面的表达式计算而得：`±(d 0 + d 1β-1 + ... + d p-1β-(p-1))βe , (0 ≤ d i < β)`\n对于十进制的浮点数，即基数 β 等于 10 的浮点数而言，上面的表达式非常容易理解，也很直白。计算机内部的数值表达是基于二进制的。从上面的表达式，我们可以知道，二进制数同样可以有小数点，也同样具有类似于十进制的表达方式。只是此时 β 等于 2，而每个数字 d 只能在 0 和 1 之间取值。比如二进制数 1001.101 相当于 1 × 2<sup>3</sup> + 0 × 2<sup>2</sup> + 0 × 2<sup>1</sup> + 1 × 2<sup>0</sup> + 1 × 2<sup>-1</sup> + 0 × 2<sup>-2</sup> + 1 × 2<sup>-3</sup>，对应于十进制的 9.625。其规范浮点数表达为 1.001101 × 2<sup>3</sup>。\n\n### 根据精度表示浮点数\n\n问：要把小数装入计算机，总共分几步？你猜对了，3 步。\n\n* 第一步：转换成二进制。\n* 第二步：用二进制科学计算法表示。\n* 第三步：表示成 IEEE 754 形式。\n\n#### 如何把十进制小数转换成二进制小数。\n十进制小数转换成二进制小数采用\"乘2取整，顺序排列\"法。\n具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。\n* 如：25.7=（11001.10110011001100110011001100110011...）B\n  * 整数部分：\n        25%2 = 1 ======== 1\n        12%2 = 0 ======== 0\n        6%2  = 3 ======== 0\n        3%2  = 1 ======== 1\n        1%2  = 1 ======== 1\n * 小数部分：\n        0.7*2=1.4========取出整数部分1 \n        0.4*2=0.8========取出整数部分0 \n        0.8*2=1.6========取出整数部分1 \n        0.6*2=1.2========取出整数部分1 \n        0.2*2=0.4========取出整数部分0　 \n        0.4*2=0.8========取出整数部分0 \n        0.8*2=1.6========取出整数部分1 \n        0.6*2=1.2========取出整数部分1 \n        0.2*2=0.4========取出整数部分0 \n * 最后结果就是： \n        11001.1 0110 0110 0110 0110 0110 0110 0110 0110 0110...\n \n#### 用二进制科学计算法表示\n  11001.101100110 == 1.1001101100110 * 2<sup>4</sup>\n#### 表示成 IEEE 754 形式\n1. 正数 固符号位为 0 \n2. 尾数 由于第一位使用是1,固取(首位1干掉了).10011 0110 0110 0110 0110 0110 0110 0110 0110 0110\n3. 指数 4 + 1023(偏移量),转换为 二进制就是 10000000011\n组合在一起就是 0 10000000011 10011 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 011\n\n> 单精度32位的 偏移量是  Math.pow(2,8)/2 -1 == 127 ，双精度64位的偏移量是 Math.pow(2,11)/2 -1 == 1023 \n\n### 哪些数能精确表示？\n那么 0.1 在计算机中可以精确表示吗？答案是出人意料的， 不能。\n\n在此之前，先思考个问题： `在 0.1 到 0.9 的 9 个小数中，有多少可以用二进制精确表示呢？`\n\n我们按照乘以 2 取整数位的方法，把 0.1 表示为二进制（我假设那些不会进制转换的同学已经补习完了）：\n\n(1) 0.1 x 2 = 0.2  取整数位 0 得 0.0\n(2) 0.2 x 2 = 0.4  取整数位 0 得 0.00\n(3) 0.4 x 2 = 0.8  取整数位 0 得 0.000\n(4) 0.8 x 2 = 1.6  取整数位 1 得 0.0001\n(5) 0.6 x 2 = 0.2  取整数位 1 得 0.00011\n(6) 0.2 x 2 = 0.4  取整数位 0 得 0.000110\n(7) 0.4 x 2 = 0.8  取整数位 0 得 0.0001100\n(8) 0.8 x 2 = 1.6  取整数位 1 得 0.00011001\n(9) 0.6 x 2 = 1.2  取整数位 1 得 0.000110011\n(n) ...\n我们得到一个无限循环的二进制小数 0.000110011…\n\n我为什么要把这个计算过程这么详细的写出来呢？就是为了让你看，多看几遍，再多看几遍，继续看… 还没看出来，好吧，把眼睛揉一下，我提示你，把第一行去掉，从 (2) 开始看，看到 (6)，对比一下 (2) 和 (6)。 然后把前两行去掉，从 (3) 开始看…\n明白了吧，0.2、0.4、0.6、0.8 都不能精确的表示为二进制小数。 难以置信，这可是所有的偶数啊！那奇数呢？ 答案就是：\n0.1 到 0.9 的 9 个小数中，只有 0.5 可以用二进制精确的表示。\n**如果把 0.0 再算上，那么就有两个数可以精确表示，一个奇数 0.5，一个偶数 0.0。** \n\n那么到底怎么确定一个数能否精确表示呢？还是回到我们熟悉的十进制分数。\n\n1/2、5/9、34/25 哪些可以写成有限小数？把一个分数化到最简（分子分母无公约数），如果分母的因式分解只有 2 和 5，那么就可以写成有限小数，否则就是无限循环小数。为什么是 2 和 5 呢？因为他们是 10 的因子 10 = 2 x 5。二进制和十六进制呢？他们的因子只有 2，所以十六进制只是二进制的一种简写形式，它的精度和二进制一样。\n**如果一个十进制数可以用二进制精确表示，那么它的最后一位肯定是 5。备注：这是个必要条件，而不是充分条件。**\n\n###  为啥 0.2+0.4 不等于0.6\n```javascript\n0.2 + 0.4 //0.6000000000000001\n```\n1.6 + 2.8 = 4.4 \n四舍五入得到 4。我们用另一种方法\n先把 1.6 四舍五入为 2\n再把 2.8 四舍五入为 3\n最后求和 2 + 3 = 5\n通过两种运算，我们得到了两个结果 4 和 5。同理，在我们的浮点数运算中，参与运算的两个数 0.2 和 0.4 精度已经丢失了，所以他们求和的结果已经不是 0.6 了。\n\n## 特殊值\n\n* 指数域不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数的计算值减去127（或1023），得到真实值，再将尾数前加上第一位的1。\n* 指数域全为0。这时，浮点数的指数等于1-127（或者1-1023），尾数不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。\n* 指数域全为1。这时，如果尾数全为0，表示±无穷大（正负取决于符号位s）；如果尾数不全为0，表示这个数不是一个数（NaN）。\n\n### NaN(Not a Number)\nNaN 用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。\nNaN 指数域全为 1，且尾数域不等于零的浮点数。IEEE 标准没有要求具体的尾数域，所以 NaN 实际上不是一个，而是一族。不同的实现可以自由选择尾数域的值来表达 NaN。\n任何有 NaN 作为操作数的操作也将产生 NaN。用特殊的 NaN 来表达上述运算错误的意义在于避免了因这些错误而导致运算的不必要的终止。回顾我们对 NaN 的介绍，当零除以零时得到的结果不是无穷而是 NaN 。原因不难理解，当除数和被除数都逼近于零时，其商可能为任何值，所以 IEEE 标准决定此时用 NaN 作为商比较合适。\n### 有符号的零\n因为 IEEE 标准的浮点数格式中，小数点左侧的 1 是隐藏的，而零显然需要尾数必须是零。所以，零也就无法直接用这种格式表达而只能特殊处理。\n实际上，零保存为尾数域为全为 0，指数域为 emin - 1 = -127，也就是说指数域也全为 0。考虑到符号域的作用，所以存在着两个零，即 +0 和 -0。不同于正负无穷之间是有序的，IEEE 标准规定正负零是相等的。\n零有正负之分，的确非常容易让人困惑。这一点是基于数值分析的多种考虑，经利弊权衡后形成的结果。有符号的零可以避免运算中，特别是涉及无穷的运算中，符号信息的丢失。举例而言，如果零无符号，则等式 1/(1/x) = x 当x = ±∞ 时不再成立。原因是如果零无符号，1 和正负无穷的比值为同一个零，然后 1 与 0 的比值为正无穷，符号没有了。解决这个问题，除非无穷也没有符号。但是无穷的符号表达了上溢发生在数轴的哪一侧，这个信息显然是不能不要的。零有符号也造成了其它问题，比如当 x=y 时，等式1/x = 1/y 在 x 和 y 分别为 +0 和 -0 时，两端分别为正无穷和负无穷而不再成立。当然，解决这个问题的另一个思路是和无穷一样，规定零也是有序的。但是，如果零是有序的，则即使 if (x==0) 这样简单的判断也由于 x 可能是 ±0 而变得不确定了。两害取其轻者，零还是无序的好。\n\n注： 本文转自 [随心小筑](http://jser.it/blog/2014/07/07/numbers-in-javascript/) 我自己做了本分填充和整理","source":"_posts/numberInJavaScript-2016-06-19.md","raw":"title: numberInJavaScript\ndate: 2016-06-19 21:51:58\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# 思考\n先想几个问题吧：\n1. JavaScript的数字为什么有0和-0？\n2. JavaScript中的NaN为什么互不相等？\n3. JavaScript中的数字真的只有一种类型吗？\n4. JavaScript中常被诟病的0.3 - 0.2 == 0.1原因是什么？\n5. 数组的最大长度是多少？为什么是这个值？\n\n上述问题，只有在JavaScript中有吗？\n<!--more-->\n当下，计算机如此普及，我相信，即便非程序员也了解：计算机的世界只有`0`和`1`。而一个程序员应该了解：`0/1`组成的东西叫机器码，有原码, 反码, 补码等。而一个JS程序员应该了解：JS中的数字是不分类型的，也就是没有`byte/int/float/doubl`e等的差异。而一个稍微研究ES规范的JS程序员应该了解：JS的`number`是IEEE 754标准下64-bits的双精度数值，而且ES中有`ToInteger/ToInt32/ToUint32/ToUint16`等`Type Conversion`。下面，我们就尝试着讨论一下这些。\n# 码\n从硬件的角度上讲，维护两个状态是相对容易的，比如一个二极管的导通或者截止，一个电脉冲的高或者低，从而在实现集成电路时候可以更加简单高效，所以计算机普遍使用0和1来存储和计算。那么，只有`0`和`1`，如何表示1234567890呢？这就涉及到`机器码`和`真值`。\n## 机器码和真值\n* 所谓`机器码`是指，整数在计算机中二进制形式。规则很简单，机器码的最高位（左第一位）表示数字的正负，`0`表示正数，`1`表示负数，其余位按照进制转换的规则表示具体数字。\n* 所谓`真值`是指，机器码按照上述转换规则还原的带有正负的实际整数。\n\n举例而言，用8-bits表示一个整数，则十进制的整数`+6`可表示为：`00000110`；十进制的数字`-5`可表示为`10000101`。这里说的+6和-5便是真值，而表示它们的二进制数便是机器码。再次注意，最高位只用于表示正负，比如`10000101`的真值是`-5`而非`133`，以及我们关于机器码和真值的讨论是基于整数范围的，浮点数在计算机中的存储方式与整数有很大差值，将另作讨论。\n\n有了机器码，我们便可以在计算机中使用机器码存储和计算真值，那么机器码在计算机中是如何计算的呢？\n## 原码、反码、补码\n机器码分为多种，主要包括`原码、反码、补码、移`码等，今天我们主要总结一下前三个，而移码非常简单，且多用于比较，不做详细说明。另外需要补充一点，我们在此区分机器码的这么多种形式，主要是针对的有符号数，而无符号数，不需要使用最高位来表示正负，也就不需要这么多种编码方式。\n\n### 原码\n最高位表示正负，其它位表示真值的绝对值。其中，最高位为`0`表示`正数`或者`0`，为`1`表示负数。\n比如，同样以8bits长度的数串表示`+7`的原码为`0000 0111`，-7的原码为`10000111`。以后，我们会这样表示：\n```javascript\n  [+7] = [00000111]原\n  [-7] = [10000111]原\n```\n很明显，8-bits的原码能记录的范围为：`[-127,+127]`。\n原码的好处在于，易于理解，相对直观，方便人脑识别和计算。\n对于原码，人脑使用，可以直接计算出其真值然后可以进行后续操作。但对于计算机，\n首先，因为最高位用于表示正负，所以不能直接参与运算，需要识别然后做特殊处理；\n其次，具体计算使用绝对值进行操作，所以两个操作数正负的异同会影响操作符，比如两个异号相加实际要做减法操作，甚至异号相减还需要判断绝对值大小然后决定结果正负。\n如此，我们计算机的运算器设计将会变得异常复杂。下面，我们将了解如何使用反码和补码将符号位参与运算，从而使加减法统一简单高效地处理，这也是反码和补码出现的原因。\n### 反码\n正数的反码等于其原码，而`负数的反码则是对其原码进行符号位不变，其它位逐一取反的结果`。\n比如，同样以8-bits长度的数串表示`+7`，那么有如下：\n```javascript\n  [+7] = [00000111]原 = [00000111]反\n  [-7] = [10000111]原 = [11111000]反\n```\n同样，8-bits的反码能记录的范围为：`[-127,+127]`。\n在按位取反之后，我们可以有下面的操作：\n```javascript\n  2 - 3 = 2 + (-3) \n      = [00000010]原 + [10000011]原 \n      = [00000010]反 + [11111100]反 \n      = [11111110]反 \n      = [10000001]原 \n      = -1\n```\n上面，我们将减法通过反码转化为了加法，如此，我们的运算将会简单很多，但是反码的方式同样存在一些问题：\n```javascript\n  3 - 3 = 3 + (-3) \n      = [00000011]原 + [10000011]原 \n      = [00000011]反 + [11111100]反 \n      = [11111111]反 \n      = [10000000]原 \n      = -0\n```\n出现了`-0`，这个值是没有意义的。另外，按照`反码加法法则，如果最高位有进位，需要在最低位上+1`，那么会出现：\n```javascript\n  3 - 2 = 3 + (-2) \n      = [00000011]原 + [10000010]原 \n      = [00000011]反 + [11111101]反 (这里最高位有进位，需要在最低位+1) \n      = [00000001]反 \n      = [00000001]原 \n      = 1\n```\n这种情况，又增加了反码运算的复杂性，影响效率，为解决上面的问题，出现了补码。\n### 补码\n正数的补码等于其原码，而负数的补码则是对其反码进行末位加1的结果。\n```javascript\n  [+7] = [00000111]原 = [00000111]反 = [00000111]补\n  [-7] = [10000111]原 = [11111000]反 = [11111001]补\n```\n使用补码，继续做之前的操作：\n```javascript\n  2 - 3 = 2 + (-3) \n      = [00000010]原 + [10000011]原 \n      = [00000010]反 + [11111100]反 \n      = [00000010]补 + [11111101]补 \n      = [11111111]补 \n      = [11111110]反 \n      = [10000001]原 \n      = -1\n```\n那么，如果是`3-3`呢？\n```javascript\n  3 - 3 = 3 + (-3) \n      = [00000011]原 + [10000011]原 \n      = [00000011]反 + [11111100]反 \n      = [00000011]补 + [11111101]补 \n      = [00000000]补 \n      = [00000000]原 \n      = 0\n```\n是否还需要做额外的加法操作？\n```javascript\n  3 - 2 = 3 + (-2) \n      = [00000011]原 + [10000010]原 \n      = [00000011]反 + [11111101]反 \n      = [00000011]补 + [11111110]补 \n      = [00000001]补 \n      = [00000001]原 \n      = 1\n```\n这样，我们便可以完美的将减法统一到加法之上，而且不需要繁琐的正负判断，进位控制，甚至可以节约一个位置。\n那么，这个位置，也就是`10000000`如何处理呢？\n`按照规定，10000000用来表示-128`，正数的补码/反码/原码相同，而负数的补码只是占用了-0的`[10000000]原`和`[11111111]反`转换后得到的`[10000000]补`表示-128，但是这个只是帮助理解，不能反向回推得到`-128`的原码和补码。\n所以，8bits的补码能记录的范围为：`[-128,+127]`。\n至此，我们已经了解了，计算机中主要使用的存储和计算整数的方式，鉴于现代计算机主要使用补码方式，自然能很容易理解各种数字类型的表示范围，比如32bits的int范围为：`[-231,231-1]`。这对于我们后面理解一些JavaScript中的极端情况至关重要。\n\n#### 补码10000000为什么可以表示-128？\n有知乎大神这么理解：\n作者：fhylhl 链接：http://www.zhihu.com/question/28685048/answer/41735701 来源：知乎\n> 很多人并不理解补码。补码就是同余啊。1000000是正128你知道吧，正负128模256是同余的。加减乘可以直接算也是同余的定理决定的，而不是凑出来的巧合，哪可能凑出这种东西？\n  8位只能表示256个数，0到255，但我还想表示一些负数怎么办呢？就用与该负数同余的正数来表示呗。-1=255，-2=254，等等。\n  建议脱离算数的思维方式，这其实就是一个环。模任何一个正整数（如256），可以把所有整数分类，比如模256可分256类，0 256 -256...是一类（余0类），1 257 -255...是一类（余1类），等等，这256类可看作环的元素，你看-128和128是同一个类里的（余128类），用一个代表另一个罢了。补码和普通的unsigned integers都是在每类中选一个数，unsigned integers选0到255，补码表示的有符号整数选-128到127，都是一个数恰好对应一个类。当你明白这一切后，补码就是顺理成章的事。\n\n>> 同余:数论中的重要概念。给定一个正整数m，如果两个整数a和b满足（a-b）能够整除m，即（a-b）/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系。\n\n## IEEE 754标准\n作为一个JavaScript程序员，我们只有一个Number，所以我们从一开始就习惯了：\n```javascript\n  var num1 = 123;\n  var num2 = 1.23;\n```\n但是，你知道JS的number是`IEEE 754`标准的64-bits的双精度数值吗？这是一个什么样的标准？使用这个标准的64-bits双精度意味着什么？所以，要掌握JavaScript中的数字，我们首先得了解`IEEE 754`标准。下面，我将尝试说明一下这个标准，为我们最后学习JavaScript中的数字做铺垫。\n\n## 标准的基本原理：\n我们知道，对于计算机而言，数字没有小数和整数的差别，也就是计算机中没有小数点的存在。通过前文的讨论，我们已经找到了很完美的整数存储计算的方案，但是当涉及到小数，我们很容易发现，现有的方案无法解决我们的需求。然后，计算机科学家们便尝试了多种方案，主要便是`定点数`和`浮点数`两种。\n* 所谓定点数，是指小数点位置固定在数串中间的某个特定位置，点两侧分别为数字的整数和小数部分。比如用8-bits字长的数串，小数点固定在正中间位置，那么`11001001`和`00110101`分别表示`1100.1001`和`11.0101`两个数字。这种方案简单直观易理解，但是存在严重的空间浪费，以及容易溢出的问题。\n* 所谓浮点数，是指小数点的位置是不固定的，通过科学计数法(这个应该不需要解释吧)的方式控制小数点的位置，表示不同的数字。这个表示方案便是IEEE 754标准使用的方案。IEEE 754标准是目前使用最广泛的浮点数运算标准。下面我们将主要讨论一下此方案。\n\n现在，让我们想一下小时候学习的科学计数法，比如`-123.456`这个数字，转换成科学计数法应该是：`-1.23456 × 10^2`。这里面已经包含了IEEE 754标准的主要元素。我们梳理一下：第一个，自然是正负号的问题，需要一个标志；然后，需要一个具体的数字，表示有效数字或者精度，如上例的`1.23456`；再然后，需要一个控制小数点位置的数字，如上例的`10^2`，回忆一下，我们学习科学计数法的时候，要求前面的数字的绝对值大于1而小于10，也就是小于10^2中的底数(Base)，进制固定之后，底数应该是固定的，所以这里起决定作用的是指数，也就是上例中的2。那么，有了这三个元素，我们便可以很轻松的表示出一个数字，并且灵活的调节小数点位置从而控制数字正负、精度和大小。\n\n上面的要素，转换成标准语言描述，我们称表示正负的标志叫`符号(Sign)`，表示精度的数字为`尾数(Mantissa)`或者`有效数字(Significand)`，而控制小数点位置的指数就叫`指数(Exponent)`，指数和`基数(Base)`共同作用参与计算。下图取自wikipedia，我们直观地感受下这三个要素在一个数串中的相对关系（fraction区域即等同于前面说的有效数字区域）：\n{% asset_img 123.png %}\n了解最基本的原理后，我们来大致看一下`IEEE 754`标准做了什么。\n首先做的事情就是规定这三个要素在一个数串中占有的位数，试想一下，如果各个实现的位数不确定，那么我们是不是很难正确的还原出原始数字？`IEEE 754`标准规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80比特实做）。只有32位模式有强制要求，其他都是选择性的。而现在主流的语言，多提供了单精度和双精度的实现，我们在此主要比较一下这两者，如图是它们各个部分对应上图，所使用的位数如下：\n{% asset_img 456.png %}\n{% asset_img 789.png %}\n补充一点的是，无论是科学计数法还是标准的规定，都要求有效数字（不考虑符号位）必须`>=1 && <Base`。所以，有效数字其实是一个定点数，小数点的位置固定在有效数字域的最高位和次高位之间。那么，按照上述规定，在二进制中，最高位只能是`1`，所以标准要求省略其最高位，于是精度提高一位。比如，`32-bits`的单精度有效数字区域只有23位，但是精度却是24位；`64-bits`的双精度，拥有52位的有效数字域却是53位精度的。\n\n然后，还有一个问题，如果按照先有的约定，`是不是无法表示小于1的实数？`因为，`指数一定>=0，有效数字一定>1`。于是，`IEEE 754`标准提出了一个很重要的指数偏移值。它是说明指数域(Exponent占用的区域)的编码值为指数的实际值加上某个固定的值，换言之便是，如果我们根据指数域计算出的指数是`N`，那么参与计算实际浮点数的指数应该是`N-指数偏移值`。根据IEEE 754标准的规定，该固定值为`2^(e-1) - 1`，其中的`e`为存储指数的比特的长度。比如，从上图中我们看到，`32-bits`的单精度是以`8-bits表示一个指数域`，那么偏移值应该是`2^(8-1) - 1 = 128−1 = 127`。所以，容易得出，单精度浮点数的指数部分实际取值是`全零00000000 0-127=-127`到`全零11111111 256-127=128`就是`[-127,128]`。比如，某个`32-bits`单精度的指数为十进制的`1`，那么指数域的编码应该是`10000001`，某个32-bits单精度的指数域编码是`00000001`，那么该指数的实际值应该是十进制的`-126`。这样，我们就能通过偏移值将正指数转换为负指数，从而`使浮点数能逼近0`。浮点数的指数计算跟前面讨论的机器码恰好相反，`正数的最高位都是1，而负数的最高位都是0`。\n\n以上的描述，便是IEEE 754标准最需要我们了解的原理部分，但是，作为一个广泛使用的工业标准，规定这些还是远远不够的。\nwikipedia(维基百科)对IEEE 754标准有如下描述：\n>这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number）），一些特殊数值（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。\n\n下面，补充几个，我认为与本文后续讨论相关的或者可以帮助大家理解极端现象的定义：\n`规约形式的浮点数`:如果浮点数中指数部分的编码值在`0 < exponent < 2^(e-1)`之间，且尾数部分最高有效位（即整数）是1，那么这个浮点数将被称为规约形式的浮点数。也就是，严格按照我们上文描述编码的数字。\n`非规约形式的浮点数`:如果浮点数的指数部分的编码值是`0`，尾数为非零，那么这个浮点数将被称为非规约形式的浮点数。`IEEE 754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值大1`。例如，最小的规约形式的单精度浮点数的指数部分编码值为`1`，指数的实际值为`-126`；而非规约的单精度浮点数的指数域编码值为`0`，对应的指数实际值也是`-126`而不是`-127`。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近0。规约浮点数的尾数大于等于`1`且小于`2`，而非规约浮点数的尾数小于`1`且大于`0`。\n上面的两个概念，几乎是直接从wikipedia上扒下来的，·非规约形式的浮点数·出现的意义是避免突然式下溢出（abrupt underflow），而采用渐进式下溢出。这已经是上世纪70年代的事情了，差不多是我的年龄的两倍了。这个是一些非常极端的情况，在此我尝试最简单地描述一下`非规约形式的浮点数`出现的意义，知道有这么回事便可：下面，以单精度为例，如果没有`非规约形式的浮点数`，那么绝对值最小的两个相邻的浮点数之间的差值将是绝对值最小的浮点数的2^23分之一，大家想一下，绝对值次小的浮点数减去绝对值最小的浮点数的值是多少？\n\n```javascript\n  1.00...01 × 2^(-126) - 1.00...00 × 2^(-126) = 0.00..01 × 2^(-126) \n                                              = 1 × 2^(-126-23)\n                                              = 2^(-149)\n```\n很明显，绝对值最小的`规约数`无法表达其和次小的`规约数`的差值，所以很容易导致有若干数字之间的差值下溢，可能会触发意料之外的后果。而如果采用非规约形式的浮点数，指数全0，偏移值比规约数偏移值大1（`-126`比`-127`大1），尾数小于`1`，那么非规约数能表达的最小值便是：\n```javascript\n  0.00..01 × 2^(-126) = 1 × 2^(-126-23)\n                    = 2^(-149)\n```\n所以，`非规约形式的浮点`数解决了前述的`突然式下溢出（abrupt underflow）`而被标准采纳。\n`IEEE 754`标准还规定了三个特殊值：\n* 指数全0且尾数小数部分全0，则这个数字为±0。（符号位决定正负）\n* 指数为2^e - 1且尾数的小数部分全0，这个数字是±∞。（符号位决定正负）\n* 指数为2^e - 1且尾数的小数部分非0，这个数字是NaN。\n结合前面的规约数，非规约数以及三个特殊值，可以得到如下总结：\n{% asset_img 10.png %}\n现在，让我们回忆一下，各种语言中普遍描述的双精度浮点数的范围：`[-1.7 × 10^(-308),1.7 × 10^308]`。打个岔，想象一个有300多位的十进制数字的适用情形，私以为远超过普通人想象力的边界。这个范围为什么是这个范围呢？我觉得，通过上面的讨论，大家应该能清晰，1.7/308这些数字出现的必然原因。\n首先，我们应该很容易根据偏移量得出双精度浮点数的计算公式：\n{% asset_img 11.png %}\n然后，以正数为例，按照上述特殊值中`±∞`和`NaN`的约定，指数的最大值应该满足指数取规约数的指数范围的最大值，然后小数部分取小数部分的最大值，可以得出这个二进制的数字应该是：\n    0 11111111110 11..11(52个)\n转换为16进制表示：\n0x7fef ffff ffff ffff\n那么，根据前述规约数的原理，反编码便得到十进制的：`1.7976931348623157 x 10^308`。类似的道理，Sign位取反，便是范围的下限。\n到此为止吧，我对`IEEE 754`标准也是最近几天稍加学习，再说多了就误导大家了。通过这几天的学习，我感觉，我们在理解的IEEE 754标准及浮点数的时候，要特别注意将精度和范围两个概念分别开来。范围只是一个模糊的界限，精度才是能准确表达的数字。\n\n## 回到JavaScript\n在上面的讨论中，我们很少提及JavaScript，似乎有点背离今天的主题了，但是，在了解了前述的原理之后，我们对JavaScript中数字的把握将”水到渠成”。这终将是一次，铺垫多于正文，开胃菜多于正餐的讨论。嗯，快喊小伙伴，正餐开始了！\n### ES的”The Number Type”：\n现在，我们打开ES规范的[The Number Type](http://es5.github.io/#x8.5) 是不是基本通读下来了？\n比如：\n> The Number type has exactly 18437736874454810627 (that is, 2^64 − 2^53 + 3) values…\n为什么是这个数字？因为，我们说JavaScript中的数字是`64-bits`的双精度，所以首先有`2^64`中可能的组合，然后，按照前述的`IEEE 754`标准的标准中的特殊值中的部分，`NaN`和`±∞`占用了`2^53`个数值，但是表示了三个直观的量，所以，加减一下，自然就是`18437736874454810627` `(that is, 2^64 − 2^53 + 3)` values。\n> …the 9007199254740990 (that is, 2^53−2) distinct “Not-a-Number” values…\n为什么这么多`NaN`？同样，按照前述的`IEEE 754`标准的标准中的特殊值中的部分，`NaN`使用了`Significand非零`、`指数是特定2^e-1且Sign无要求的所有可能`，即`2^53`减去`±∞`两种情况。\n>…e is an integer ranging from −1074 to 971…\n为什么指数的范围是这个呢？而不是`-1022到+1022`呢？因为，ES演化了一下公式，对比一下我们之前演示`64-bits`的公式，关于参与计算的`mantissa`，我们按照`IEEE 754`标准在演示的时候中使用的是`1.m`，而ES规范中使用的是`m`，当然会有尾数域bit长度的差异了。\n\n到这里，关于数字，大概就可以结束了。开篇的几个问题，相信读到这里的同学，都能有答案了。但是，还有一个问题，JavaScript中的数字真的只有一种类型吗？，而且貌似到现在与我们的初衷，理解`>>>`有点偏离了。不过，世界上很多事情往往都是这样，解释原理需要到口干舌燥，而用原理去解释现象却只需要三言两语。\n\n### JavaScript不是只有64-bits的双精度\n是的，小标题已经回答了我们的问题，JavaScript不是只有`64-bits`的双精度。我们通篇都在说JavaScript中数字的各种，一直按照`64-bits`的双精度来描述，但是，如之前所说，ES中有`ToInteger/ToInt32/ToUint32/ToUint16`等Type Conversion。这些Type Conversion不是我们直接调用的API，而是语言引擎在进行某些特定操作的时候，替我们做的。这种“隐形的操作”，只有在一些极端的情况下，会表现出来。现在，我们可以到`“ToInt32”/“ToUint32”/“ToInt16”`三个地方看一下，稍作比较便能发现，他们的差异很小，只是在特定的步骤中存在差异。比如，`ToUint32和ToUint16`的差异仅仅操作的最后一步存在差异，按顺序列出比较一下：\n\n> Let int32bit be posInt modulo 2^32; that is, a finite integer value k of Number type with positive sign and less than 2^32 in magnitude such that the > mathematical difference of posInt and k is mathematically an integer multiple of 2^32.\n> \n>Return int32bit.\nvs\n> Let int16bit be posInt modulo 2^16; that is, a finite integer value k of Number type with positive sign and less than 2^16 in magnitude such that the mathematical difference of posInt and k is mathematically an integer multiple of 2^16.\n>\n>Return int16bit.\n\n比较一下，不难发现，仅仅是`2^32`和`2^16`的差异，而关键点恰是`modulo`操作的时候，按照我们之前讨论的原理，很容易理解这个操作决定了可能出现的最大数。这样的比较，有一好处，能提高我们阅读标准的速度，而且加深理解，对掌握标准很有帮助。\n总结一下这三个操作的范围：\n\n* ToInt32的范围便是其它强类型语言中的[-2^31, -2^31 - 1]。\n\n* ToUint32的范围便是其它强类型语言中的[0, -2^32 - 1]。\n\n* ToUint16的范围便是其它强类型语言中的[0, -2^16 - 1]。\n通过搜索，很容易能找到，JavaScript中那些操作中使用了上述相关的操作。其中，`ToUint16`仅仅在`String.fromCharCode`中有使用，我们不做讨论了。`ToInt32`有在多个位运算符中使用，比如`~` `/` `<<` `/` `>>`，以及在`parseIn`t也有使用。而`ToUint32`的使用则出现在了大量的地方，主要分布在`，数组相关的操作，位运算的操作`两个区域。\n我们就借`ToUint32`的这些使用，回到开篇讨论的那个地方吧：\n首先，来到这里[>>>](http://es5.github.io/#x11.7.3)，看到操作如下：\n> 1. Let lref be the result of evaluating ShiftExpression.\n> \n> 2. Let lval be GetValue(lref).\n> \n> 3. Let rref be the result of evaluating AdditiveExpression.\n>\n> 4. Let rval be GetValue(rref).\n>\n> 5. Let lnum be ToUint32(lval).\n> \n> 6. Let rnum be ToUint32(rval).\n> \n> 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.\nReturn the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.\n>\n再看new Array (len)，有一句：\n> If the argument len is a Number and ToUint32(len) is equal to len, then the length property of the newly constructed object is set to ToUint32(len). If the argument len is a Number and ToUint32(len) is not equal to len, a RangeError exception is thrown.\n对比不难发现，`>>>`的返回值和`array.length`的取值范围，无差异，经过`>>>`操作后的数字，一定是一个合法的`array.length`。解释原理总是那么复杂，可是用原理解释现象总是那么简单。\n\n## 将实数转换成浮点数\n\n### 浮点数的规范化\n同样的数值可以有多种浮点数表达方式，比如上面例子中的 123.45 可以表达为 12.345 × 101，0.12345 × 103 或者 1.2345 × 102。因为这种多样性，有必要对其加以规范化以达到统一表达的目标。规范的（Normalized）浮点数表达方式具有如下形式：`±d.dd...d × βe , (0 ≤ d i < β)`。\n其中 d.dd...d 即尾数，β 为基数，e 为指数。尾数中数字的个数称为精度，在本文中用 p 来表示。每个数字 d 介于 0 和基数之间，包括 0。小数点左侧的数字不为 0。\n基于规范表达的浮点数对应的具体值可由下面的表达式计算而得：`±(d 0 + d 1β-1 + ... + d p-1β-(p-1))βe , (0 ≤ d i < β)`\n对于十进制的浮点数，即基数 β 等于 10 的浮点数而言，上面的表达式非常容易理解，也很直白。计算机内部的数值表达是基于二进制的。从上面的表达式，我们可以知道，二进制数同样可以有小数点，也同样具有类似于十进制的表达方式。只是此时 β 等于 2，而每个数字 d 只能在 0 和 1 之间取值。比如二进制数 1001.101 相当于 1 × 2<sup>3</sup> + 0 × 2<sup>2</sup> + 0 × 2<sup>1</sup> + 1 × 2<sup>0</sup> + 1 × 2<sup>-1</sup> + 0 × 2<sup>-2</sup> + 1 × 2<sup>-3</sup>，对应于十进制的 9.625。其规范浮点数表达为 1.001101 × 2<sup>3</sup>。\n\n### 根据精度表示浮点数\n\n问：要把小数装入计算机，总共分几步？你猜对了，3 步。\n\n* 第一步：转换成二进制。\n* 第二步：用二进制科学计算法表示。\n* 第三步：表示成 IEEE 754 形式。\n\n#### 如何把十进制小数转换成二进制小数。\n十进制小数转换成二进制小数采用\"乘2取整，顺序排列\"法。\n具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。\n* 如：25.7=（11001.10110011001100110011001100110011...）B\n  * 整数部分：\n        25%2 = 1 ======== 1\n        12%2 = 0 ======== 0\n        6%2  = 3 ======== 0\n        3%2  = 1 ======== 1\n        1%2  = 1 ======== 1\n * 小数部分：\n        0.7*2=1.4========取出整数部分1 \n        0.4*2=0.8========取出整数部分0 \n        0.8*2=1.6========取出整数部分1 \n        0.6*2=1.2========取出整数部分1 \n        0.2*2=0.4========取出整数部分0　 \n        0.4*2=0.8========取出整数部分0 \n        0.8*2=1.6========取出整数部分1 \n        0.6*2=1.2========取出整数部分1 \n        0.2*2=0.4========取出整数部分0 \n * 最后结果就是： \n        11001.1 0110 0110 0110 0110 0110 0110 0110 0110 0110...\n \n#### 用二进制科学计算法表示\n  11001.101100110 == 1.1001101100110 * 2<sup>4</sup>\n#### 表示成 IEEE 754 形式\n1. 正数 固符号位为 0 \n2. 尾数 由于第一位使用是1,固取(首位1干掉了).10011 0110 0110 0110 0110 0110 0110 0110 0110 0110\n3. 指数 4 + 1023(偏移量),转换为 二进制就是 10000000011\n组合在一起就是 0 10000000011 10011 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 011\n\n> 单精度32位的 偏移量是  Math.pow(2,8)/2 -1 == 127 ，双精度64位的偏移量是 Math.pow(2,11)/2 -1 == 1023 \n\n### 哪些数能精确表示？\n那么 0.1 在计算机中可以精确表示吗？答案是出人意料的， 不能。\n\n在此之前，先思考个问题： `在 0.1 到 0.9 的 9 个小数中，有多少可以用二进制精确表示呢？`\n\n我们按照乘以 2 取整数位的方法，把 0.1 表示为二进制（我假设那些不会进制转换的同学已经补习完了）：\n\n(1) 0.1 x 2 = 0.2  取整数位 0 得 0.0\n(2) 0.2 x 2 = 0.4  取整数位 0 得 0.00\n(3) 0.4 x 2 = 0.8  取整数位 0 得 0.000\n(4) 0.8 x 2 = 1.6  取整数位 1 得 0.0001\n(5) 0.6 x 2 = 0.2  取整数位 1 得 0.00011\n(6) 0.2 x 2 = 0.4  取整数位 0 得 0.000110\n(7) 0.4 x 2 = 0.8  取整数位 0 得 0.0001100\n(8) 0.8 x 2 = 1.6  取整数位 1 得 0.00011001\n(9) 0.6 x 2 = 1.2  取整数位 1 得 0.000110011\n(n) ...\n我们得到一个无限循环的二进制小数 0.000110011…\n\n我为什么要把这个计算过程这么详细的写出来呢？就是为了让你看，多看几遍，再多看几遍，继续看… 还没看出来，好吧，把眼睛揉一下，我提示你，把第一行去掉，从 (2) 开始看，看到 (6)，对比一下 (2) 和 (6)。 然后把前两行去掉，从 (3) 开始看…\n明白了吧，0.2、0.4、0.6、0.8 都不能精确的表示为二进制小数。 难以置信，这可是所有的偶数啊！那奇数呢？ 答案就是：\n0.1 到 0.9 的 9 个小数中，只有 0.5 可以用二进制精确的表示。\n**如果把 0.0 再算上，那么就有两个数可以精确表示，一个奇数 0.5，一个偶数 0.0。** \n\n那么到底怎么确定一个数能否精确表示呢？还是回到我们熟悉的十进制分数。\n\n1/2、5/9、34/25 哪些可以写成有限小数？把一个分数化到最简（分子分母无公约数），如果分母的因式分解只有 2 和 5，那么就可以写成有限小数，否则就是无限循环小数。为什么是 2 和 5 呢？因为他们是 10 的因子 10 = 2 x 5。二进制和十六进制呢？他们的因子只有 2，所以十六进制只是二进制的一种简写形式，它的精度和二进制一样。\n**如果一个十进制数可以用二进制精确表示，那么它的最后一位肯定是 5。备注：这是个必要条件，而不是充分条件。**\n\n###  为啥 0.2+0.4 不等于0.6\n```javascript\n0.2 + 0.4 //0.6000000000000001\n```\n1.6 + 2.8 = 4.4 \n四舍五入得到 4。我们用另一种方法\n先把 1.6 四舍五入为 2\n再把 2.8 四舍五入为 3\n最后求和 2 + 3 = 5\n通过两种运算，我们得到了两个结果 4 和 5。同理，在我们的浮点数运算中，参与运算的两个数 0.2 和 0.4 精度已经丢失了，所以他们求和的结果已经不是 0.6 了。\n\n## 特殊值\n\n* 指数域不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数的计算值减去127（或1023），得到真实值，再将尾数前加上第一位的1。\n* 指数域全为0。这时，浮点数的指数等于1-127（或者1-1023），尾数不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。\n* 指数域全为1。这时，如果尾数全为0，表示±无穷大（正负取决于符号位s）；如果尾数不全为0，表示这个数不是一个数（NaN）。\n\n### NaN(Not a Number)\nNaN 用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。\nNaN 指数域全为 1，且尾数域不等于零的浮点数。IEEE 标准没有要求具体的尾数域，所以 NaN 实际上不是一个，而是一族。不同的实现可以自由选择尾数域的值来表达 NaN。\n任何有 NaN 作为操作数的操作也将产生 NaN。用特殊的 NaN 来表达上述运算错误的意义在于避免了因这些错误而导致运算的不必要的终止。回顾我们对 NaN 的介绍，当零除以零时得到的结果不是无穷而是 NaN 。原因不难理解，当除数和被除数都逼近于零时，其商可能为任何值，所以 IEEE 标准决定此时用 NaN 作为商比较合适。\n### 有符号的零\n因为 IEEE 标准的浮点数格式中，小数点左侧的 1 是隐藏的，而零显然需要尾数必须是零。所以，零也就无法直接用这种格式表达而只能特殊处理。\n实际上，零保存为尾数域为全为 0，指数域为 emin - 1 = -127，也就是说指数域也全为 0。考虑到符号域的作用，所以存在着两个零，即 +0 和 -0。不同于正负无穷之间是有序的，IEEE 标准规定正负零是相等的。\n零有正负之分，的确非常容易让人困惑。这一点是基于数值分析的多种考虑，经利弊权衡后形成的结果。有符号的零可以避免运算中，特别是涉及无穷的运算中，符号信息的丢失。举例而言，如果零无符号，则等式 1/(1/x) = x 当x = ±∞ 时不再成立。原因是如果零无符号，1 和正负无穷的比值为同一个零，然后 1 与 0 的比值为正无穷，符号没有了。解决这个问题，除非无穷也没有符号。但是无穷的符号表达了上溢发生在数轴的哪一侧，这个信息显然是不能不要的。零有符号也造成了其它问题，比如当 x=y 时，等式1/x = 1/y 在 x 和 y 分别为 +0 和 -0 时，两端分别为正无穷和负无穷而不再成立。当然，解决这个问题的另一个思路是和无穷一样，规定零也是有序的。但是，如果零是有序的，则即使 if (x==0) 这样简单的判断也由于 x 可能是 ±0 而变得不确定了。两害取其轻者，零还是无序的好。\n\n注： 本文转自 [随心小筑](http://jser.it/blog/2014/07/07/numbers-in-javascript/) 我自己做了本分填充和整理","slug":"numberInJavaScript","published":1,"updated":"2016-06-19T13:52:33.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7rt0015543vz7a5hogp"},{"title":"js中函数参数都是按值传递的","date":"2016-02-22T02:17:58.000Z","comments":1,"_content":"## 问题的起源\n其实这个问题来源于C和C++,因为C或C++里都有一个特殊的数据类型----指针，那时候所谓的传值和传引用是对指针来说的。那么针对指针来说，什么是传值，又什么是传引用呢？首先，指针作为一种数据类型，其本身肯定是占用一定的内存空间，而且指针同时还要指向另一块内存空间。\n<!--more-->\n{% asset_img image5.png %}\n针对指针来说，指针作为一种数据类型，指针的标识符也就是其在内存中所在的地址，指针的值就是其所指向的地址。也就是说，指针值是地址。\n那么一个指针在作为函数的参数的时候，传给参数的到底是指针的地址还是指针的值呢？ ----这就是传值和传引用问题的起源。\n## 数据类型\n在 javascript 中数据类型可以分为两类：\n* 原始数据类型 primitive type，比如Undefined、Null、Boolean、Number、String(除外)。\n* 引用类型 Object type，比如Object、Array、Function、Date等。\n\nPS：本文所说的原始数据类型也称为简单数据类型，引用类型也称为复杂数据类型。\n## 声明变量时不同的内存分配\n** 原始值：** 存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。String类型除外。\n** 引用值** ：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。\n{% asset_img image1.jpg %}\n## 不同的内存分配机制也带来了不同的访问机制\n在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值则是可以直接访问到的。\n\n## 复制变量时的不同\n** 原始值：**在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。\n{% asset_img image2.jpg %}\n** 引用值：**在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）\n{% asset_img image3.jpg %}\n\n## 函数参数传递的不同\n首先我们应该明确一点：** ECMAScript中所有函数的参数都是按值来传递的。**但是为什么涉及到原始类型与引用类型的值时仍然有区别呢，还不就是因为内存分配时的差别。\n** 原始值：**只是把变量里的值传递给参数，之后参数和这个变量互不影响。\n** 引用值：**对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象呀。或许我这么说了以后你对书上的例子还是有点不太理解，那么请看图吧：\n{% asset_img image4.jpg %}\n{% asset_img image13.png %}\n所以，如果是按引用传递的话，是把第二格中的内容（也就是变量本身）整个传递进去（就不会有第四格的存在了）。但事实是变量把它里面的值传递（复制）给了参数，让这个参数也指向原对象。因此如果在函数内部给这个参数赋值另一个对象时，这个参数就会更改它的值为新对象的内存地址指向新的对象，但此时原来的变量仍然指向原来的对象，这时候他们是相互独立的；但如果这个参数是改变对象内部的属性的话，这个改变会体现在外部，因为他们共同指向的这个对象被修改了呀！\n{% asset_img image14.png %}\n对于传引用来说，形参的值是指针的地址，那么每次对形参的改变，其实改变的都是指针所指向的地址。而如果向取得结构体的地址，也需要通过实参的地址。\n## 特殊的类型---String\n字符串也是一种数据类型，那么字符串的值保存在哪里呢？ 其作为函数参数的时候，传值是如何进行的呢？\n字符串虽然也是一种基本数据类型，但因为其大小不固定，所以，其一般其更像与引用数据类型。但其又有其特殊性----不可变性。\n ### 什么是字符串的不可变？\n ```javascript\nvar str = \"\";\nfor (var i = 0; i < 3; i++) {\n    str += i;\n}\nconsole.log(str); //012\n```\n看上图程序，字符串是可以改变的。那为什么还要说，字符串不可变呢，先别急，我们来分析一下程序运行时内存结构图。\n{% asset_img image7.png %}\n{% asset_img image8.png %} \n{% asset_img image9.png %} \n{% asset_img image10.png %}\n看到没有，每一次字符串值的改变，其所指向的地址都会跟着改变一次。其所说的不可变，是跟引用数据类型相比来说，引用数据类型值的改变一般是对象本身的改变，而其指向是不变的，而字符串值的改变是其指向地址的改变。所以，字符串的每一次改变都会产生垃圾,此垃圾过一段时间会被垃圾回收机制回收。\n\n了解了上述的情况，所以字符传在作为传值的时候，为了节省空间，只是复制了字符串所指向的地址给形参，而形参的值如果改变了的话，因为字符串具有不可变特性，所以会重新开辟一份空间给形参。如下:\n```javascript\nvar str = '你是谁？';\nfunction change(str) {\n    str = '我就是我了';\n}\nchange(str);\nconsole.log(str); //你是谁\n```\n{% asset_img image11.png %}\n{% asset_img image12.png %}\n字符串在Java C++中均作为比较特殊的一种类型，JS中虽然将其当作一种基本数据类型，但是其使用时更偏向于引用数据类型，但是其又具有不可变型，才促使我们可以将其当作基本数据类型使用。\n> 转自：http://www.th7.cn/web/js/201503/90277.shtml\n> 转自：http://fehacker.com/2014/12/19/call-by-sharing/\n","source":"_posts/js中函数参数都是按值传递的-2016-02-22.md","raw":"title: js中函数参数都是按值传递的\ndate: 2016-02-22 10:17:58\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n## 问题的起源\n其实这个问题来源于C和C++,因为C或C++里都有一个特殊的数据类型----指针，那时候所谓的传值和传引用是对指针来说的。那么针对指针来说，什么是传值，又什么是传引用呢？首先，指针作为一种数据类型，其本身肯定是占用一定的内存空间，而且指针同时还要指向另一块内存空间。\n<!--more-->\n{% asset_img image5.png %}\n针对指针来说，指针作为一种数据类型，指针的标识符也就是其在内存中所在的地址，指针的值就是其所指向的地址。也就是说，指针值是地址。\n那么一个指针在作为函数的参数的时候，传给参数的到底是指针的地址还是指针的值呢？ ----这就是传值和传引用问题的起源。\n## 数据类型\n在 javascript 中数据类型可以分为两类：\n* 原始数据类型 primitive type，比如Undefined、Null、Boolean、Number、String(除外)。\n* 引用类型 Object type，比如Object、Array、Function、Date等。\n\nPS：本文所说的原始数据类型也称为简单数据类型，引用类型也称为复杂数据类型。\n## 声明变量时不同的内存分配\n** 原始值：** 存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。String类型除外。\n** 引用值** ：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。\n{% asset_img image1.jpg %}\n## 不同的内存分配机制也带来了不同的访问机制\n在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值则是可以直接访问到的。\n\n## 复制变量时的不同\n** 原始值：**在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。\n{% asset_img image2.jpg %}\n** 引用值：**在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）\n{% asset_img image3.jpg %}\n\n## 函数参数传递的不同\n首先我们应该明确一点：** ECMAScript中所有函数的参数都是按值来传递的。**但是为什么涉及到原始类型与引用类型的值时仍然有区别呢，还不就是因为内存分配时的差别。\n** 原始值：**只是把变量里的值传递给参数，之后参数和这个变量互不影响。\n** 引用值：**对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象呀。或许我这么说了以后你对书上的例子还是有点不太理解，那么请看图吧：\n{% asset_img image4.jpg %}\n{% asset_img image13.png %}\n所以，如果是按引用传递的话，是把第二格中的内容（也就是变量本身）整个传递进去（就不会有第四格的存在了）。但事实是变量把它里面的值传递（复制）给了参数，让这个参数也指向原对象。因此如果在函数内部给这个参数赋值另一个对象时，这个参数就会更改它的值为新对象的内存地址指向新的对象，但此时原来的变量仍然指向原来的对象，这时候他们是相互独立的；但如果这个参数是改变对象内部的属性的话，这个改变会体现在外部，因为他们共同指向的这个对象被修改了呀！\n{% asset_img image14.png %}\n对于传引用来说，形参的值是指针的地址，那么每次对形参的改变，其实改变的都是指针所指向的地址。而如果向取得结构体的地址，也需要通过实参的地址。\n## 特殊的类型---String\n字符串也是一种数据类型，那么字符串的值保存在哪里呢？ 其作为函数参数的时候，传值是如何进行的呢？\n字符串虽然也是一种基本数据类型，但因为其大小不固定，所以，其一般其更像与引用数据类型。但其又有其特殊性----不可变性。\n ### 什么是字符串的不可变？\n ```javascript\nvar str = \"\";\nfor (var i = 0; i < 3; i++) {\n    str += i;\n}\nconsole.log(str); //012\n```\n看上图程序，字符串是可以改变的。那为什么还要说，字符串不可变呢，先别急，我们来分析一下程序运行时内存结构图。\n{% asset_img image7.png %}\n{% asset_img image8.png %} \n{% asset_img image9.png %} \n{% asset_img image10.png %}\n看到没有，每一次字符串值的改变，其所指向的地址都会跟着改变一次。其所说的不可变，是跟引用数据类型相比来说，引用数据类型值的改变一般是对象本身的改变，而其指向是不变的，而字符串值的改变是其指向地址的改变。所以，字符串的每一次改变都会产生垃圾,此垃圾过一段时间会被垃圾回收机制回收。\n\n了解了上述的情况，所以字符传在作为传值的时候，为了节省空间，只是复制了字符串所指向的地址给形参，而形参的值如果改变了的话，因为字符串具有不可变特性，所以会重新开辟一份空间给形参。如下:\n```javascript\nvar str = '你是谁？';\nfunction change(str) {\n    str = '我就是我了';\n}\nchange(str);\nconsole.log(str); //你是谁\n```\n{% asset_img image11.png %}\n{% asset_img image12.png %}\n字符串在Java C++中均作为比较特殊的一种类型，JS中虽然将其当作一种基本数据类型，但是其使用时更偏向于引用数据类型，但是其又具有不可变型，才促使我们可以将其当作基本数据类型使用。\n> 转自：http://www.th7.cn/web/js/201503/90277.shtml\n> 转自：http://fehacker.com/2014/12/19/call-by-sharing/\n","slug":"js中函数参数都是按值传递的","published":1,"updated":"2016-02-22T03:35:12.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7sh0018543vpck309sc"},{"title":"ECMAScrip中的对象存取器:getter和setter","date":"2016-01-21T09:34:17.000Z","comments":1,"_content":"显然这是一个无关IE（高级IE除外）的话题，尽管如此，有兴趣的同学还是一起来认识一下ECMAScript5标准中getter和setter的实现。在一个对象中，操作其中的属性或方法，通常运用最多的就是读（引用）和写了，譬如说o.get，这就是一个读的操作，而o.set = 1则是一个写的操作。事实上在除ie外最新主流浏览器的实现中，任何一个对象的键值都可以被getter和setter方法所取代，这被称之为“存取器属性”。\n<!--more-->\n毫无疑问，getter负责查询值，它不带任何参数，setter则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的return都是无效的。和普通属性不同的是，存储器属性在只声明了get或set时，对于读和写是两者不可兼得的，当它只拥有了getter方法，那么它仅仅只读，同样的，当它只有setter方法，那么您读到的永远都是undefined。如何声明对象存储器属性呢？ 最快捷的途径就是利用对象字面量的语法来写了，请看下述一段代码：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            return 'man';\n        }\n    };\n    //显然这是不允许的，因为贤心并不希望外界去改变他是男性的事实，所以对于sex只设置了只读功能\n    oo.sex = 'woman';//在严格模式下报错。\n    console.log(oo.sex); //结果依然是man\n有意思的是，这颠覆了我们以往的理解，就是在方法定义时并未用function关键字。事实上这里的get或set，你可以理解为两种不同状态下的function：包容的一面（写），安全的一面（读），当一种整体被肢解为不同的形态，意味着我们可能不再需要在表现形式上遵循传统，所以我们并没有使用冒号将键和值分开。那么，继续上面的例子。你将如何在存储器属性的基础上变得读写兼备呢，也许下面的一段会给你带来答案：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            if(this.sexx){\n                return this.sexx;\n            }else{\n                return 'man';\n            }\n        }, set sex(val){\n            this.sexx = val;\n        }\n    };\n    //噢，他如此包容，乃至于人们改变他的性别，他也接受\n    oo.sex = 'woman';\n    console.log(oo.sex); //结果woman\n\n或许你会觉得这是多此一举的，因为我们完全可以忽视get和set，直接让sex方法具备两种权限。 但之所以我们将get和set单独拿出来，是为了更加清晰地理解ECMAScript5对javascript对象键值操作中，一个更为严谨的诠释。 当然，在IE污染的中国，新型的主流技术总是显得格格不入，在实际的项目开发中，也许你永远不会用到get和set，但谁又能保证以后不会呢……\n\n摘自：[贤心博客](http://sentsin.com/web/20.html)\n","source":"_posts/ECMAScrip中的对象存取器-getter和setter-2016-01-21.md","raw":"title: 'ECMAScrip中的对象存取器:getter和setter'\ndate: 2016-01-21 17:34:17\ntags:\n- JavaScript\ncomments: true\n---\n显然这是一个无关IE（高级IE除外）的话题，尽管如此，有兴趣的同学还是一起来认识一下ECMAScript5标准中getter和setter的实现。在一个对象中，操作其中的属性或方法，通常运用最多的就是读（引用）和写了，譬如说o.get，这就是一个读的操作，而o.set = 1则是一个写的操作。事实上在除ie外最新主流浏览器的实现中，任何一个对象的键值都可以被getter和setter方法所取代，这被称之为“存取器属性”。\n<!--more-->\n毫无疑问，getter负责查询值，它不带任何参数，setter则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的return都是无效的。和普通属性不同的是，存储器属性在只声明了get或set时，对于读和写是两者不可兼得的，当它只拥有了getter方法，那么它仅仅只读，同样的，当它只有setter方法，那么您读到的永远都是undefined。如何声明对象存储器属性呢？ 最快捷的途径就是利用对象字面量的语法来写了，请看下述一段代码：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            return 'man';\n        }\n    };\n    //显然这是不允许的，因为贤心并不希望外界去改变他是男性的事实，所以对于sex只设置了只读功能\n    oo.sex = 'woman';//在严格模式下报错。\n    console.log(oo.sex); //结果依然是man\n有意思的是，这颠覆了我们以往的理解，就是在方法定义时并未用function关键字。事实上这里的get或set，你可以理解为两种不同状态下的function：包容的一面（写），安全的一面（读），当一种整体被肢解为不同的形态，意味着我们可能不再需要在表现形式上遵循传统，所以我们并没有使用冒号将键和值分开。那么，继续上面的例子。你将如何在存储器属性的基础上变得读写兼备呢，也许下面的一段会给你带来答案：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            if(this.sexx){\n                return this.sexx;\n            }else{\n                return 'man';\n            }\n        }, set sex(val){\n            this.sexx = val;\n        }\n    };\n    //噢，他如此包容，乃至于人们改变他的性别，他也接受\n    oo.sex = 'woman';\n    console.log(oo.sex); //结果woman\n\n或许你会觉得这是多此一举的，因为我们完全可以忽视get和set，直接让sex方法具备两种权限。 但之所以我们将get和set单独拿出来，是为了更加清晰地理解ECMAScript5对javascript对象键值操作中，一个更为严谨的诠释。 当然，在IE污染的中国，新型的主流技术总是显得格格不入，在实际的项目开发中，也许你永远不会用到get和set，但谁又能保证以后不会呢……\n\n摘自：[贤心博客](http://sentsin.com/web/20.html)\n","slug":"ECMAScrip中的对象存取器-getter和setter","published":1,"updated":"2016-01-21T09:37:50.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7u5001e543vcgctbolw"},{"title":"onload vs DOMContentLoaded","date":"2016-01-08T02:27:11.000Z","comments":1,"_content":"* `$(document).ready(function () { });`\n* `$(function () { });`\n\n以上两行代码的目的和效果都一样———待DOM加载完成之后，执行传入的function函数。\n\n这是我们在页面初始化时经常使用的监听方案，那么他的实际的执行关系时什么样的呢？\n在原生js中是什么样的一种表现？\n<!--more-->\n## 定义\n+ onload:\n当onload事件触发的时候，页面上的所有dom，样式表，脚本，图片，flash，iframe都已经加载完成了。\n+ DOMContentLoaded:\n当DOMContentLoaded事件触发时，仅当dom加载完成，不包括样式表，图片，flash，iframe\n\n光看定义，一目了然，哪个比较适合作为我们判断的标准：图片啊什么的，我们完全可以不用等。\n\n在某些Gecko和Webkit引擎版本的浏览器里面，包括IE8在内，会同时发起多个http的请求并行加载样式表和脚步，但是脚本会等样式表加载完成之后才会被执行，甚至样式表加载之前页面都不会渲染。opera不会，样式表未加载好就可以执行js。\n\n{% asset_img onLoadVSDomContentLoaded.png %}\n\n### 兼容方案\n#### ie8及以下兼容处理方案\nie的一般处理方案 --- `onreadystatechange` 事件。\nhtml加载过程中会有一个document.readyState状态\n五种状态：\n+ 0（未初始化）：还没有send\n+ 1 loading（载入）：正在发送请求\n+ 2 loaded（载入完成）：执行完成，已经接收到全部响应内容\n+ 3 interactive（交互）： 正在解析响应内容\n+ 4 complete（完成）： 响应内容解析完成，客户端可以用了。\n*complete事件和window.onload事件是同时的。*\n\n这就是要监听页面的readystatechange事件，当事件为interactive或者complete时就可以开始做js的事情了。但是如果我们注册 ready 函数的时间点太晚了，这时页面已经加载完成，而我们才注册自己的 ready 函数，那就用不着上面的层层检查了，直接看看当前页面的 readyState 就可以了，如果已经是 complete ，那就可以直接执行我们准备注册的 ready 函数了。不过 ChrisS 报告了一个很特别的错误情况，我们需要延迟一下执行。\n\n> setTimeout 经常被用来做网页上的定时器，允许为它指定一个毫秒数作为间隔执行的时间。当被启动的程序需要在非常短的时间内运行，我们就会给它指定一个很小的时间数，或者需要马上执行的话，我们甚至把这个毫秒数设置为0，但事实上，setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的毫秒数设置为0，被调用的程序也没有马上启动。这个最小的时间间隔是多少呢？这和浏览器及操作系统有关。在John Resig的新书《Javascript忍者的秘密》一书中提到。\n>> Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。\n\n既然规范都是这样写的，那看来使用setTimeout是没办法再把这个最小时间间隔缩短了。这样，通过设置为 1, 我们可以让程序在浏览器支持的最小时间间隔之后执行了。\n\n```javascript\n    if (document.readyState === \"complete\") {\n        // 延迟 1 毫秒之后，执行 ready 函数\n        setTimeout(jQuery.ready, 1);\n    }\n```\n\n#### doScroll 检测法\n但是当页面中带有iframe时，这个readyState状态会挂起一直等待，等待页面的iframe也加载完毕之后再处理，这个过程是我们不想要得，那就有另外一种处理方案。\n> MSDN 关于 JScript 的一个方法有段不起眼的话，当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了！Diego Perini 在 2007 年的时候，报告了一种检测 IE 是否加载完成的方式，使用 doScroll 方法调用。详细的说明见这里。原理是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在本例中每间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。\n\n```javascript\n    (function doScrollCheck() {\n        if (!jQuery.isReady) {  \n            try {\n                // Use the trick by Diego Perini\n                // http://javascript.nwbox.com/IEContentLoaded/\n                top.doScroll(\"left\");\n            } catch (e) {\n                return setTimeout(doScrollCheck, 50);\n            }   \n            // and execute any waiting functions\n            jQuery.ready();\n        }\n    })();\n```\n\n#### jQuery的实现  \n\n```javascript\n    //全局方法\n    DOMContentLoaded = function() {\n        if ( document.addEventListener ) {\n            document.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n            jQuery.ready();\n        } else if ( document.readyState === \"complete\" ) {\n            // we're here because readyState === \"complete\" in oldIE\n            // which is good enough for us to call the dom ready!\n            document.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n            jQuery.ready();\n        }\n    }\n\n    //入口 jquery实例调用\n    ready: function( fn ) {\n        // Add the callback\n        jQuery.ready.promise().done( fn );\n\n        return this;\n    }\n\n    jQuery.ready.promise = function( obj ) {\n        if ( !readyList ) {\n\n            readyList = jQuery.Deferred();\n\n            // Catch cases where $(document).ready() is called after the browser event has already occurred.\n            // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n            // 当页面加载完了，直接调用ready方法\n            if ( document.readyState === \"complete\" ) {\n                // Handle it asynchronously to allow scripts the opportunity to delay ready\n                setTimeout( jQuery.ready, 1 );\n\n            // Standards-based browsers support DOMContentLoaded\n            } else if ( document.addEventListener ) {\n                // Use the handy event callback\n                document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\n                // A fallback to window.onload, that will always work\n                window.addEventListener( \"load\", jQuery.ready, false );\n\n            // If IE event model is used\n            } else {\n                // Ensure firing before onload, maybe late but safe also for iframes\n                document.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n\n                // A fallback to window.onload, that will always work\n                window.attachEvent( \"onload\", jQuery.ready );\n\n                // If IE and not a frame\n                // continually check to see if the document is ready\n                var top = false;\n\n                try {\n                    top = window.frameElement == null && document.documentElement;\n                } catch(e) {}\n\n                if ( top && top.doScroll ) {\n                    (function doScrollCheck() {\n                        if ( !jQuery.isReady ) {\n\n                            try {\n                                // Use the trick by Diego Perini\n                                // http://javascript.nwbox.com/IEContentLoaded/\n                                top.doScroll(\"left\");\n                            } catch(e) {\n                                return setTimeout( doScrollCheck, 50 );\n                            }\n\n                            // and execute any waiting functions\n                            jQuery.ready();\n                        }\n                    })();\n                }\n            }\n        }\n        return readyList.promise( obj );\n    };\n\n    jQuery.extend({\n        // 表示ready方法是否正在执行，若正在执行，则将isReady设置为true\n        isReady: false,\n\n        // ready方法执行前需要等待的次数\n        readyWait: 1,\n\n        // hold或者释放ready方法，若参数为true则readyWait++，否则执行ready，传入参数为true\n        holdReady: function( hold ) {\n            if ( hold ) {\n                jQuery.readyWait++;\n            } else {\n                jQuery.ready( true );\n            }\n        },\n\n        // 当DOM加载完毕时开始执行ready\n        ready: function( wait ) {\n\n            // 若传入的参数为true，则--readyWait；否则判断isReady，即ready是否正在执行  \n            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n                return;\n            }\n\n            // Remember that the DOM is ready\n            jQuery.isReady = true;\n\n            // 若readyWait-1后还是大于0，则返回，不执行ready。\n            if ( wait !== true && --jQuery.readyWait > 0 ) {\n                return;\n            }\n\n            // If there are functions bound, to execute\n            readyList.resolveWith( document, [ jQuery ] );\n\n            // 触发ready方法，然后解除绑定的ready方法。\n            if ( jQuery.fn.triggerHandler ) {\n                jQuery( document ).triggerHandler( \"ready\" );\n                jQuery( document ).off( \"ready\" );\n            }\n        }\n    });\n```\n根据以上代码可见，最终DOMContented事件执行的，其实是jQUery.ready()这个工具函数。\n（注意，jquery.ready()和jquery(document).raedy()不一样！！，前者是工具函数，后者是实例函数。）\n这里是通过定义一个DOMContentLoaded函数作为桥梁来执行jquery.ready()函数的，这样做的目的就是为了及时的remove掉document的DOMContentLoaded事件的引用。\n{% asset_img zongjie.png %}\n推荐好文:  [何控制jquery的ready事件](http://www.xiabingbao.com/jquery/2015/06/27/jquery-holdready/)\n","source":"_posts/DOMContentLoaded-2016-01-08.md","raw":"title: onload vs DOMContentLoaded\ndate: 2016-01-08 10:27:11\ntags:\n- jQuery\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n* `$(document).ready(function () { });`\n* `$(function () { });`\n\n以上两行代码的目的和效果都一样———待DOM加载完成之后，执行传入的function函数。\n\n这是我们在页面初始化时经常使用的监听方案，那么他的实际的执行关系时什么样的呢？\n在原生js中是什么样的一种表现？\n<!--more-->\n## 定义\n+ onload:\n当onload事件触发的时候，页面上的所有dom，样式表，脚本，图片，flash，iframe都已经加载完成了。\n+ DOMContentLoaded:\n当DOMContentLoaded事件触发时，仅当dom加载完成，不包括样式表，图片，flash，iframe\n\n光看定义，一目了然，哪个比较适合作为我们判断的标准：图片啊什么的，我们完全可以不用等。\n\n在某些Gecko和Webkit引擎版本的浏览器里面，包括IE8在内，会同时发起多个http的请求并行加载样式表和脚步，但是脚本会等样式表加载完成之后才会被执行，甚至样式表加载之前页面都不会渲染。opera不会，样式表未加载好就可以执行js。\n\n{% asset_img onLoadVSDomContentLoaded.png %}\n\n### 兼容方案\n#### ie8及以下兼容处理方案\nie的一般处理方案 --- `onreadystatechange` 事件。\nhtml加载过程中会有一个document.readyState状态\n五种状态：\n+ 0（未初始化）：还没有send\n+ 1 loading（载入）：正在发送请求\n+ 2 loaded（载入完成）：执行完成，已经接收到全部响应内容\n+ 3 interactive（交互）： 正在解析响应内容\n+ 4 complete（完成）： 响应内容解析完成，客户端可以用了。\n*complete事件和window.onload事件是同时的。*\n\n这就是要监听页面的readystatechange事件，当事件为interactive或者complete时就可以开始做js的事情了。但是如果我们注册 ready 函数的时间点太晚了，这时页面已经加载完成，而我们才注册自己的 ready 函数，那就用不着上面的层层检查了，直接看看当前页面的 readyState 就可以了，如果已经是 complete ，那就可以直接执行我们准备注册的 ready 函数了。不过 ChrisS 报告了一个很特别的错误情况，我们需要延迟一下执行。\n\n> setTimeout 经常被用来做网页上的定时器，允许为它指定一个毫秒数作为间隔执行的时间。当被启动的程序需要在非常短的时间内运行，我们就会给它指定一个很小的时间数，或者需要马上执行的话，我们甚至把这个毫秒数设置为0，但事实上，setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的毫秒数设置为0，被调用的程序也没有马上启动。这个最小的时间间隔是多少呢？这和浏览器及操作系统有关。在John Resig的新书《Javascript忍者的秘密》一书中提到。\n>> Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。\n\n既然规范都是这样写的，那看来使用setTimeout是没办法再把这个最小时间间隔缩短了。这样，通过设置为 1, 我们可以让程序在浏览器支持的最小时间间隔之后执行了。\n\n```javascript\n    if (document.readyState === \"complete\") {\n        // 延迟 1 毫秒之后，执行 ready 函数\n        setTimeout(jQuery.ready, 1);\n    }\n```\n\n#### doScroll 检测法\n但是当页面中带有iframe时，这个readyState状态会挂起一直等待，等待页面的iframe也加载完毕之后再处理，这个过程是我们不想要得，那就有另外一种处理方案。\n> MSDN 关于 JScript 的一个方法有段不起眼的话，当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了！Diego Perini 在 2007 年的时候，报告了一种检测 IE 是否加载完成的方式，使用 doScroll 方法调用。详细的说明见这里。原理是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在本例中每间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。\n\n```javascript\n    (function doScrollCheck() {\n        if (!jQuery.isReady) {  \n            try {\n                // Use the trick by Diego Perini\n                // http://javascript.nwbox.com/IEContentLoaded/\n                top.doScroll(\"left\");\n            } catch (e) {\n                return setTimeout(doScrollCheck, 50);\n            }   \n            // and execute any waiting functions\n            jQuery.ready();\n        }\n    })();\n```\n\n#### jQuery的实现  \n\n```javascript\n    //全局方法\n    DOMContentLoaded = function() {\n        if ( document.addEventListener ) {\n            document.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n            jQuery.ready();\n        } else if ( document.readyState === \"complete\" ) {\n            // we're here because readyState === \"complete\" in oldIE\n            // which is good enough for us to call the dom ready!\n            document.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n            jQuery.ready();\n        }\n    }\n\n    //入口 jquery实例调用\n    ready: function( fn ) {\n        // Add the callback\n        jQuery.ready.promise().done( fn );\n\n        return this;\n    }\n\n    jQuery.ready.promise = function( obj ) {\n        if ( !readyList ) {\n\n            readyList = jQuery.Deferred();\n\n            // Catch cases where $(document).ready() is called after the browser event has already occurred.\n            // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n            // 当页面加载完了，直接调用ready方法\n            if ( document.readyState === \"complete\" ) {\n                // Handle it asynchronously to allow scripts the opportunity to delay ready\n                setTimeout( jQuery.ready, 1 );\n\n            // Standards-based browsers support DOMContentLoaded\n            } else if ( document.addEventListener ) {\n                // Use the handy event callback\n                document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\n                // A fallback to window.onload, that will always work\n                window.addEventListener( \"load\", jQuery.ready, false );\n\n            // If IE event model is used\n            } else {\n                // Ensure firing before onload, maybe late but safe also for iframes\n                document.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n\n                // A fallback to window.onload, that will always work\n                window.attachEvent( \"onload\", jQuery.ready );\n\n                // If IE and not a frame\n                // continually check to see if the document is ready\n                var top = false;\n\n                try {\n                    top = window.frameElement == null && document.documentElement;\n                } catch(e) {}\n\n                if ( top && top.doScroll ) {\n                    (function doScrollCheck() {\n                        if ( !jQuery.isReady ) {\n\n                            try {\n                                // Use the trick by Diego Perini\n                                // http://javascript.nwbox.com/IEContentLoaded/\n                                top.doScroll(\"left\");\n                            } catch(e) {\n                                return setTimeout( doScrollCheck, 50 );\n                            }\n\n                            // and execute any waiting functions\n                            jQuery.ready();\n                        }\n                    })();\n                }\n            }\n        }\n        return readyList.promise( obj );\n    };\n\n    jQuery.extend({\n        // 表示ready方法是否正在执行，若正在执行，则将isReady设置为true\n        isReady: false,\n\n        // ready方法执行前需要等待的次数\n        readyWait: 1,\n\n        // hold或者释放ready方法，若参数为true则readyWait++，否则执行ready，传入参数为true\n        holdReady: function( hold ) {\n            if ( hold ) {\n                jQuery.readyWait++;\n            } else {\n                jQuery.ready( true );\n            }\n        },\n\n        // 当DOM加载完毕时开始执行ready\n        ready: function( wait ) {\n\n            // 若传入的参数为true，则--readyWait；否则判断isReady，即ready是否正在执行  \n            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n                return;\n            }\n\n            // Remember that the DOM is ready\n            jQuery.isReady = true;\n\n            // 若readyWait-1后还是大于0，则返回，不执行ready。\n            if ( wait !== true && --jQuery.readyWait > 0 ) {\n                return;\n            }\n\n            // If there are functions bound, to execute\n            readyList.resolveWith( document, [ jQuery ] );\n\n            // 触发ready方法，然后解除绑定的ready方法。\n            if ( jQuery.fn.triggerHandler ) {\n                jQuery( document ).triggerHandler( \"ready\" );\n                jQuery( document ).off( \"ready\" );\n            }\n        }\n    });\n```\n根据以上代码可见，最终DOMContented事件执行的，其实是jQUery.ready()这个工具函数。\n（注意，jquery.ready()和jquery(document).raedy()不一样！！，前者是工具函数，后者是实例函数。）\n这里是通过定义一个DOMContentLoaded函数作为桥梁来执行jquery.ready()函数的，这样做的目的就是为了及时的remove掉document的DOMContentLoaded事件的引用。\n{% asset_img zongjie.png %}\n推荐好文:  [何控制jquery的ready事件](http://www.xiabingbao.com/jquery/2015/06/27/jquery-holdready/)\n","slug":"DOMContentLoaded","published":1,"updated":"2016-06-01T06:25:10.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7u8001g543vn6l892jn"},{"title":"第三章 基本概念","date":"2016-01-20T01:38:23.000Z","comments":1,"_content":"# 语法\n## 区分大小写\nECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n<!--more-->\n## 标示符\n所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。\n规则：\n* 第一个字符必须是一个字母、下划线`_`或一个美元符号`$`\n* 其他字符可以是字母、下划线、美元符号或数字。标识符中的字母包含扩展的ASCll或Unicode字母字符(如À和Æ);\n\n## 严格模式 `\"use strict;\"`\n\n[严格模式](http://www.yangshengdonghome.com/2016/01/21/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/)\n\n\n## 语句\n\n* 一个语句由一个或多个表达式、关键字或运算符（符号）组成。通常，在一个行上书写一个语句，但可在两个行或多个行上书写一个语句。此外，在同一个行上书写两个或多个语句，用分号分隔。通常，每个新行都开始一个新语句。最好是显式终止您的语句。可使用分号 (;) 做到这一点，分号是 JavaScript 语句的终止字符。\n* 由括号 ({}) 包围的一组 JavaScript 语句称为一个块。组织在一个块中的语句通常可以视为一个语句，比如`var a = function (){};`和对象字面量(`a = {};`)，这两个结尾的也需要加分号，其他的大括号情况(for循环、ifelse判断)，可以不加分号。\n\n    ```javascript\n    abc={}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n    abc=function(){}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n    if(a==1){}bbc=function(){}// 正常\n    for(var a = 1;a<10;a++){}bbc=function(){}//正常\n    ```\n### 语句和表达式的区别\n\n    ```javascript\n    var a = 1 + 3;\n    ```\n这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。\n`1 + 3`叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。一条语句可以包含多个表达式。\n# 关键字和保留字\n按照规则，关键字也是语言保留的，不能用作标识符。\n\n**关键字：真正意义上的保留字。**\n\nif分支语句：`if`, `else`\nswitch分支语句：`switch`, `case`, `default`, `break`\n循环语句：`do`, `while`, `for`, `continue`\n异常处理语句：`try`, `catch`, `finally`, `throw`\n获取类型：`typeof`, `instanceof`\n布尔值：`true`, `false`, `null`\n函数相关：`var`, `void`, `function`, `return`\n其他：`in`, `this`,` with`, `new`, `delete`\n\n**保留字：结合java、C++等面向对象语言的思路，将来有可能新加入的关键字。**\n\n基本数据类型：`byte`, `char`, `boolean`, `int`, `short`, `long`, `float`, `double`, <span style=\"color:green;\">enum</span>\n继承：<span style=\"color:red;\">implements</span>, <span style=\"color:green;\">extends</span>, <span style=\"color:green;\">super</span>\n类与接口：<span style=\"color:green;\">class</span>, <span style=\"color:red;\">interface</span>\n用来修饰函数的关键字：`abstract`, `native`, <span style=\"color:red;\">static</span>, `final`, <span style=\"color:green;\">const</span>, `volatile`, `synchronized`\n导入导出：<span style=\"color:green;\">export</span>, <span style=\"color:green;\">import</span>\n访问权限：<span style=\"color:red;\">private</span>, <span style=\"color:red;\">protected</span>, <span style=\"color:red;\">public</span>\n其他：goto, <span style=\"color:red;\">package</span>, `throws`, `transient`, `debugger`, <span style=\"color:red;\">let</span>,  <span style=\"color:red;\">yield</span>,  <span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>\n<span style=\"color:#ddd;\">注意：红色字体为第5版严格模式下做的限制，<span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>这两个在严格模式下不能做标识符或属性名。</span>\n<span style=\"color:#ddd;\">注意：第5版把在非严格模式下运行时的保留字减少到绿色字体这几个，但是为了最大的兼容性还是都不要使用了吧。</span>\n\n**顺便整理下javascript语言中提供的有用的常用的变量和函数**\n\n数据类型：`Number`, `Boolean`, `String`, `undefined`, `Object`, `Array`, `Function`, `Date`, `Math`, `RegExp`, `Error`\n错误类型：`EvalError`, `RangeError`, `ReferenceError`, `SyntaxError`, `TypeError`, `URIError`\n编码：`decodeURI`, `decodeURIComponent`, `encodeURI`\n转义：`escape`, `unescape`\n类型转换：`parentInt`, `parentFloat`\n特殊值及判断：`isFinite`, `isNaN`, `NaN`, `Infinity`\n其他：`arguments`, `eval`\n<span style=\"color: red;\">这些都不是ECMAScript的关键字，undefined不是关键字，但是null确是关键字。</span>\n最后注意：我们常用的函数`alert()`不属于上面的三类。\n\n# 变量\n\n## 声明变量\n\n1. 使用关键词 var，这个语法可以同时用来声明局部(function内部)和全局变量。\n2. 在非严格模式下，无论是在全局范围内还是函数内，使用直接给变量赋值`count = 3`这种语法，会产生一个全部变量count(隐式全局变量)，这种方式不推荐。\n3. <span style=\"color:red;\">无法用var声明块级局部变量</span>。\n\n```javascript\n// A single declaration.\nvar count;  \n// Multiple declarations with a single var keyword.\nvar count, amount, level;    \n// Variable declaration and initialization in one statement.\nvar count = 0, amount = 100;\ncount = 3;//无论实在全局范围内还是函数内，使用这种语法直接给变量赋值，会产生一个全部变量\n```\n如果未在 var 语句中初始化您的变量，它将自动采用 undefined 值，试图访问一个未初始化的变量会导致一个 ReferenceError 异常被抛出\n\n如果使用`var`重新声明一个已经存在的变量，是无效的。\n\n```javascript\nvar x = 1;\nvar x;\nx // 1\n```\n但是，如果第二次声明的同时还赋值了，则会覆盖掉前面的值。\n> 这种写法在 严格模式下不会报错，但是如果是重复的属性名或者形参则会报错。\n\n```javascript\nvar x = 1;\nvar x = 2;\nx // 2\n```\n\n使用var声明的全局变量和不使用var的区别：\n\n```javascript\n// 定义三个全局变量\nvar global_var = 1;\nglobal_novar = 2; // 反面教材\n(function () {\n    global_fromfunc = 3; // 反面教材\n}());\n\n// 试图删除\ndelete global_var; // false\ndelete global_novar; // true\ndelete global_fromfunc; // true\n\n// 测试该删除\ntypeof global_var; // \"number\"\ntypeof global_novar; // \"undefined\"\ntypeof global_fromfunc; // \"undefined\"\n```\n\n原因：使用var命令声明变量时（或者使用属性赋值的方式声明变量），变量的可配置性（configurable）为false。\n        \n```javascript\nvar a = 3;\nb = 3;\nconsole.log(Object.getOwnPropertyDescriptor(window, \"a\"));//Object {value: 3, writable: true, enumerable: true, configurable: false}\nconsole.log(Object.getOwnPropertyDescriptor(window, \"b\"));//Object {value: 3, writable: true, enumerable: true, configurable: true}\n\n```\n---\n了解另外两种变量的声明方式：\n* let：声明块范围局部变量，可选初始化值。\n* const：声明一个只读命名常量。\n\n## 数据类型\n\nECMAScript是变量松散类型语言(动态数据类型语言)，即每个变量只是一个占位符，其类型并不固定，可以随时变化，这意味着你定义变量时不必指定变量类型，而且变量类型会在脚本执行需要时自动转换。但是，<span style=\"color: red;\">数据本身和各种运算是有类型的</span>。\nECMAScript 中有5 种简单数据类型（也称为基本数据类型(primitive type)）：Undefined、Null、Boolean、Number和String。还有1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。(ES6又新增了第七种Symbol类型的值)。\nObject对象又可以分成三个子类型：\n\n- 狭义的对象（object）\n- 数组（array）\n- 函数（function）`function f() {} console.log(typeof f) //\"function\"`\n\n狭义的对象和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。\n### undefined类型\n[好好学学undefined！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6undefined%EF%BC%81/)\n\n### null类型\n\nnull类型也只有一个值：null , 表示一个变量中没有包含有效数据，null表示\"没有对象\"。`字面值null`在这里意为`空值`、`空对象`的意思，更确切的说，一个被赋值为null的变量没有保存有效的对象等，可以通过给一个变量赋值为null来清空变量中的内容(不删除变量)。\n\n主要用处：\n\n* 作为函数的参数传递，表示该函数的参数不是对象。\n* 作为对象原型链的终点（例如声明原型链的结束 Foo.prototype = null）。\n```javascript    \nObject.getPrototypeOf(Object.prototype) // null\n```\n产生null的原因只有一个，即对一个变量显式的赋值为null 。\n```javascript \nvar p = null;\nconsole.log(p); //null\ntypeof p; // \"object\"\ntypeof null; // \"object\"\n```\n另外，需要注意的是，`typeof null` 应该返回\"null\"，但实际上返回的是\"object\"，这是一个历史遗留问题，并没有其他原因，不要想太多，曾经有提案 `typeof null === 'null'`但提案被拒绝。\n> 《javascript高级程序设计3》是这么解释的:从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用typeof 操作符检测null 值时会返回\"object\"的原因。\n> \n```javascript \n//判断null值，这个时候就不能用typeOf了，直接用if(xxx === null){}\nconsole.log(typeof null) //\"Object\"\nconsole.log(null instanceof Object) // false\nvar a = null,b;\nconsole.log(a === null) //true\nconsole.log(b === null) //false 因为 undefined !== null  三个等号为false\nconsole.log(b == null) // true 两个等号为true\n```\n\n> undefined == null //true [为什么相等？](https://www.w3.org/html/ig/zh/wiki/ES5/expressions#.E7.AD.89.E5.80.BC.E8.BF.90.E7.AE.97.E7.AC.A6)\n\n### Boolean类型\n\nboolean类型只有两个字面值：`true`和`false` 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()。其中转换结果为false的值有(false, \"\", +0, -0, NaN, null, undefined)，其他值(包括空对象、空数组)均将转换为true。\n\n产生原因：下列运算符会返回布尔值。\n\n- 两元逻辑运算符： `&&` (And)，`||` (Or)\n- 前置逻辑运算符： `!` (Not)\n- 相等运算符：`===`，`!==`，`==`，`!=`\n- 比较运算符：`>`，`>=`，`<`，`<=`\n    \n```javascript \ntypeof true; // \"boolean\"\n\ntypeof false; // \"boolean\"\n\nBoolean(new Object()); //true\n\nBoolean(undefined); //false\n\nBoolean(null); //false\n\nBoolean(''); //false\n\nBoolean(0); //false\n\nBoolean(100); // true\n\nBoolean([]) // true\n    \nBoolean({}) // true\n```\n    \n    \n所有对象的布尔值都是true，甚至连false对应的布尔对象也是true。\n\n```javascript\nBoolean(new Boolean(false)) // true\n```\n    \n如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，比如：\nif判断语句中自动调用Boolean()。\n    \n```javascript \nif (x = y + z){} //将值 y + z 赋给变量 x，然后检查整个表达式的结果（x 的值）是否为 0。\n```\n\n### Number类型\n[好好学学Number！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n\n### String类型\n[好好学学String！](http://www.yangshengdonghome.com/2016/02/02/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6String/)\n\n### Object类型\n[好好学学Object！](http://www.yangshengdonghome.com/2016/02/03/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6Object/)\n\n## 类型转换\n[类型转换](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)\n\n## 类型检验\n[类型检验](http://www.yangshengdonghome.com/2016/02/19/%E7%B1%BB%E5%9E%8B%E6%A3%80%E9%AA%8C/)\n\n## 值传递和引用传递\n[值传递和引用传递](http://www.yangshengdonghome.com/2016/02/22/js%E4%B8%AD%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%83%BD%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84/)\n\n## 操作符&运算符\n[值传递和引用传递](http://www.yangshengdonghome.com/2016/02/25/%E8%BF%90%E7%AE%97%E7%AC%A6/)\n\n## 操作语句 \n`break switch continue do()while{}; while(){} with(){}; label for(){} for...in `\n\n## 数组\n\n## 函数","source":"_posts/3-第三章基本概念-2016-01-20.md","raw":"title: 第三章 基本概念\ndate: 2016-01-20 09:38:23\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n# 语法\n## 区分大小写\nECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n<!--more-->\n## 标示符\n所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。\n规则：\n* 第一个字符必须是一个字母、下划线`_`或一个美元符号`$`\n* 其他字符可以是字母、下划线、美元符号或数字。标识符中的字母包含扩展的ASCll或Unicode字母字符(如À和Æ);\n\n## 严格模式 `\"use strict;\"`\n\n[严格模式](http://www.yangshengdonghome.com/2016/01/21/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/)\n\n\n## 语句\n\n* 一个语句由一个或多个表达式、关键字或运算符（符号）组成。通常，在一个行上书写一个语句，但可在两个行或多个行上书写一个语句。此外，在同一个行上书写两个或多个语句，用分号分隔。通常，每个新行都开始一个新语句。最好是显式终止您的语句。可使用分号 (;) 做到这一点，分号是 JavaScript 语句的终止字符。\n* 由括号 ({}) 包围的一组 JavaScript 语句称为一个块。组织在一个块中的语句通常可以视为一个语句，比如`var a = function (){};`和对象字面量(`a = {};`)，这两个结尾的也需要加分号，其他的大括号情况(for循环、ifelse判断)，可以不加分号。\n\n    ```javascript\n    abc={}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n    abc=function(){}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n    if(a==1){}bbc=function(){}// 正常\n    for(var a = 1;a<10;a++){}bbc=function(){}//正常\n    ```\n### 语句和表达式的区别\n\n    ```javascript\n    var a = 1 + 3;\n    ```\n这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。\n`1 + 3`叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。一条语句可以包含多个表达式。\n# 关键字和保留字\n按照规则，关键字也是语言保留的，不能用作标识符。\n\n**关键字：真正意义上的保留字。**\n\nif分支语句：`if`, `else`\nswitch分支语句：`switch`, `case`, `default`, `break`\n循环语句：`do`, `while`, `for`, `continue`\n异常处理语句：`try`, `catch`, `finally`, `throw`\n获取类型：`typeof`, `instanceof`\n布尔值：`true`, `false`, `null`\n函数相关：`var`, `void`, `function`, `return`\n其他：`in`, `this`,` with`, `new`, `delete`\n\n**保留字：结合java、C++等面向对象语言的思路，将来有可能新加入的关键字。**\n\n基本数据类型：`byte`, `char`, `boolean`, `int`, `short`, `long`, `float`, `double`, <span style=\"color:green;\">enum</span>\n继承：<span style=\"color:red;\">implements</span>, <span style=\"color:green;\">extends</span>, <span style=\"color:green;\">super</span>\n类与接口：<span style=\"color:green;\">class</span>, <span style=\"color:red;\">interface</span>\n用来修饰函数的关键字：`abstract`, `native`, <span style=\"color:red;\">static</span>, `final`, <span style=\"color:green;\">const</span>, `volatile`, `synchronized`\n导入导出：<span style=\"color:green;\">export</span>, <span style=\"color:green;\">import</span>\n访问权限：<span style=\"color:red;\">private</span>, <span style=\"color:red;\">protected</span>, <span style=\"color:red;\">public</span>\n其他：goto, <span style=\"color:red;\">package</span>, `throws`, `transient`, `debugger`, <span style=\"color:red;\">let</span>,  <span style=\"color:red;\">yield</span>,  <span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>\n<span style=\"color:#ddd;\">注意：红色字体为第5版严格模式下做的限制，<span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>这两个在严格模式下不能做标识符或属性名。</span>\n<span style=\"color:#ddd;\">注意：第5版把在非严格模式下运行时的保留字减少到绿色字体这几个，但是为了最大的兼容性还是都不要使用了吧。</span>\n\n**顺便整理下javascript语言中提供的有用的常用的变量和函数**\n\n数据类型：`Number`, `Boolean`, `String`, `undefined`, `Object`, `Array`, `Function`, `Date`, `Math`, `RegExp`, `Error`\n错误类型：`EvalError`, `RangeError`, `ReferenceError`, `SyntaxError`, `TypeError`, `URIError`\n编码：`decodeURI`, `decodeURIComponent`, `encodeURI`\n转义：`escape`, `unescape`\n类型转换：`parentInt`, `parentFloat`\n特殊值及判断：`isFinite`, `isNaN`, `NaN`, `Infinity`\n其他：`arguments`, `eval`\n<span style=\"color: red;\">这些都不是ECMAScript的关键字，undefined不是关键字，但是null确是关键字。</span>\n最后注意：我们常用的函数`alert()`不属于上面的三类。\n\n# 变量\n\n## 声明变量\n\n1. 使用关键词 var，这个语法可以同时用来声明局部(function内部)和全局变量。\n2. 在非严格模式下，无论是在全局范围内还是函数内，使用直接给变量赋值`count = 3`这种语法，会产生一个全部变量count(隐式全局变量)，这种方式不推荐。\n3. <span style=\"color:red;\">无法用var声明块级局部变量</span>。\n\n```javascript\n// A single declaration.\nvar count;  \n// Multiple declarations with a single var keyword.\nvar count, amount, level;    \n// Variable declaration and initialization in one statement.\nvar count = 0, amount = 100;\ncount = 3;//无论实在全局范围内还是函数内，使用这种语法直接给变量赋值，会产生一个全部变量\n```\n如果未在 var 语句中初始化您的变量，它将自动采用 undefined 值，试图访问一个未初始化的变量会导致一个 ReferenceError 异常被抛出\n\n如果使用`var`重新声明一个已经存在的变量，是无效的。\n\n```javascript\nvar x = 1;\nvar x;\nx // 1\n```\n但是，如果第二次声明的同时还赋值了，则会覆盖掉前面的值。\n> 这种写法在 严格模式下不会报错，但是如果是重复的属性名或者形参则会报错。\n\n```javascript\nvar x = 1;\nvar x = 2;\nx // 2\n```\n\n使用var声明的全局变量和不使用var的区别：\n\n```javascript\n// 定义三个全局变量\nvar global_var = 1;\nglobal_novar = 2; // 反面教材\n(function () {\n    global_fromfunc = 3; // 反面教材\n}());\n\n// 试图删除\ndelete global_var; // false\ndelete global_novar; // true\ndelete global_fromfunc; // true\n\n// 测试该删除\ntypeof global_var; // \"number\"\ntypeof global_novar; // \"undefined\"\ntypeof global_fromfunc; // \"undefined\"\n```\n\n原因：使用var命令声明变量时（或者使用属性赋值的方式声明变量），变量的可配置性（configurable）为false。\n        \n```javascript\nvar a = 3;\nb = 3;\nconsole.log(Object.getOwnPropertyDescriptor(window, \"a\"));//Object {value: 3, writable: true, enumerable: true, configurable: false}\nconsole.log(Object.getOwnPropertyDescriptor(window, \"b\"));//Object {value: 3, writable: true, enumerable: true, configurable: true}\n\n```\n---\n了解另外两种变量的声明方式：\n* let：声明块范围局部变量，可选初始化值。\n* const：声明一个只读命名常量。\n\n## 数据类型\n\nECMAScript是变量松散类型语言(动态数据类型语言)，即每个变量只是一个占位符，其类型并不固定，可以随时变化，这意味着你定义变量时不必指定变量类型，而且变量类型会在脚本执行需要时自动转换。但是，<span style=\"color: red;\">数据本身和各种运算是有类型的</span>。\nECMAScript 中有5 种简单数据类型（也称为基本数据类型(primitive type)）：Undefined、Null、Boolean、Number和String。还有1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。(ES6又新增了第七种Symbol类型的值)。\nObject对象又可以分成三个子类型：\n\n- 狭义的对象（object）\n- 数组（array）\n- 函数（function）`function f() {} console.log(typeof f) //\"function\"`\n\n狭义的对象和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。\n### undefined类型\n[好好学学undefined！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6undefined%EF%BC%81/)\n\n### null类型\n\nnull类型也只有一个值：null , 表示一个变量中没有包含有效数据，null表示\"没有对象\"。`字面值null`在这里意为`空值`、`空对象`的意思，更确切的说，一个被赋值为null的变量没有保存有效的对象等，可以通过给一个变量赋值为null来清空变量中的内容(不删除变量)。\n\n主要用处：\n\n* 作为函数的参数传递，表示该函数的参数不是对象。\n* 作为对象原型链的终点（例如声明原型链的结束 Foo.prototype = null）。\n```javascript    \nObject.getPrototypeOf(Object.prototype) // null\n```\n产生null的原因只有一个，即对一个变量显式的赋值为null 。\n```javascript \nvar p = null;\nconsole.log(p); //null\ntypeof p; // \"object\"\ntypeof null; // \"object\"\n```\n另外，需要注意的是，`typeof null` 应该返回\"null\"，但实际上返回的是\"object\"，这是一个历史遗留问题，并没有其他原因，不要想太多，曾经有提案 `typeof null === 'null'`但提案被拒绝。\n> 《javascript高级程序设计3》是这么解释的:从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用typeof 操作符检测null 值时会返回\"object\"的原因。\n> \n```javascript \n//判断null值，这个时候就不能用typeOf了，直接用if(xxx === null){}\nconsole.log(typeof null) //\"Object\"\nconsole.log(null instanceof Object) // false\nvar a = null,b;\nconsole.log(a === null) //true\nconsole.log(b === null) //false 因为 undefined !== null  三个等号为false\nconsole.log(b == null) // true 两个等号为true\n```\n\n> undefined == null //true [为什么相等？](https://www.w3.org/html/ig/zh/wiki/ES5/expressions#.E7.AD.89.E5.80.BC.E8.BF.90.E7.AE.97.E7.AC.A6)\n\n### Boolean类型\n\nboolean类型只有两个字面值：`true`和`false` 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()。其中转换结果为false的值有(false, \"\", +0, -0, NaN, null, undefined)，其他值(包括空对象、空数组)均将转换为true。\n\n产生原因：下列运算符会返回布尔值。\n\n- 两元逻辑运算符： `&&` (And)，`||` (Or)\n- 前置逻辑运算符： `!` (Not)\n- 相等运算符：`===`，`!==`，`==`，`!=`\n- 比较运算符：`>`，`>=`，`<`，`<=`\n    \n```javascript \ntypeof true; // \"boolean\"\n\ntypeof false; // \"boolean\"\n\nBoolean(new Object()); //true\n\nBoolean(undefined); //false\n\nBoolean(null); //false\n\nBoolean(''); //false\n\nBoolean(0); //false\n\nBoolean(100); // true\n\nBoolean([]) // true\n    \nBoolean({}) // true\n```\n    \n    \n所有对象的布尔值都是true，甚至连false对应的布尔对象也是true。\n\n```javascript\nBoolean(new Boolean(false)) // true\n```\n    \n如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，比如：\nif判断语句中自动调用Boolean()。\n    \n```javascript \nif (x = y + z){} //将值 y + z 赋给变量 x，然后检查整个表达式的结果（x 的值）是否为 0。\n```\n\n### Number类型\n[好好学学Number！](http://www.yangshengdonghome.com/2016/01/29/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6number/)\n\n### String类型\n[好好学学String！](http://www.yangshengdonghome.com/2016/02/02/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6String/)\n\n### Object类型\n[好好学学Object！](http://www.yangshengdonghome.com/2016/02/03/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E5%AD%A6Object/)\n\n## 类型转换\n[类型转换](http://www.yangshengdonghome.com/2016/02/18/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)\n\n## 类型检验\n[类型检验](http://www.yangshengdonghome.com/2016/02/19/%E7%B1%BB%E5%9E%8B%E6%A3%80%E9%AA%8C/)\n\n## 值传递和引用传递\n[值传递和引用传递](http://www.yangshengdonghome.com/2016/02/22/js%E4%B8%AD%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%83%BD%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84/)\n\n## 操作符&运算符\n[值传递和引用传递](http://www.yangshengdonghome.com/2016/02/25/%E8%BF%90%E7%AE%97%E7%AC%A6/)\n\n## 操作语句 \n`break switch continue do()while{}; while(){} with(){}; label for(){} for...in `\n\n## 数组\n\n## 函数","slug":"3-第三章基本概念","published":1,"updated":"2016-06-08T14:33:41.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7ui001k543voa5uy69z"},{"title":"第二章 在HTML中使用JavaScrpt","date":"2016-01-05T06:25:13.000Z","comments":1,"_content":"## script元素\n\n`<script src=\"demo.js\"></script>`尽管`<script>` 标签内没有内容，结束的 `</script>` 标签也是必需的。外部文件一般扩展名为.js，但这不是强制的，不写.js扩展名一样可以运行。\n<!--more-->\n* type 这个属性不是必须的，默认值是 “text /javascript”，表示的是编写代码使用的脚本语言的内容类型（也称为MIME 类型）。服务器在传送js文件时使用的MIME类型，通常是application/x-javascript，但在type中设置这个值可能会导致脚本被忽略，考虑到约定俗成和最大浏览器兼容性，目前type属性的值依旧还是text/javascript。\n*  async  只适用外部引入脚本。\n*  defer 只适用外部引入脚本。\n*  language 已废弃。\n*  src\n\n>1. 如果通过&lt;script&gt;&lt;/script&gt;向页面写入一段可以执行的js代码？。\n>\n        <script>\n            document.write('&lt;script&gt;alert(0)&lt;/script&gt;');//alert(0); 不执行\n            document.write('<script>alert(4)</scr'+'ipt>'); //正常弹窗\n            document.write('<script>alert(2)<\\/script>'); //正常弹窗\n            document.write('<script>alert(3)</script>'); //报错\n        </script>\n\n>2. 执行顺序：\n>无论如何包含代码，只要不存在defer 和async 属性，浏览器都会按照`<script>`元素在页面中出现的先后顺序对它们依次进行解析。换句话说，在第一个`<script>`元素包含的代码解析完成后，第二个`<script>`包含的代码才会被解析，然后才是第三个、第四个……\n\n## 标签的位置\n\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <title>Example HTML Page</title>\n        </head>\n        <body>\n            <!-- 这里放内容 -->\n            <script type=\"text/javascript\" src=\"example1.js\"></script>\n            <script type=\"text/javascript\" src=\"example2.js\"></script>\n        </body>\n    </html>\n## 延迟脚本 defer\n\ndefer这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕(`/HTML`)后再运行。因此，在`<script>`元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\nIE4、Firefox 3.5、Safari 5 和Chrome ，其他浏览器会忽略这个属性。为此，把延迟脚本放在页面底部仍然是最佳选择。\n>**defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载**\n\n## 异步脚本 async\n\nHTML5 为`<script>`元素定义了async 属性。指定async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\n- Firefox 3.6、Safari 5 和Chrome。\n- ie系列，async没有任何效果\n- 在chrome下，只有外联脚本，且是在body中引用的，才能生效.\n- **异步执行的表现是，在DOMContentLoaded事件之后，window.loaded事件之前，所以，这个属性处理阻塞的问题是可行的**\n\n## Defer和async的区别\n\n先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：\n+ `<script src=\"script.js\"></script>` 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。\n+ `<script async src=\"script.js\"></script>` 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n+ `<script defer src=\"myscript.js\"></script>` 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。\n\n然后从实用角度来说呢，首先把所有脚本都丢到 `</body>` 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。\n接着，我们来看一张图咯：\n\n{% asset_img deferAsync.png %}\n\n**此图告诉我们以下几个要点：**\ndefer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）。它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的，关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用。async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。\n\n### Defer async常规表现（一些高级浏览器）\n\n#### herder\n1. header中行内脚本执行顺序不受defer async影响，顺序执行，会阻塞DOMContentLoaded。\n2. header中引用外部脚本，添加defer async后，浏览器表现情况不统一，async的可能先执行，所以引用外部脚本并不适合加在header中，也不适合添加defer async标示。\n \n#### body\n1. body中图片加载会阻塞window.loaded,不会阻塞DOMContentLoaded。\n2. body中行内脚本执行顺序不受defer async影响，顺序执行，阻塞DOMContentLoaded。\n3. body中引用外部脚本，defer async表现正常，外部脚本应该加在body中，body结束标签上面。\n\n#### ajax\n1. 无论是header还是body中，行内脚本执行的ajax还是外部脚本执行的ajax，都对页面加载没有影响。\n\n#### 总结\n1. defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载。\n2. async脚本都会在loaded之前执行，它会阻塞window.loaded。\n3. DOMContentLoaded在window.loaded之前执行，阻塞DOMContentLoaded也就会阻塞window.loaded\n4. document ready在DOMContentLoaded之前执行，说明document ready是监听DOMContentLoaded完成的\n \n### IE\n\n1. IE支持defer属性,不支持async属性，从IE9及以上支持onload,支持DOMContentLoaded。\n2. IE6，7支持行内脚本defer属性， 从表现上来看IE6,7,8,9都支持行内脚本的defer，所以我们在ie6,7,8,9中观察到的现象是，行内的先执行async,再执行没加defer async标记的，defer的延迟执行了。\n3. 同时我们又发现IE6,7脚本中ajax影响了页面加载，影响document ready,IE8及以上版本不受影响。\n4. 到了IE8以上，表现和webkit内核浏览器基本相似了。\n\n**不是动态添加的脚本，都会阻塞页DOMContentLoaded，动态添加的脚本应该在document ready后加载，但是也会阻塞loaded**\n>不懂DOMContentLoaded的点[这里](http://www.yangshengdonghome.com/2016/01/08/DOMContentLoaded/)。\n\n## 嵌入代码与外部文件\n\n* 推荐通过`<script>`标签引入外部js文件。\n* 浏览器能够根据具体的设置缓存链接的所有外部JavaScript 文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的\n速度。\n\n## 文档模式 `<!DOCTYPE *>`\n\nE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。\n1. 混杂模式（quirks mode）\n2. 标准模式（standards mode）\n3. 准标准模式（almost standards mode）\n\n如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。\n>现在所有的HTML文档都推荐使用HTML5规定的`<!DOCTYPE html>`\n\n## noscript\n\n包含在`<noscript></noscript>`元素中的内容只有在下列情况下才会显示出来：\n* 浏览器不支持脚本；\n* 浏览器支持脚本，但脚本被禁用。\n","source":"_posts/2-在HTML中使用JavaScrpt-2016-01-05.md","raw":"title: 第二章 在HTML中使用JavaScrpt\ndate: 2016-01-05 14:25:13\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n## script元素\n\n`<script src=\"demo.js\"></script>`尽管`<script>` 标签内没有内容，结束的 `</script>` 标签也是必需的。外部文件一般扩展名为.js，但这不是强制的，不写.js扩展名一样可以运行。\n<!--more-->\n* type 这个属性不是必须的，默认值是 “text /javascript”，表示的是编写代码使用的脚本语言的内容类型（也称为MIME 类型）。服务器在传送js文件时使用的MIME类型，通常是application/x-javascript，但在type中设置这个值可能会导致脚本被忽略，考虑到约定俗成和最大浏览器兼容性，目前type属性的值依旧还是text/javascript。\n*  async  只适用外部引入脚本。\n*  defer 只适用外部引入脚本。\n*  language 已废弃。\n*  src\n\n>1. 如果通过&lt;script&gt;&lt;/script&gt;向页面写入一段可以执行的js代码？。\n>\n        <script>\n            document.write('&lt;script&gt;alert(0)&lt;/script&gt;');//alert(0); 不执行\n            document.write('<script>alert(4)</scr'+'ipt>'); //正常弹窗\n            document.write('<script>alert(2)<\\/script>'); //正常弹窗\n            document.write('<script>alert(3)</script>'); //报错\n        </script>\n\n>2. 执行顺序：\n>无论如何包含代码，只要不存在defer 和async 属性，浏览器都会按照`<script>`元素在页面中出现的先后顺序对它们依次进行解析。换句话说，在第一个`<script>`元素包含的代码解析完成后，第二个`<script>`包含的代码才会被解析，然后才是第三个、第四个……\n\n## 标签的位置\n\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <title>Example HTML Page</title>\n        </head>\n        <body>\n            <!-- 这里放内容 -->\n            <script type=\"text/javascript\" src=\"example1.js\"></script>\n            <script type=\"text/javascript\" src=\"example2.js\"></script>\n        </body>\n    </html>\n## 延迟脚本 defer\n\ndefer这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕(`/HTML`)后再运行。因此，在`<script>`元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\nIE4、Firefox 3.5、Safari 5 和Chrome ，其他浏览器会忽略这个属性。为此，把延迟脚本放在页面底部仍然是最佳选择。\n>**defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载**\n\n## 异步脚本 async\n\nHTML5 为`<script>`元素定义了async 属性。指定async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\n- Firefox 3.6、Safari 5 和Chrome。\n- ie系列，async没有任何效果\n- 在chrome下，只有外联脚本，且是在body中引用的，才能生效.\n- **异步执行的表现是，在DOMContentLoaded事件之后，window.loaded事件之前，所以，这个属性处理阻塞的问题是可行的**\n\n## Defer和async的区别\n\n先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：\n+ `<script src=\"script.js\"></script>` 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。\n+ `<script async src=\"script.js\"></script>` 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n+ `<script defer src=\"myscript.js\"></script>` 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。\n\n然后从实用角度来说呢，首先把所有脚本都丢到 `</body>` 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。\n接着，我们来看一张图咯：\n\n{% asset_img deferAsync.png %}\n\n**此图告诉我们以下几个要点：**\ndefer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）。它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的，关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用。async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。\n\n### Defer async常规表现（一些高级浏览器）\n\n#### herder\n1. header中行内脚本执行顺序不受defer async影响，顺序执行，会阻塞DOMContentLoaded。\n2. header中引用外部脚本，添加defer async后，浏览器表现情况不统一，async的可能先执行，所以引用外部脚本并不适合加在header中，也不适合添加defer async标示。\n \n#### body\n1. body中图片加载会阻塞window.loaded,不会阻塞DOMContentLoaded。\n2. body中行内脚本执行顺序不受defer async影响，顺序执行，阻塞DOMContentLoaded。\n3. body中引用外部脚本，defer async表现正常，外部脚本应该加在body中，body结束标签上面。\n\n#### ajax\n1. 无论是header还是body中，行内脚本执行的ajax还是外部脚本执行的ajax，都对页面加载没有影响。\n\n#### 总结\n1. defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载。\n2. async脚本都会在loaded之前执行，它会阻塞window.loaded。\n3. DOMContentLoaded在window.loaded之前执行，阻塞DOMContentLoaded也就会阻塞window.loaded\n4. document ready在DOMContentLoaded之前执行，说明document ready是监听DOMContentLoaded完成的\n \n### IE\n\n1. IE支持defer属性,不支持async属性，从IE9及以上支持onload,支持DOMContentLoaded。\n2. IE6，7支持行内脚本defer属性， 从表现上来看IE6,7,8,9都支持行内脚本的defer，所以我们在ie6,7,8,9中观察到的现象是，行内的先执行async,再执行没加defer async标记的，defer的延迟执行了。\n3. 同时我们又发现IE6,7脚本中ajax影响了页面加载，影响document ready,IE8及以上版本不受影响。\n4. 到了IE8以上，表现和webkit内核浏览器基本相似了。\n\n**不是动态添加的脚本，都会阻塞页DOMContentLoaded，动态添加的脚本应该在document ready后加载，但是也会阻塞loaded**\n>不懂DOMContentLoaded的点[这里](http://www.yangshengdonghome.com/2016/01/08/DOMContentLoaded/)。\n\n## 嵌入代码与外部文件\n\n* 推荐通过`<script>`标签引入外部js文件。\n* 浏览器能够根据具体的设置缓存链接的所有外部JavaScript 文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的\n速度。\n\n## 文档模式 `<!DOCTYPE *>`\n\nE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。\n1. 混杂模式（quirks mode）\n2. 标准模式（standards mode）\n3. 准标准模式（almost standards mode）\n\n如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。\n>现在所有的HTML文档都推荐使用HTML5规定的`<!DOCTYPE html>`\n\n## noscript\n\n包含在`<noscript></noscript>`元素中的内容只有在下列情况下才会显示出来：\n* 浏览器不支持脚本；\n* 浏览器支持脚本，但脚本被禁用。\n","slug":"2-在HTML中使用JavaScrpt","published":1,"updated":"2016-06-01T06:28:16.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7um001n543vvc64mi8d"},{"title":"第一章 JavaScrpt简介","date":"2016-01-05T06:24:40.000Z","comments":1,"_content":"先简要说一下和JavaScript相关的一些背景术语，就不详细讨论JavaScript的历史了，想了解的朋友可以参考原书。\n<!--more-->\n### 专有名词\n+ ECMA：\n欧洲计算机制造商协会（Standard ECMA-262European Computer Manufacturers Association）\n+ TC39：\nECMA第39号技术委员会（Technical Committee#39），由来自一些关注脚本语言发展的公司的程序员组成，负责制定一种通用、跨平台、供应商中立的脚本语言。\n+ ECMAScript：\n由ECMA制定，在ECMA-262中定义的脚本语言标准。ECMAScript只是一个脚本语言标准，你尽可以在自己的环境中取实现它，这个环境，就称为ECMAScript的宿主环境，Web浏览器可以说是ECMAScript目前最重要的宿主环境了，而不同的Web浏览器，对ECMAScript标准的支持也不尽相同。除Web浏览器，Adobe ActionScript也实现了ECMAScript。一般的宿主环境，除了实现ECMAScript标准，也会有各自的扩展，以便与环境更好的交互。\n+ ES3、ES5、ES6：是指ECMAScript 的三个版本，最新版是ES6，已经有部分特性被浏览器支持。[查看各个版本被各大浏览器的支持情况](http://kangax.github.io/compat-table/es5/)。\n\n### DOM\n#### what is DOM？\n通过 JavaScript，您可以重构整个HTML文档。您可以添加、移除、改变或重排页面上的项目。要改变页面的某个东西，JavaScript就需要对HTML文档中所有元素进行访问的入口。这个入口，连同对HTML 元素进行添加、移动、改变或移除的方法和属性，都是通过文档对象模型来获得的（DOM）。在 1998 年，W3C 发布了第一级的 DOM 规范。这个规范允许访问和操作 HTML 页面中的每一个单独的元素。所有的浏览器都执行了这个标准，因此，DOM 的兼容性问题也几乎难觅踪影了。DOM 可被 JavaScript 用来读取、改变 HTML、XHTML 以及 XML 文档。\n+ DOM 被分为不同的部分（核心、XML及HTML）和级别（DOM Level 1/2/3）：\n  + Core DOM 定义了一套标准的针对任何结构化文档的对象 \n  + XML DOM  定义了一套标准的针对 XML 文档的对象 \n  + HTML DOM 定义了一套标准的针对 HTML 文档的对象。\n \n#### DOM Level\n+ DOM1级：\n 1. DOM1 级由两个模块组成：DOM核心（DOM Core）和DOM HTML。其中，DOM 核心规定的是如何映射基于XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在DOM 核心的基础上加以扩展，添加了针对HTML 的对象和方法。\n+  DOM2级：\n 1. DOM2 级在原来DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1 级中的DOM核心模块也经过扩展开始支持XML 命名空间。\n+  DOM3级：\n 1. 引入了以统一方式加载和保存文档的方法\n 2. 新增了验证文档的方法\n 3. DOM3 级也对DOM 核心进行了扩展，开始支持XML 1.0 规范，涉及XML Infoset、XPath和XML Base。\n\n#### BOM\n从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的JavaScript 扩展算作BOM的一部分。下面就是一些这样的扩展：\n1. 弹出新浏览器窗口的功能；\n2. 移动、缩放和关闭浏览器窗口的功能；\n3. 提供浏览器详细信息的navigator 对象；\n4. 提供浏览器所加载页面的详细信息的location 对象；\n5. 提供用户显示器分辨率详细信息的screen 对象；\n6. 对cookies 的支持；\n7. 像XMLHttpRequest 和IE 的ActiveXObject 这样的自定义对象。\n\n\n#### LiveScript、JavaScript、JScript：\nLiveScript是JavaScript的前身，而JScript则是微软为了防止版权冲突而给自己的脚本语言起的名称。他们除了实现了ECMAScript外，还会包括针对浏览器的扩展（BOM：浏览器对象模型）和针对XML/HTML API的扩展（DOM：文档对象模型）。\n+ JavaScript 是一种专为网页交互设计的脚本语言，由下列三个不同的部分组成：\n+ ECMAScript：规定了以下这些内容：语法、类型、语句、关键字、保留字、操作符、对象\n+ DOM：文档对象模型（Document Object Model）\n+ BOM：浏览器对象模型（Browser Object Model）","source":"_posts/1-JavaScrpt简介-2016-01-05.md","raw":"title: 第一章 JavaScrpt简介\ndate: 2016-01-05 14:24:40\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n先简要说一下和JavaScript相关的一些背景术语，就不详细讨论JavaScript的历史了，想了解的朋友可以参考原书。\n<!--more-->\n### 专有名词\n+ ECMA：\n欧洲计算机制造商协会（Standard ECMA-262European Computer Manufacturers Association）\n+ TC39：\nECMA第39号技术委员会（Technical Committee#39），由来自一些关注脚本语言发展的公司的程序员组成，负责制定一种通用、跨平台、供应商中立的脚本语言。\n+ ECMAScript：\n由ECMA制定，在ECMA-262中定义的脚本语言标准。ECMAScript只是一个脚本语言标准，你尽可以在自己的环境中取实现它，这个环境，就称为ECMAScript的宿主环境，Web浏览器可以说是ECMAScript目前最重要的宿主环境了，而不同的Web浏览器，对ECMAScript标准的支持也不尽相同。除Web浏览器，Adobe ActionScript也实现了ECMAScript。一般的宿主环境，除了实现ECMAScript标准，也会有各自的扩展，以便与环境更好的交互。\n+ ES3、ES5、ES6：是指ECMAScript 的三个版本，最新版是ES6，已经有部分特性被浏览器支持。[查看各个版本被各大浏览器的支持情况](http://kangax.github.io/compat-table/es5/)。\n\n### DOM\n#### what is DOM？\n通过 JavaScript，您可以重构整个HTML文档。您可以添加、移除、改变或重排页面上的项目。要改变页面的某个东西，JavaScript就需要对HTML文档中所有元素进行访问的入口。这个入口，连同对HTML 元素进行添加、移动、改变或移除的方法和属性，都是通过文档对象模型来获得的（DOM）。在 1998 年，W3C 发布了第一级的 DOM 规范。这个规范允许访问和操作 HTML 页面中的每一个单独的元素。所有的浏览器都执行了这个标准，因此，DOM 的兼容性问题也几乎难觅踪影了。DOM 可被 JavaScript 用来读取、改变 HTML、XHTML 以及 XML 文档。\n+ DOM 被分为不同的部分（核心、XML及HTML）和级别（DOM Level 1/2/3）：\n  + Core DOM 定义了一套标准的针对任何结构化文档的对象 \n  + XML DOM  定义了一套标准的针对 XML 文档的对象 \n  + HTML DOM 定义了一套标准的针对 HTML 文档的对象。\n \n#### DOM Level\n+ DOM1级：\n 1. DOM1 级由两个模块组成：DOM核心（DOM Core）和DOM HTML。其中，DOM 核心规定的是如何映射基于XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在DOM 核心的基础上加以扩展，添加了针对HTML 的对象和方法。\n+  DOM2级：\n 1. DOM2 级在原来DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1 级中的DOM核心模块也经过扩展开始支持XML 命名空间。\n+  DOM3级：\n 1. 引入了以统一方式加载和保存文档的方法\n 2. 新增了验证文档的方法\n 3. DOM3 级也对DOM 核心进行了扩展，开始支持XML 1.0 规范，涉及XML Infoset、XPath和XML Base。\n\n#### BOM\n从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的JavaScript 扩展算作BOM的一部分。下面就是一些这样的扩展：\n1. 弹出新浏览器窗口的功能；\n2. 移动、缩放和关闭浏览器窗口的功能；\n3. 提供浏览器详细信息的navigator 对象；\n4. 提供浏览器所加载页面的详细信息的location 对象；\n5. 提供用户显示器分辨率详细信息的screen 对象；\n6. 对cookies 的支持；\n7. 像XMLHttpRequest 和IE 的ActiveXObject 这样的自定义对象。\n\n\n#### LiveScript、JavaScript、JScript：\nLiveScript是JavaScript的前身，而JScript则是微软为了防止版权冲突而给自己的脚本语言起的名称。他们除了实现了ECMAScript外，还会包括针对浏览器的扩展（BOM：浏览器对象模型）和针对XML/HTML API的扩展（DOM：文档对象模型）。\n+ JavaScript 是一种专为网页交互设计的脚本语言，由下列三个不同的部分组成：\n+ ECMAScript：规定了以下这些内容：语法、类型、语句、关键字、保留字、操作符、对象\n+ DOM：文档对象模型（Document Object Model）\n+ BOM：浏览器对象模型（Browser Object Model）","slug":"1-JavaScrpt简介","published":1,"updated":"2016-06-01T02:33:50.000Z","layout":"post","photos":[],"link":"","_id":"cipmnl7us001q543vxhv8glu0"}],"PostAsset":[{"_id":"source/_posts/类型检验-2016-02-19/type.jpg","post":"cipmnl7q8000a543vj6i67sjy","slug":"type.jpg","modified":1},{"_id":"source/_posts/好好学学number-2016-01-29/number.png","post":"cipmnl7qp000m543v57wgdxee","slug":"number.png","modified":1},{"_id":"source/_posts/好好学学number-2016-01-29/number2.png","post":"cipmnl7qp000m543v57wgdxee","slug":"number2.png","modified":1},{"_id":"source/_posts/严格模式-2016-01-21/stracit.png","post":"cipmnl7rb000v543vr5r2t1q6","slug":"stracit.png","modified":1},{"_id":"source/_posts/numberInJavaScript-2016-06-19/10.png","post":"cipmnl7rt0015543vz7a5hogp","slug":"10.png","modified":1},{"_id":"source/_posts/numberInJavaScript-2016-06-19/11.png","post":"cipmnl7rt0015543vz7a5hogp","slug":"11.png","modified":1},{"_id":"source/_posts/numberInJavaScript-2016-06-19/123.png","post":"cipmnl7rt0015543vz7a5hogp","slug":"123.png","modified":1},{"_id":"source/_posts/numberInJavaScript-2016-06-19/32.png","post":"cipmnl7rt0015543vz7a5hogp","slug":"32.png","modified":1},{"_id":"source/_posts/numberInJavaScript-2016-06-19/456.jpg","post":"cipmnl7rt0015543vz7a5hogp","slug":"456.jpg","modified":1},{"_id":"source/_posts/numberInJavaScript-2016-06-19/64.png","post":"cipmnl7rt0015543vz7a5hogp","slug":"64.png","modified":1},{"_id":"source/_posts/numberInJavaScript-2016-06-19/789.jpg","post":"cipmnl7rt0015543vz7a5hogp","slug":"789.jpg","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image1.jpg","post":"cipmnl7sh0018543vpck309sc","slug":"image1.jpg","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image10.png","post":"cipmnl7sh0018543vpck309sc","slug":"image10.png","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image11.png","post":"cipmnl7sh0018543vpck309sc","slug":"image11.png","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image12.png","post":"cipmnl7sh0018543vpck309sc","slug":"image12.png","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image13.png","post":"cipmnl7sh0018543vpck309sc","slug":"image13.png","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image14.png","post":"cipmnl7sh0018543vpck309sc","slug":"image14.png","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image2.jpg","post":"cipmnl7sh0018543vpck309sc","slug":"image2.jpg","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image3.jpg","post":"cipmnl7sh0018543vpck309sc","slug":"image3.jpg","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image4.jpg","post":"cipmnl7sh0018543vpck309sc","slug":"image4.jpg","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image5.png","post":"cipmnl7sh0018543vpck309sc","slug":"image5.png","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image6.png","post":"cipmnl7sh0018543vpck309sc","slug":"image6.png","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image7.png","post":"cipmnl7sh0018543vpck309sc","slug":"image7.png","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image8.png","post":"cipmnl7sh0018543vpck309sc","slug":"image8.png","modified":1},{"_id":"source/_posts/js中函数参数都是按值传递的-2016-02-22/image9.png","post":"cipmnl7sh0018543vpck309sc","slug":"image9.png","modified":1},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/onLoadVSDomContentLoaded.png","post":"cipmnl7u8001g543vn6l892jn","slug":"onLoadVSDomContentLoaded.png","modified":1},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/zongjie.png","post":"cipmnl7u8001g543vn6l892jn","slug":"zongjie.png","modified":1},{"_id":"source/_posts/2-在HTML中使用JavaScrpt-2016-01-05/deferAsync.png","post":"cipmnl7um001n543vvc64mi8d","slug":"deferAsync.png","modified":1}],"PostCategory":[{"post_id":"cipmnl7pw0002543vrhssviap","category_id":"cipmnl7pz0003543v66n7towi","_id":"cipmnl7q20006543vzsh4fkxx"},{"post_id":"cipmnl7q40007543vyjoywltq","category_id":"cipmnl7pz0003543v66n7towi","_id":"cipmnl7q50008543v1creewh8"},{"post_id":"cipmnl7q8000a543vj6i67sjy","category_id":"cipmnl7pz0003543v66n7towi","_id":"cipmnl7q9000b543vpgnc6o8d"},{"post_id":"cipmnl7qg000d543v919gfst8","category_id":"cipmnl7qh000e543vnkbu9caa","_id":"cipmnl7qi000g543vfw8kpce2"},{"post_id":"cipmnl7ql000h543vau1b4at5","category_id":"cipmnl7qh000e543vnkbu9caa","_id":"cipmnl7qm000i543v88x65l80"},{"post_id":"cipmnl7qp000m543v57wgdxee","category_id":"cipmnl7qh000e543vnkbu9caa","_id":"cipmnl7qq000n543vlor2n5pd"},{"post_id":"cipmnl7r0000p543v6eayhyn4","category_id":"cipmnl7qh000e543vnkbu9caa","_id":"cipmnl7r1000q543v31ynpanu"},{"post_id":"cipmnl7r6000s543vyu7wcyaz","category_id":"cipmnl7pz0003543v66n7towi","_id":"cipmnl7r8000t543vx3pl9x9o"},{"post_id":"cipmnl7rb000v543vr5r2t1q6","category_id":"cipmnl7qh000e543vnkbu9caa","_id":"cipmnl7rd000w543vbf34ws3d"},{"post_id":"cipmnl7ri000z543ves8o0xxh","category_id":"cipmnl7qh000e543vnkbu9caa","_id":"cipmnl7rk0010543vglfsjd6z"},{"post_id":"cipmnl7rp0012543vq23iypo9","category_id":"cipmnl7qh000e543vnkbu9caa","_id":"cipmnl7rr0013543v6wfz0mu2"},{"post_id":"cipmnl7rt0015543vz7a5hogp","category_id":"cipmnl7qh000e543vnkbu9caa","_id":"cipmnl7ru0016543vpox3gmf7"},{"post_id":"cipmnl7sh0018543vpck309sc","category_id":"cipmnl7pz0003543v66n7towi","_id":"cipmnl7si0019543v8krxk2tr"},{"post_id":"cipmnl7u8001g543vn6l892jn","category_id":"cipmnl7qh000e543vnkbu9caa","_id":"cipmnl7ua001h543vxsmb7qus"},{"post_id":"cipmnl7ui001k543voa5uy69z","category_id":"cipmnl7pz0003543v66n7towi","_id":"cipmnl7uk001l543v7jcl64qq"},{"post_id":"cipmnl7um001n543vvc64mi8d","category_id":"cipmnl7pz0003543v66n7towi","_id":"cipmnl7un001o543vljfbad44"},{"post_id":"cipmnl7us001q543vxhv8glu0","category_id":"cipmnl7pz0003543v66n7towi","_id":"cipmnl7ut001r543vvmopuhmm"}],"PostTag":[{"post_id":"cipmnl7pw0002543vrhssviap","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7q10005543vokxnwfdo"},{"post_id":"cipmnl7q40007543vyjoywltq","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7q60009543v7f0el3g1"},{"post_id":"cipmnl7q8000a543vj6i67sjy","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7q9000c543vdg39alfg"},{"post_id":"cipmnl7qg000d543v919gfst8","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7qi000f543vrvre5zne"},{"post_id":"cipmnl7ql000h543vau1b4at5","tag_id":"cipmnl7qm000j543v4cg0ef5m","_id":"cipmnl7qn000k543vrqg879z8"},{"post_id":"cipmnl7ql000h543vau1b4at5","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7qn000l543v60gqx80q"},{"post_id":"cipmnl7qp000m543v57wgdxee","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7qr000o543vwltcaq5t"},{"post_id":"cipmnl7r0000p543v6eayhyn4","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7r2000r543vaiwjv1r1"},{"post_id":"cipmnl7r6000s543vyu7wcyaz","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7r9000u543v11m5ka54"},{"post_id":"cipmnl7rb000v543vr5r2t1q6","tag_id":"cipmnl7qm000j543v4cg0ef5m","_id":"cipmnl7rd000x543v3tqlaavj"},{"post_id":"cipmnl7rb000v543vr5r2t1q6","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7re000y543v2pqyjezy"},{"post_id":"cipmnl7ri000z543ves8o0xxh","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7rk0011543v2pw3mpsu"},{"post_id":"cipmnl7rp0012543vq23iypo9","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7rr0014543vqvg8hxkh"},{"post_id":"cipmnl7rt0015543vz7a5hogp","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7rv0017543v0p2weclv"},{"post_id":"cipmnl7sh0018543vpck309sc","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7sj001a543vuutgdt83"},{"post_id":"cipmnl7u5001e543vcgctbolw","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7u6001f543vxwofvrc9"},{"post_id":"cipmnl7u8001g543vn6l892jn","tag_id":"cipmnl7qm000j543v4cg0ef5m","_id":"cipmnl7ua001i543v4c1k6tcj"},{"post_id":"cipmnl7u8001g543vn6l892jn","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7ub001j543v1w7qt5v9"},{"post_id":"cipmnl7ui001k543voa5uy69z","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7uk001m543vnv2jv4rd"},{"post_id":"cipmnl7um001n543vvc64mi8d","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7uo001p543vpws38jwb"},{"post_id":"cipmnl7us001q543vxhv8glu0","tag_id":"cipmnl7q00004543vindu16s5","_id":"cipmnl7uu001s543vwyypka9u"}],"Tag":[{"name":"JavaScript","_id":"cipmnl7q00004543vindu16s5"},{"name":"jQuery","_id":"cipmnl7qm000j543v4cg0ef5m"}]}}