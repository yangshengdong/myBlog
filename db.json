{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"source/CNAME","path":"CNAME","modified":1}],"Cache":[{"_id":"source/404.html","shasum":"9ae5313c4ee64f8060cd08bad8a6a8270e0bd02c","modified":1452479190000},{"_id":"source/CNAME","shasum":"5bea78925f82297f017d461af01317b7a493d489","modified":1452478547000},{"_id":"source/_posts/3-第三章基本概念-2016-01-20.md","shasum":"f72f06b0da3e1de3f55f627b8516265103fccc99","modified":1454032739000},{"_id":"source/_posts/2-在HTML中使用JavaScrpt-2016-01-05.md","shasum":"d719e03fd1a46903ecf60ddcb21df761b0b6e440","modified":1453253613000},{"_id":"source/_posts/1-JavaScrpt简介-2016-01-05.md","shasum":"e41e78fbc6d0c3ac9e93de6f2e23bd2888ab3d8a","modified":1453442264000},{"_id":"source/_posts/void-0-2016-01-29.md","shasum":"1e741ccc4b7fd2bb5df3f38c5520707167644e9e","modified":1454053234000},{"_id":"source/_posts/2-在HTML中使用JavaScrpt-2016-01-05/deferAsync.png","shasum":"405aba297cb925c030bc11878e291edc350b3645","modified":1452171438000},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/zongjie.png","shasum":"75b021d03703a62dffca85d21065daa074d2edc4","modified":1452226722000},{"_id":"source/_posts/DOMContentLoaded-2016-01-08.md","shasum":"589d363c2019cc1847f9f6a2a57f338982e5643c","modified":1453208396000},{"_id":"source/_posts/ECMAScrip中的对象存取器-getter和setter-2016-01-21.md","shasum":"53477985cd52e20b2a72c148a3cd7dc49fb96423","modified":1453369070000},{"_id":"source/_posts/hello-world.md","shasum":"774b507901d9b17991ace2a70263b6dd6d11999a","modified":1451973164000},{"_id":"source/_posts/webkit的预加载扫描器-2016-01-19.md","shasum":"c8b9ebe46cdb0553b9cba8e0a1accc4499da7911","modified":1453208403000},{"_id":"source/_posts/好好学学undefined！-2016-01-29.md","shasum":"1b57652f7b14ee4ee86df3d321b2184ed27ff457","modified":1454050698000},{"_id":"source/baidu_verify_i0wnrfk2ui.html","shasum":"48d9c82953f45c582fba83160d71d4df0ec7103f","modified":1452572516000},{"_id":"source/_posts/严格模式-2016-01-21.md","shasum":"dde3ca7e1e28c0eb5158ca80144f784f21a062b7","modified":1453372464000},{"_id":"source/_posts/好好学学number-2016-01-29.md","shasum":"6f59e00e3d9021e08189d2813838ba9964c4a1cb","modified":1454045712000},{"_id":"source/_posts/如何学习javascript-转帖-2016-01-27.md","shasum":"86d88de583c4d5b64794f5feb02d861820a8a022","modified":1453862572000},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/onLoadVSDomContentLoaded.png","shasum":"597586264b44d04e58387eb02379818a338627b1","modified":1452220118000},{"_id":"source/_posts/好好学学number-2016-01-29/number2.png","shasum":"2735883e61ae234615de6234b9280f12a4e4ba47","modified":1454043023000},{"_id":"source/_posts/好好学学number-2016-01-29/number.png","shasum":"6d0564a349b5e99daa5b5588314b3a4ce45f7fd1","modified":1453980343000},{"_id":"themes/jacman/LICENSE","shasum":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1450859342000},{"_id":"themes/jacman/languages/default.yml","shasum":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1450859342000},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1450859342000},{"_id":"themes/jacman/README.md","shasum":"79be8a49927c8666f1804d7ccd08af8d3268062a","modified":1450859342000},{"_id":"themes/jacman/README_zh.md","shasum":"0854e4c96f53005f3a47e21af3f8aee361719ce4","modified":1450859342000},{"_id":"themes/jacman/_config.yml","shasum":"ec3e1c2147b1223cf10a14ba768a931a2e13f31d","modified":1452228411000},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"f0772c9de0431384d4e852358ee425a1cdf3ea6d","modified":1453707593000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"32db7e7c8171530d29c3878f387c4438d6057508","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"c4f527fff0070fbe65919053a16224412317f40d","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1450859342000},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","shasum":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1450859342000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1450859342000},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1450859342000},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1450859342000},{"_id":"themes/jacman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1450859342000},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1450859342000},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1450859342000},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1450859342000},{"_id":"themes/jacman/layout/layout.ejs","shasum":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1450859342000},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","shasum":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","shasum":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1450859342000},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"f016180726019927b9a835ed01e04d153f27a149","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1450859342000},{"_id":"themes/jacman/source/css/style.styl","shasum":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"1136600932b97534b88465bf05ef313630b2de3d","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450859342000},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1450859342000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1450859342000},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1450859342000},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1450859342000},{"_id":"themes/jacman/source/img/author.jpg","shasum":"2a292e681b4c6c975eec9c8c356d99647a465542","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1450859342000},{"_id":"themes/jacman/source/img/favicon.ico","shasum":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1450859342000},{"_id":"themes/jacman/source/img/logo.svg","shasum":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1450859342000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1450859342000},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1450859342000},{"_id":"themes/jacman/source/img/jacman.jpg","shasum":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1450859342000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1450859342000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","shasum":"57c3987166a26415a71292162690e82c21e315ad","modified":1450859342000},{"_id":"themes/jacman/source/js/totop.js","shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1450859342000},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1450859342000},{"_id":"themes/jacman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1450859342000},{"_id":"themes/jacman/source/img/logo.png","shasum":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1450859342000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1450859342000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1450859342000},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1450859342000},{"_id":"public/js/totop.js","modified":1454053253040,"shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb"},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","modified":1454053253046,"shasum":"57c3987166a26415a71292162690e82c21e315ad"},{"_id":"public/js/jquery.imagesloaded.min.js","modified":1454053253049,"shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f"},{"_id":"public/js/jquery-2.0.3.min.js","modified":1454053253052,"shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d"},{"_id":"public/js/gallery.js","modified":1454053253055,"shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed"},{"_id":"public/img/scrollup.png","modified":1454053253060,"shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3"},{"_id":"public/img/logo.svg","modified":1454053253063,"shasum":"9ae38f7225c38624faeb7b74996efa9de7bf065b"},{"_id":"public/img/logo.png","modified":1454053253066,"shasum":"fd08d12d1fa147cf894e8f8327e38f1758de32ed"},{"_id":"public/img/jacman.jpg","modified":1454053253070,"shasum":"0ba14a4a5e3be012826fc713c33479912126d34e"},{"_id":"public/img/favicon.ico","modified":1454053253073,"shasum":"2d22a3e0c7905a894e832c831dd91c29c209c7a5"},{"_id":"public/img/cc-zero.svg","modified":1454053253077,"shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030"},{"_id":"public/img/cc-by.svg","modified":1454053253080,"shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e"},{"_id":"public/img/cc-by-sa.svg","modified":1454053253084,"shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e"},{"_id":"public/img/cc-by-nd.svg","modified":1454053253087,"shasum":"c563508ce9ced1e66948024ba1153400ac0e0621"},{"_id":"public/img/cc-by-nc.svg","modified":1454053253091,"shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7"},{"_id":"public/img/cc-by-nc-sa.svg","modified":1454053253094,"shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e"},{"_id":"public/img/cc-by-nc-nd.svg","modified":1454053253096,"shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564"},{"_id":"public/img/banner.jpg","modified":1454053253100,"shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74"},{"_id":"public/img/author.jpg","modified":1454053253104,"shasum":"2a292e681b4c6c975eec9c8c356d99647a465542"},{"_id":"public/font/fontdiao.woff","modified":1454053253107,"shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f"},{"_id":"public/font/fontdiao.ttf","modified":1454053253115,"shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab"},{"_id":"public/font/fontdiao.svg","modified":1454053253120,"shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b"},{"_id":"public/font/fontdiao.eot","modified":1454053253123,"shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9"},{"_id":"public/font/fontawesome-webfont.woff","modified":1454053253126,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/font/fontawesome-webfont.ttf","modified":1454053253130,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/font/fontawesome-webfont.svg","modified":1454053253134,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/font/fontawesome-webfont.eot","modified":1454053253139,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/font/coveredbyyourgrace-webfont.woff","modified":1454053253144,"shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e"},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","modified":1454053253147,"shasum":"194ccb4acf77a03dc25bcc174edb266143704fec"},{"_id":"public/font/coveredbyyourgrace-webfont.svg","modified":1454053253151,"shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53"},{"_id":"public/font/coveredbyyourgrace-webfont.eot","modified":1454053253155,"shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de"},{"_id":"public/font/FontAwesome.otf","modified":1454053253160,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1454053253170,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1454053253173,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1454053253175,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1454053253180,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1454053253183,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1454053253190,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1454053253192,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1454053253195,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1454053253197,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1454053253201,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1454053253204,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1454053253207,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1454053253210,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1454053253212,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1454053253215,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1454053253832,"shasum":"b12fa858391638038d79987085c32a9928ecf7b8"},{"_id":"public/CNAME","modified":1454053254163,"shasum":"5bea78925f82297f017d461af01317b7a493d489"},{"_id":"public/2016/01/29/好好学学number/number.png","modified":1454053254169,"shasum":"6d0564a349b5e99daa5b5588314b3a4ce45f7fd1"},{"_id":"public/2016/01/29/好好学学number/number2.png","modified":1454053254176,"shasum":"2735883e61ae234615de6234b9280f12a4e4ba47"},{"_id":"public/2016/01/08/DOMContentLoaded/onLoadVSDomContentLoaded.png","modified":1454053254183,"shasum":"597586264b44d04e58387eb02379818a338627b1"},{"_id":"public/2016/01/08/DOMContentLoaded/zongjie.png","modified":1454053254190,"shasum":"75b021d03703a62dffca85d21065daa074d2edc4"},{"_id":"public/2016/01/05/2-在HTML中使用JavaScrpt/deferAsync.png","modified":1454053254196,"shasum":"405aba297cb925c030bc11878e291edc350b3645"},{"_id":"public/404.html","modified":1454053254287,"shasum":"4744fe4ffc6f829ef32ff53855822e20f4e29e1f"},{"_id":"public/baidu_verify_i0wnrfk2ui.html","modified":1454053254298,"shasum":"b3f41baff9e890ecfccc0a8d360fd0919a39b450"},{"_id":"public/2016/01/29/void-0/index.html","modified":1454053254345,"shasum":"9344afd4d75e4a45b7a7c3a10758496d645242c6"},{"_id":"public/2016/01/29/好好学学number/index.html","modified":1454053254395,"shasum":"a2d24d94dc6933fe18df0d16170a68c102eef95c"},{"_id":"public/2016/01/29/好好学学undefined！/index.html","modified":1454053254412,"shasum":"2a6bdbd7cba89dfcf66d369d973182dbcff80532"},{"_id":"public/2016/01/27/如何学习javascript-转帖/index.html","modified":1454053254427,"shasum":"6633da0233b830128c538e1a4a65eed504670e83"},{"_id":"public/2016/01/21/ECMAScrip中的对象存取器-getter和setter/index.html","modified":1454053254440,"shasum":"977daa5504f50942e760c2b9a4d08a8f259bca9b"},{"_id":"public/2016/01/21/严格模式/index.html","modified":1454053254463,"shasum":"61ce027d7500ab205d7aee6f1bd74a606bc488f9"},{"_id":"public/2016/01/20/3-第三章基本概念/index.html","modified":1454053254483,"shasum":"98dd295eca1c1b2166e1f0f0ed68b11d81b0d1f4"},{"_id":"public/2016/01/19/webkit的预加载扫描器/index.html","modified":1454053254493,"shasum":"cef94c901b1bf070903dca307b08397c35da87f5"},{"_id":"public/2016/01/08/DOMContentLoaded/index.html","modified":1454053254516,"shasum":"b732a2d81a0dedf46d08748f385dc9e5660085de"},{"_id":"public/2016/01/05/2-在HTML中使用JavaScrpt/index.html","modified":1454053254540,"shasum":"967c91a1df2935275133ccf34bfd8d12513cf35d"},{"_id":"public/2016/01/05/1-JavaScrpt简介/index.html","modified":1454053254555,"shasum":"10f9f6bba632fcfdff3f152a64b25d54bab1fcd3"},{"_id":"public/2016/01/05/hello-world/index.html","modified":1454053254566,"shasum":"d60b485283317c8e2951c3217478a5b8e24c6749"},{"_id":"public/archives/index.html","modified":1454053254579,"shasum":"648955e7ac33edfd6757c8dd6aad524d5cc43c87"},{"_id":"public/archives/page/2/index.html","modified":1454053254587,"shasum":"7515344857f9263ae9e46e9c47cf96679aed8b08"},{"_id":"public/archives/2016/index.html","modified":1454053254605,"shasum":"9135b1c2f94a013cfaab4f88d312c32a10af8e02"},{"_id":"public/archives/2016/page/2/index.html","modified":1454053254612,"shasum":"96338217cbea9b23958abde6b9c099e63db25517"},{"_id":"public/archives/2016/01/index.html","modified":1454053254623,"shasum":"18a9f91f96e5003fa55aacc6fb415f3f061f82ee"},{"_id":"public/archives/2016/01/page/2/index.html","modified":1454053254638,"shasum":"67ba2e090a3786f7da460cd36b02d4220577346e"},{"_id":"public/categories/JavaScript/index.html","modified":1454053254647,"shasum":"fa478af0786a62d9ac0622ba576850ddb6f46069"},{"_id":"public/categories/《JS高程3-笔记》/index.html","modified":1454053254654,"shasum":"c95c7d2ba193adf9d5e46083468923f87ab92c82"},{"_id":"public/tags/JavaScript/index.html","modified":1454053254661,"shasum":"b22f2735d3c1f441d78c0a9e9d5663805ec5a0ed"},{"_id":"public/tags/jQuery/index.html","modified":1454053254667,"shasum":"5912a2f39dab4b282c8144ccab206138c81fea9d"},{"_id":"public/index.html","modified":1454053254689,"shasum":"623b16a944c97c83798b2f62116b479167473a00"},{"_id":"public/page/2/index.html","modified":1454053254699,"shasum":"bd75866cc1926362c000b29ca6b33703cf23ba6d"}],"Category":[{"name":"JavaScript","_id":"cijzdrhxg0003n83vsrqmkobk"},{"name":"《JS高程3-笔记》","_id":"cijzdrhyt000vn83vixvj8dbl"}],"Data":[],"Page":[{"layout":"default","_content":"<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"www.yangshengdonghome.com\" homePageName=\"前端之路\"></script>","source":"404.html","raw":"---\nlayout: default\n---\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"www.yangshengdonghome.com\" homePageName=\"前端之路\"></script>","date":"2016-01-11T01:58:24.000Z","updated":"2016-01-11T02:26:30.000Z","path":"404.html","title":"","comments":1,"_id":"cijzdrhwi0000n83vy6zikk7u"},{"_content":"i0wnrfk2ui","source":"baidu_verify_i0wnrfk2ui.html","raw":"i0wnrfk2ui","date":"2016-01-12T04:22:37.000Z","updated":"2016-01-12T04:21:56.000Z","path":"baidu_verify_i0wnrfk2ui.html","title":"","comments":1,"layout":"page","_id":"cijzdrhx60001n83viijppxbo"}],"Post":[{"title":"如何学习javascript(转帖)","date":"2016-01-27T02:24:34.000Z","comments":1,"_content":"# 首先说明\n首先要说明的是，咱现在不是高手，最多还是一个半桶水，算是入了JS的门。 谈不上经验，都是一些教训。这个时候有人要说，“靠，你丫半桶水，凭啥教我们”。您先别急着骂，先听我说。你叫一个大学生去教小学数学，不见得比一个初中生教得好。因为大学生早已经过了那个阶段，都忘记自己怎么走过来的了。而对于初中生，刚好走过那个阶段，对自己怎么走过来的还记忆犹新，或者还有一些自己的总结。比如，很多高手觉得那本犀牛书入门很好，他们觉得太简单了，但以我的经验来看，它不是入门的最好选择。\n<!--more-->\n# 先说说学js的条件\n论条件，咱是文科生，大学专业工商管理，和计算机毛关系都没；有人说英语，读了四年大学，很遗憾，咱还四级没混过；就咱这条件都学得乐呵呵的，您还等啥。 当然学习JS也是有门槛的，就是你的html和css至少还比较熟练，您不能连<body>这东东是干啥的都不知道就开始上JS了，学乘除前，学好加减法总是有益无害的。\n# 再说几点忠告\n\n1. 不要着急看一些复杂网页效果的代码，这样除了打击你自信心，什么也学不到。没达到一定的武功水平，割了小JJ也学不会葵花宝典的。\n2. 别急着加技术交流QQ群，加牛人QQ。如果你找张三丰交流武功，你上去第一句问“丰哥，where is 丹田？”，你会被他一掌劈死的。\n3. 看网上什么多少天精通JS，啥啥啥从入门到精通，这种教程直接跳过吧，太多的事实证明，以一种浮躁的心态去做任何事都会以失败而告终。\n4. 千万别去弄啥电脑培训，花了钱和时间不说，关键是学不到东西。本来你买两本好书自学3个月能学会的，他们硬是能折腾你两年。\n\n# 推荐几本好书\n“超毛，你丫吹了半天牛B，还是没说怎么学啊” 呵呵，我也没啥特别的办法，只是推荐几本好书。推荐的书，得按先后顺序看。别第一本没看完，就急着上第二本，并不是每次“穿越”都能成功的\n## 第一阶段：《JavaScript DOM编程艺术》\n看这本书之前，请先确认您对Javascript有个基本的了解，应该知道if else之类的语法，如果不懂，先去看看我第二阶段推荐的《Javascript高级程序设计》的前三章，记住看三章就别往下看了，回到《JavaScript DOM编程艺术》这本书上来。 学习Javascript用《JavaScript DOM编程艺术》来入门最好不过了，老老实实看两遍，看完了你就会对JS有一个大概的了解，整本书都围绕着一个网页效果例子展开，你跟着老老实实敲一篇，敲完之后，你会发现这个效果不是常在网页中看到么，发现自己也能做出来网上的效果了，嘿嘿，小有成就感吧。\n## 第二阶段：《JavaScript高级程序设计》\n有的书是用来成为经典的，比如犀牛书；还有些书是用来超越经典的，显然这本书就是这种。书中章章经典，由浅入深，其中第6章，关于JS面向对象的解说，没有教程出其右。 如果有一场满分100分的JS考试，看了《JavaScript DOM编程艺术》能让你拿到20分，那么看完这本书，你就能拿到60分以上了。学完后，你会成就感倍增的，相信我（至少看两遍，推荐三篇，跟着书上的代码一行行的敲）。 这本书强烈推荐购买，写的太TMD牛逼了，给你带来的价值超过百倍千倍。 这本书最新的是第三版，貌似就是前些日子出来的，我看的是第二版，第三版相对第二版变动不大，添加了几章内容，价格目前相差10元左右。 接下来，恭喜你可以下山了，这个时候可以自己做一些事情了。 你可以去Ferris这个教程看看他写的这些效果，看看源代码，怎么样，是不是觉得有一部分很简单了，尝试着跟着他写一写这些效果吧。 学技术闭门造车是行不通的，适当的加一两个QQ群交流（注重质量），常去论坛逛逛，你会经常有些小收获的。 再有就是看看前辈这些牛人前辈们分享的文章，它会让你的学习事半功倍的，这里是热心人收集的国内一些牛人的博客、个人网站，点这里。\n## 第三阶段：《JavaScript语言精粹》和《高性能JavaScript》\n接下来两本书《JavaScript语言精粹》和《高性能JavaScript》算是JS高级教程的补充，里面有一些内容和JS高级教程重复了，两本书可以同时看，都不厚，可以对前面所学的有一个很好的加强和巩固。\n## 第四阶段：《JavaScript DOM高级程序设计》和《JavaScript设计模式》\n在吃透了前面所说的书之后，接下来两本书的顺序已经无关紧要了，《JavaScript DOM高级程序设计》（注意和《JavaScript 高级程序设计》相区别）和《JavaScript设计模式》，这两本都是重量级的书，能让你的JS技术上一个新的台阶；这两本书前者主修炼外功，后者主修炼内功，有点想乾坤大挪移和九阳神功的关系。《JavaScript DOM高级程序设计》 首先教你搭建一个类似JQuery的额工具函数库，然后通过讲解几个实际中经常遇到的几个应用例子，会让初学者受益匪浅。《JavaScript设计模式》主要讲Javascript的设计模式，说实话，翻译的质量很一般，有些生硬，但已经基本不影响你的学习，看代码完全可以理解出自己的意思。\n# 最后想说的\n不安逸，不浮躁。任何学习都不是一蹴而就的，牛B就是一个学习积累的过程，别指望两三个月，你的水平就多么厉害。倚天屠龙记里面的武功最牛B的是张三丰，而不是张无忌。任何工作都需要多种技能，别忽略了html, css等其他知识的学习。\n\n>转自 (博客园)[http://kb.cnblogs.com/page/191787/]","source":"_posts/如何学习javascript-转帖-2016-01-27.md","raw":"title: 如何学习javascript(转帖)\ndate: 2016-01-27 10:24:34\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# 首先说明\n首先要说明的是，咱现在不是高手，最多还是一个半桶水，算是入了JS的门。 谈不上经验，都是一些教训。这个时候有人要说，“靠，你丫半桶水，凭啥教我们”。您先别急着骂，先听我说。你叫一个大学生去教小学数学，不见得比一个初中生教得好。因为大学生早已经过了那个阶段，都忘记自己怎么走过来的了。而对于初中生，刚好走过那个阶段，对自己怎么走过来的还记忆犹新，或者还有一些自己的总结。比如，很多高手觉得那本犀牛书入门很好，他们觉得太简单了，但以我的经验来看，它不是入门的最好选择。\n<!--more-->\n# 先说说学js的条件\n论条件，咱是文科生，大学专业工商管理，和计算机毛关系都没；有人说英语，读了四年大学，很遗憾，咱还四级没混过；就咱这条件都学得乐呵呵的，您还等啥。 当然学习JS也是有门槛的，就是你的html和css至少还比较熟练，您不能连<body>这东东是干啥的都不知道就开始上JS了，学乘除前，学好加减法总是有益无害的。\n# 再说几点忠告\n\n1. 不要着急看一些复杂网页效果的代码，这样除了打击你自信心，什么也学不到。没达到一定的武功水平，割了小JJ也学不会葵花宝典的。\n2. 别急着加技术交流QQ群，加牛人QQ。如果你找张三丰交流武功，你上去第一句问“丰哥，where is 丹田？”，你会被他一掌劈死的。\n3. 看网上什么多少天精通JS，啥啥啥从入门到精通，这种教程直接跳过吧，太多的事实证明，以一种浮躁的心态去做任何事都会以失败而告终。\n4. 千万别去弄啥电脑培训，花了钱和时间不说，关键是学不到东西。本来你买两本好书自学3个月能学会的，他们硬是能折腾你两年。\n\n# 推荐几本好书\n“超毛，你丫吹了半天牛B，还是没说怎么学啊” 呵呵，我也没啥特别的办法，只是推荐几本好书。推荐的书，得按先后顺序看。别第一本没看完，就急着上第二本，并不是每次“穿越”都能成功的\n## 第一阶段：《JavaScript DOM编程艺术》\n看这本书之前，请先确认您对Javascript有个基本的了解，应该知道if else之类的语法，如果不懂，先去看看我第二阶段推荐的《Javascript高级程序设计》的前三章，记住看三章就别往下看了，回到《JavaScript DOM编程艺术》这本书上来。 学习Javascript用《JavaScript DOM编程艺术》来入门最好不过了，老老实实看两遍，看完了你就会对JS有一个大概的了解，整本书都围绕着一个网页效果例子展开，你跟着老老实实敲一篇，敲完之后，你会发现这个效果不是常在网页中看到么，发现自己也能做出来网上的效果了，嘿嘿，小有成就感吧。\n## 第二阶段：《JavaScript高级程序设计》\n有的书是用来成为经典的，比如犀牛书；还有些书是用来超越经典的，显然这本书就是这种。书中章章经典，由浅入深，其中第6章，关于JS面向对象的解说，没有教程出其右。 如果有一场满分100分的JS考试，看了《JavaScript DOM编程艺术》能让你拿到20分，那么看完这本书，你就能拿到60分以上了。学完后，你会成就感倍增的，相信我（至少看两遍，推荐三篇，跟着书上的代码一行行的敲）。 这本书强烈推荐购买，写的太TMD牛逼了，给你带来的价值超过百倍千倍。 这本书最新的是第三版，貌似就是前些日子出来的，我看的是第二版，第三版相对第二版变动不大，添加了几章内容，价格目前相差10元左右。 接下来，恭喜你可以下山了，这个时候可以自己做一些事情了。 你可以去Ferris这个教程看看他写的这些效果，看看源代码，怎么样，是不是觉得有一部分很简单了，尝试着跟着他写一写这些效果吧。 学技术闭门造车是行不通的，适当的加一两个QQ群交流（注重质量），常去论坛逛逛，你会经常有些小收获的。 再有就是看看前辈这些牛人前辈们分享的文章，它会让你的学习事半功倍的，这里是热心人收集的国内一些牛人的博客、个人网站，点这里。\n## 第三阶段：《JavaScript语言精粹》和《高性能JavaScript》\n接下来两本书《JavaScript语言精粹》和《高性能JavaScript》算是JS高级教程的补充，里面有一些内容和JS高级教程重复了，两本书可以同时看，都不厚，可以对前面所学的有一个很好的加强和巩固。\n## 第四阶段：《JavaScript DOM高级程序设计》和《JavaScript设计模式》\n在吃透了前面所说的书之后，接下来两本书的顺序已经无关紧要了，《JavaScript DOM高级程序设计》（注意和《JavaScript 高级程序设计》相区别）和《JavaScript设计模式》，这两本都是重量级的书，能让你的JS技术上一个新的台阶；这两本书前者主修炼外功，后者主修炼内功，有点想乾坤大挪移和九阳神功的关系。《JavaScript DOM高级程序设计》 首先教你搭建一个类似JQuery的额工具函数库，然后通过讲解几个实际中经常遇到的几个应用例子，会让初学者受益匪浅。《JavaScript设计模式》主要讲Javascript的设计模式，说实话，翻译的质量很一般，有些生硬，但已经基本不影响你的学习，看代码完全可以理解出自己的意思。\n# 最后想说的\n不安逸，不浮躁。任何学习都不是一蹴而就的，牛B就是一个学习积累的过程，别指望两三个月，你的水平就多么厉害。倚天屠龙记里面的武功最牛B的是张三丰，而不是张无忌。任何工作都需要多种技能，别忽略了html, css等其他知识的学习。\n\n>转自 (博客园)[http://kb.cnblogs.com/page/191787/]","slug":"如何学习javascript-转帖","published":1,"updated":"2016-01-27T02:42:52.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhxc0002n83vgfezhbge"},{"title":"好好学学undefined！","date":"2016-01-29T01:48:56.000Z","comments":1,"_content":"# undefined类型\nundefined类型只有一个值，即特殊的undefined，我们称之为`字面值undefined`，undefined意为`未定义`。\n\n`字面值undefined`是全局Global对象（window）的一个特殊属性，其值是未定义的。但 typeof window.undefined 返回\"undefined\" 。\n\n我们可以通过下面的例子来验证undefined是否为全局Global对象（window）的属性:\n\n    alert('undefined' in window);//输出：true   \n    var anObj = {};   \n    alert('undefined' in anObj); //输出：false \n    从中可以看出，undefined是window对象的一个属性，但却不是anObj对象的一个属性。\n## `字面值undefined`的产生\n`字面值undefined`产生的原因有5种：\n\n    * 访问对象不存在的属性或方法\n    * 声明了变量但从未赋值\n    * 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n    * 方法没有返回值，默认返回undefined\n    * 访问越界的数组。\n    * void(expression) 形式的表达式。\n    \n    {% codeblock lang:JavaScript %}\n    var v1,obj = {};      \n      \n    console.log(v1); //`字面值undefined`    \n    console.log(obj.get); //`字面值undefined`\n    \n    typeof v1; // \"undefined\"    \n    typeof v2; // 对未声明的变量使用typeof 也会输出 \"undefined\"。     \n    typeof obj.get; // \"undefined\"\n    \n    var message1 = undefined;  //显示的设置为undefined\n    typeof message1 //\"undefined\"\n    \n    function test(){}; \n    console.log(test()); //`字面值undefined`\n    \n    var arr = []; \n    console.log(arr[8]) //`字面值undefined`\n    {% endcodeblock %}\n        \n<span style=\"color: red;\">当我们在程序中使用`字面值undefined`时，实际上使用的是window对象的undefined属性，同样，当我们定义一个变量但未赋予其初始值，例如：`var aValue;`这时，JavaScript在预编译时会将其初始值设置为对window.undefined属性的引用，于是，当我们将一个变量或值与undefined比较时，实际上是与window对象的undefined属性比较。这个比较过程中，JavaScript会搜索window对象名叫\"undefined\"的属性，然后再比较两个操作数的引用指针是否相同。</span>\n\n---\n您可以通过将变量与`字面值undefined`进行比较确定变量是否存在，您也可以通过将变量的类型与字符串“undefined”进行比较确定其类型是否为 undefined类型。\n以下示例演示了如何确定已声明的变量的 x：\n        \n    var x;\n    \n    // This method works.\n    if (x == undefined) { //这种方式只能对已经声明的变量使用，对未声明的变量使用会报错。\n        document.write(\"comparing x to undefined <br/>\");\n    }\n    \n    // This method doesn't work - you must check for the string \"undefined\".\n    if (typeof(x) == undefined) {//未执行，因为typeof 方法返回的是字符串。\n        document.write(\"comparing the type of x to undefined <br/>\");\n    }\n    // This method does work. \n    if (typeof(x) == \"undefined\") {\n        document.write(\"comparing the type of x to the string 'undefined'\");\n    }\n    \n    // Output: \n    // comparing x to undefined \n    // comparing the type of x to the string 'undefined'\n## 提高访问`字面值undefined`的性能：\n由于window对象的属性值是非常多的，在每一次与`字面值undefined`的比较中，搜索window对象的undefined属性都会花费时间。在需要频繁与undefined进行比较的函数中，这可能会是一个性能问题点。因此，在这种情况下，我们可以自行定义一个局部的undefined变量，来加快对undefined的比较速度。例如：\n\n    function anyFunc() {\n        var undefined; //自定义局部undefined变量\n        if (x == undefined){} //作用域上的引用比较\n        while (y != undefined){} //作用域上的引用比较\n    };\n其中，定义undefined局部变量时，其初始值会是对window.undefined属性值的引用。新定义的局部undefined变量存在与该函数的作用域上。\n在随后的比较操作中，JavaScript代码的书写方式没有任何的改变，但比较速度却很快。因为作用域上的变量数量会远远少于window对象的属性，搜索变量的速度会极大提高。\n这就是许多前端JS框架为什么常常要自己定义一个局部undefined变量的原因!!!\n比如jQuery 源码：\n\n    (function( window, undefined ) {\n        /*\n        * \n        * code\n        * \n        * */\n    })( window );","source":"_posts/好好学学undefined！-2016-01-29.md","raw":"title: 好好学学undefined！\ndate: 2016-01-29 09:48:56\ntags:\n- jQuery\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# undefined类型\nundefined类型只有一个值，即特殊的undefined，我们称之为`字面值undefined`，undefined意为`未定义`。\n\n`字面值undefined`是全局Global对象（window）的一个特殊属性，其值是未定义的。但 typeof window.undefined 返回\"undefined\" 。\n\n我们可以通过下面的例子来验证undefined是否为全局Global对象（window）的属性:\n\n    alert('undefined' in window);//输出：true   \n    var anObj = {};   \n    alert('undefined' in anObj); //输出：false \n    从中可以看出，undefined是window对象的一个属性，但却不是anObj对象的一个属性。\n## `字面值undefined`的产生\n`字面值undefined`产生的原因有5种：\n\n    * 访问对象不存在的属性或方法\n    * 声明了变量但从未赋值\n    * 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n    * 方法没有返回值，默认返回undefined\n    * 访问越界的数组。\n    * void(expression) 形式的表达式。\n    \n    {% codeblock lang:JavaScript %}\n    var v1,obj = {};      \n      \n    console.log(v1); //`字面值undefined`    \n    console.log(obj.get); //`字面值undefined`\n    \n    typeof v1; // \"undefined\"    \n    typeof v2; // 对未声明的变量使用typeof 也会输出 \"undefined\"。     \n    typeof obj.get; // \"undefined\"\n    \n    var message1 = undefined;  //显示的设置为undefined\n    typeof message1 //\"undefined\"\n    \n    function test(){}; \n    console.log(test()); //`字面值undefined`\n    \n    var arr = []; \n    console.log(arr[8]) //`字面值undefined`\n    {% endcodeblock %}\n        \n<span style=\"color: red;\">当我们在程序中使用`字面值undefined`时，实际上使用的是window对象的undefined属性，同样，当我们定义一个变量但未赋予其初始值，例如：`var aValue;`这时，JavaScript在预编译时会将其初始值设置为对window.undefined属性的引用，于是，当我们将一个变量或值与undefined比较时，实际上是与window对象的undefined属性比较。这个比较过程中，JavaScript会搜索window对象名叫\"undefined\"的属性，然后再比较两个操作数的引用指针是否相同。</span>\n\n---\n您可以通过将变量与`字面值undefined`进行比较确定变量是否存在，您也可以通过将变量的类型与字符串“undefined”进行比较确定其类型是否为 undefined类型。\n以下示例演示了如何确定已声明的变量的 x：\n        \n    var x;\n    \n    // This method works.\n    if (x == undefined) { //这种方式只能对已经声明的变量使用，对未声明的变量使用会报错。\n        document.write(\"comparing x to undefined <br/>\");\n    }\n    \n    // This method doesn't work - you must check for the string \"undefined\".\n    if (typeof(x) == undefined) {//未执行，因为typeof 方法返回的是字符串。\n        document.write(\"comparing the type of x to undefined <br/>\");\n    }\n    // This method does work. \n    if (typeof(x) == \"undefined\") {\n        document.write(\"comparing the type of x to the string 'undefined'\");\n    }\n    \n    // Output: \n    // comparing x to undefined \n    // comparing the type of x to the string 'undefined'\n## 提高访问`字面值undefined`的性能：\n由于window对象的属性值是非常多的，在每一次与`字面值undefined`的比较中，搜索window对象的undefined属性都会花费时间。在需要频繁与undefined进行比较的函数中，这可能会是一个性能问题点。因此，在这种情况下，我们可以自行定义一个局部的undefined变量，来加快对undefined的比较速度。例如：\n\n    function anyFunc() {\n        var undefined; //自定义局部undefined变量\n        if (x == undefined){} //作用域上的引用比较\n        while (y != undefined){} //作用域上的引用比较\n    };\n其中，定义undefined局部变量时，其初始值会是对window.undefined属性值的引用。新定义的局部undefined变量存在与该函数的作用域上。\n在随后的比较操作中，JavaScript代码的书写方式没有任何的改变，但比较速度却很快。因为作用域上的变量数量会远远少于window对象的属性，搜索变量的速度会极大提高。\n这就是许多前端JS框架为什么常常要自己定义一个局部undefined变量的原因!!!\n比如jQuery 源码：\n\n    (function( window, undefined ) {\n        /*\n        * \n        * code\n        * \n        * */\n    })( window );","slug":"好好学学undefined！","published":1,"updated":"2016-01-29T06:58:18.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhxl0007n83vnni0mvzg"},{"title":"好好学学number!","date":"2016-01-29T01:55:43.000Z","_content":"# Number类型\n\nJavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相等的，而且1加上1.0得到的还是一个整数，不会像有些语言那样变成小数。\n    \n    1 === 1.0 // true\n    1 + 1.0 // 2\n\n也就是说，在JavaScript语言的底层，根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算。\n\n由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n    \n    0.1 + 0.2 === 0.3  // false\n    \n    0.3 / 0.1          // 2.9999999999999996\n    \n    (0.3 - 0.2) === (0.2 - 0.1)    // false\n\n{% asset_img number2.png %}\n\n解释：根据国际标准IEEE-754，64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分（共52位），第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数。\n\n    {% codeblock lang:javascript %}\n    Math.pow(2, 53)        // 9007199254740992\n    \n    Math.pow(2, 53) + 1    // 9007199254740992\n    \n    Math.pow(2, 53) + 2    // 9007199254740994\n    \n    Math.pow(2, 53) + 3    // 9007199254740996\n    \n    Math.pow(2, 53) + 4    // 9007199254740996\n    {% endcodeblock %}\n    \n从上面示例可以看到，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于等于2的53次方的数值，都无法保持精度。因此，JavaScript提供的有效数字的精度为53个二进制位（IEEE 754规定有效数字第一位默认总是为1，不保存在64位浮点数之中，这一位再加上后面的52位，就是总共53位），也就是说，绝对值小于2的53次方的整数，即-(2<sup>53</sup>-1)到2<sup>53</sup>-1，都可以精确表示。\n    \n那么超过2<sup>53</sup>部分的数字怎么处理呢？\n\n    {% codeblock lang:javascript%}\n    Math.pow(2, 53)    // 9007199254740992\n    \n    9007199254740992111    // 9007199254740992000\n    \n    {% endcodeblock %}\n上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的`111`）都会无法保存，变成0。\n\n另一方面，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。\n\n如果指数部分等于或超过最大正值1024，JavaScript会返回`Infinity`（关于Infinity的介绍参见下文），这称为“正向溢出”；如果等于或超过最小负值-1023（即非常接近0），JavaScript会直接把这个数转为0，这称为“负向溢出”。事实上，JavaScript对指数部分的两个极端值（`11111111111`(二进制)和`00000000000`(二进制)）做了定义，`11111111111`(二进制)表示`NaN`和`Infinity`，`00000000000`(二进制)表示0。\n    \n    {% codeblock lang:javascript%}\n    var x = 0.5;\n    \n    for(var i = 0; i < 25; i++) {\n      x = x * x;\n    }\n    console.log(x);// 0\n    {% endcodeblock %}\n上面代码对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript就直接将其转为0。\n\n>* 精确地描述，Number类型拥有 18437736874454810627（即，2<sup>64</sup>-2<sup>53</sup>+3）个值，表示为 IEEE-754 格式 64 位双精度数值（IEEE 二进制浮点数算术中描述了它）。\n>* <span style=\"color: red;\">除了 IEEE 标准中的 9007199254740990（即，2<sup>53</sup>-2）个明显的“非数字”值；在 ECMAScript 中，它们被表示为一个单独的特殊值：NaN。</span>（请注意，NaN 值由程序表达式 NaN 产生，并假设执行程序不能调整定义的全局变量 NaN，在javascript中NaN是global全局对象的一个属性`window.NaN`） 在某些实现中，外部代码也许有能力探测出众多非数字值之间的不同，但此类行为依赖于具体实现；对于 ECMAScript 代码而言，NaN 值相互之间无法区别。\n>* 还有另外两个特殊值，称为正无穷和负无穷。为简洁起见，在说明目的时，用符号 +∞ 和 -∞ 分别代表它们。（请注意，两个无限数值由程序表达式 +Infinity（简作 Infinity） 和 -Infinity 产生，并假设执行程序不能调整定义的全局变量 Infinity，在javascript中global全局对象的一个Infinity属性`window.Infinity`）。\n>* 另外 18437736874454810624（即，2<sup>64</sup>-2<sup>53</sup>）个值被称为有限数值，其中的一半是正数，另一半是负数，对于每个正数而言，都有一个与之对应的、相同规模的负数。\n>* 请注意，还有一个正零和一个负零。\n\n数轴：\n\n{% asset_img number.png [200] [400] %}\n\n    \n> 对于这个如果有兴趣细扣就[点这里](http://www.cnblogs.com/kingwolfofsky/archive/2011/07/21/2112299.html)，[还有这里](https://www.w3.org/html/ig/zh/wiki/ES5/types#Number_.E7.B1.BB.E5.9E.8B)\n\n## 整数\n\n整数可以被表示成十进制（基数为10）、十六进制（基数为16）以及八进制（基数为8）。\n\n* 十进制：十进制整数字组成的数字序列，不带前导0（零）。\n* 八进制：八进制整数只能包括数字0-7，通过在八进制整数前面加前导`0`（零）或者或`0o`的数值来表示八进制整数。八进制整数只包含 0 到 7 的数字。<span style=\"color:red;\">具有前导`0`并包含数字“8”和/或“9”的数字将被解释为十进制数字</span>，具有前导`0o`并包含数字“8”和/或“9”的数字将会报错。\n* 十六进制：通过在整数前面加前导“0x”（零和 x|X）来表示十六进制（“hex”）整数。字母 A 到 F 以单个数字的形式表示以 10 为基数的 10 到 15。字母 A 到 F 用于以单个数字的形式表示以 10 为基数的 10 到 15。即，0xF 相当于 15，0x10 相当于 16。\n* 二进制：有前缀`0b`或`0B`的数值。\n\n在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值，还有严格模式下禁止使用八进制。\n    \n    {% codeblock lang:javascript%}\n    //默认情况下，JavaScript内部会自动将八进制、十六进制、二进制转为十进制。    \n    0xff   // 255\n    -0xF1A7// -61863\n    0o377  // 255\n    015    // 13\n    019    // 19\n    0b11   // 3\n    \n    //如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。\n    0xzz // 报错\n    0o88 // 报错\n    0b22 // 报错\n    {% endcodeblock %}\n\n<span style=\"color:#555;\">IEBUG：从 Internet Explorer 9 标准模式、Internet Explorer 10 标准模式、Internet Explorer 11 标准模式和 Windows 应用商店应用 开始，parseInt 函数不将前缀为“0”的字符串视为八进制。但在不使用 parseInt 函数时，前缀为“0”的字符串仍可被解释为八进制。</span>\n\n## 浮点值\n\n* 一个十进制整数，它可以带符号（即前面的“+”或“ - ”号），\n* 一个小数点（“.”），\n* 一个小数部分（由一串十进制数表示），\n* 一个指数部分\n指数部分是以“e”或“E”开头后面跟着一个整数，可以有正负号（即前面写“+”或“-”）。一个浮点数字面值必须至少有一位数字，后接小数点或者“e”（大写“E”也可）组成。一些浮点数字面值的例子，如3.1415，-3.1E13，.1e12以及2E-12。\n简言之，其语法是：\n\n        [digits][.digits][(E|e)[(+|-)]digits]\n        //实例:\n        3.14\n        2345.789\n        .3333333333333333333 // 0 可以省略\n\n以下两种情况，JavaScript会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。\n\n* 小数点前的数字多于21位\n    {% codeblock lang:javascript%}\n    console.log(1234567890123456789012)    // 1.2345678901234568e+21\n    {% endcodeblock %}\n* 小数点后的零多于5个\n    {% codeblock lang:javascript%}\n    console.log(0.0000003) //3e-7\n    {% endcodeblock %}\n\n## NaN\n    NaN 用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。由上面的表中可以看出，对于单精度浮点数，NaN 表示为指数为 emax + 1 = 128（指数域全为 1），且尾数域不等于零的浮点数。IEEE 标准没有要求具体的尾数域，所以 <span style=\"red;\">NaN 实际上不是一个，而是一族</span>。\n    \n## +0 和 -0\n\n先看一道题： 假如 A === B 并且 1/A < 1/B; 请问 A 等于 几？\n\n### 产生原因\n数字需要被编码才能进行数字化存储.举个例子,假如我们要将一个整数编码为4位的二进制数,使用原码(sign-and-magnitude)方法,则最高位是符号位(0代表正,1代表负),剩下的三位表示大小(具体的值).因此,−2和+2会编码成为下面这样:\n\n    1010 // +2\n    0010 // -2\n    这就意味着将会有两个零:\n    1000 // -0\n    0000 // +0\n在JavaScript中,所有的数字都是浮点数,都是根据IEEE-754标准中的浮点数算法以双精度格式被编码。这个标准中正负号的处理方式类似于原码(sign-and-magnitude)方法中整数的编码方式,所以也有正负零。\n\n### 参与运算\n    +0 === -0 //true 虽然有正0和负0但是他们两个是相等\n    -0 < +0   //false  \n    +0 < -0   //false\n    \n    -0 + -0  // -0\n    -0 + +0  // +0\n    +0 X -5  // -0\n    -0 X -5  // +0\n     1 / +0  // Infinity\n     1 / -0  // -Infinity\n    +0 / -0  // NaN\n\n### 参与Math对象的方法\n\n* Math.pow(x,y)方法可返回从  之间的角度。\n    \n    {% codeblock lang:JavaScript %}\n        Math.pow(+0, -1) // Infinity\n        Math.pow(-0, -1) // -Infinity\n    {% endcodeblock %}\n    \n* Math.atan2(x,y)方法可返回从 x<sup>y</sup> 的值。\n\n        x = 0 , y <= -0     // π(3.141592653589793)\n        Math.atan2(+0, -0)  // π(3.141592653589793)\n        \n        x = 0 , y >= 0      // 0\n        Math.atan2(+0, +0)  // 0\n        \n        x = -0 , y >= +0    // -0\n        Math.atan2(-0, +0)  // -0\n        \n        x = -0 , y <= -0    // -π(-3.141592653589793)\n        Math.atan2(-0, -0)  // -π(-3.141592653589793)\n    \n    \n* Math.round()是另外一个参数不为零却产生-0结果的操作:\n\n        Math.round(-0.1) // -0\n\n### 区分这两个零\n\n方法1: 判断一个零是正还是负的标准解法是用它除1,然后看计算的结果是-Infinity还是+Infinity\n    \n        function isNegativeZero(x) {\n            return x === 0 && (1/x < 0);\n        }\n\n方法2: 除了上面讲的几种解法.还有一个解法来自Allen Wirfs-Brock(译者注:TC39编辑,ES标准就是他写出来的。):\n        \n        {% codeblock lang:JavaScript %}\n        function isNegativeZero(x) {\n            if (x !== 0) return false;\n            var obj = {};\n            Object.defineProperty(obj, 'z', { value: -0, configurable: false });\n            try {\n                // 如果x的值和z属性的当前值不相等的话,就会抛出异常.\n                Object.defineProperty(obj, 'z', { value: x });\n            } catch (e) {\n                return false\n            };\n            return true;\n        }\n        {% endcodeblock %}\n        \n解释: 通常情况下,你不能重新定义一个不可配置的对象属性，否则会抛出异常:`TypeError: Cannot redefine property: z`可是，如果你重新定义属性时指定的属性特性的值与该特性当前的值相等，则JavaScript会忽略掉这个重定义，不会抛出异常。其中在判断两个值是否相等时使用的运算不是===，是一个称之为SameValue的内部算法，该算法可以区分开 -0 和 +0 。可以从Wirfs-Brock的原文中了解更多细。(冻结一个对象会让该对象的所有属性变的不可配置)。\n\n> 在执行一些特殊方法的时候，比如alert或innerHTML等方法，它将由脚本解析器自动调用toString()方法。\n\n看完上面这些，那么这节开头的题目的结果自然而然就知道喽。\n\n引用：\n> [紫云飞](http://www.cnblogs.com/ziyunfei/archive/2012/12/10/2777099.html)\n> [阮一峰](http://javascript.ruanyifeng.com/grammar/number.html)","source":"_posts/好好学学number-2016-01-29.md","raw":"title: '好好学学number!'\ndate: 2016-01-29 09:55:43\ntags:\n---\n# Number类型\n\nJavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相等的，而且1加上1.0得到的还是一个整数，不会像有些语言那样变成小数。\n    \n    1 === 1.0 // true\n    1 + 1.0 // 2\n\n也就是说，在JavaScript语言的底层，根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算。\n\n由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n    \n    0.1 + 0.2 === 0.3  // false\n    \n    0.3 / 0.1          // 2.9999999999999996\n    \n    (0.3 - 0.2) === (0.2 - 0.1)    // false\n\n{% asset_img number2.png %}\n\n解释：根据国际标准IEEE-754，64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分（共52位），第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数。\n\n    {% codeblock lang:javascript %}\n    Math.pow(2, 53)        // 9007199254740992\n    \n    Math.pow(2, 53) + 1    // 9007199254740992\n    \n    Math.pow(2, 53) + 2    // 9007199254740994\n    \n    Math.pow(2, 53) + 3    // 9007199254740996\n    \n    Math.pow(2, 53) + 4    // 9007199254740996\n    {% endcodeblock %}\n    \n从上面示例可以看到，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于等于2的53次方的数值，都无法保持精度。因此，JavaScript提供的有效数字的精度为53个二进制位（IEEE 754规定有效数字第一位默认总是为1，不保存在64位浮点数之中，这一位再加上后面的52位，就是总共53位），也就是说，绝对值小于2的53次方的整数，即-(2<sup>53</sup>-1)到2<sup>53</sup>-1，都可以精确表示。\n    \n那么超过2<sup>53</sup>部分的数字怎么处理呢？\n\n    {% codeblock lang:javascript%}\n    Math.pow(2, 53)    // 9007199254740992\n    \n    9007199254740992111    // 9007199254740992000\n    \n    {% endcodeblock %}\n上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的`111`）都会无法保存，变成0。\n\n另一方面，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。\n\n如果指数部分等于或超过最大正值1024，JavaScript会返回`Infinity`（关于Infinity的介绍参见下文），这称为“正向溢出”；如果等于或超过最小负值-1023（即非常接近0），JavaScript会直接把这个数转为0，这称为“负向溢出”。事实上，JavaScript对指数部分的两个极端值（`11111111111`(二进制)和`00000000000`(二进制)）做了定义，`11111111111`(二进制)表示`NaN`和`Infinity`，`00000000000`(二进制)表示0。\n    \n    {% codeblock lang:javascript%}\n    var x = 0.5;\n    \n    for(var i = 0; i < 25; i++) {\n      x = x * x;\n    }\n    console.log(x);// 0\n    {% endcodeblock %}\n上面代码对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript就直接将其转为0。\n\n>* 精确地描述，Number类型拥有 18437736874454810627（即，2<sup>64</sup>-2<sup>53</sup>+3）个值，表示为 IEEE-754 格式 64 位双精度数值（IEEE 二进制浮点数算术中描述了它）。\n>* <span style=\"color: red;\">除了 IEEE 标准中的 9007199254740990（即，2<sup>53</sup>-2）个明显的“非数字”值；在 ECMAScript 中，它们被表示为一个单独的特殊值：NaN。</span>（请注意，NaN 值由程序表达式 NaN 产生，并假设执行程序不能调整定义的全局变量 NaN，在javascript中NaN是global全局对象的一个属性`window.NaN`） 在某些实现中，外部代码也许有能力探测出众多非数字值之间的不同，但此类行为依赖于具体实现；对于 ECMAScript 代码而言，NaN 值相互之间无法区别。\n>* 还有另外两个特殊值，称为正无穷和负无穷。为简洁起见，在说明目的时，用符号 +∞ 和 -∞ 分别代表它们。（请注意，两个无限数值由程序表达式 +Infinity（简作 Infinity） 和 -Infinity 产生，并假设执行程序不能调整定义的全局变量 Infinity，在javascript中global全局对象的一个Infinity属性`window.Infinity`）。\n>* 另外 18437736874454810624（即，2<sup>64</sup>-2<sup>53</sup>）个值被称为有限数值，其中的一半是正数，另一半是负数，对于每个正数而言，都有一个与之对应的、相同规模的负数。\n>* 请注意，还有一个正零和一个负零。\n\n数轴：\n\n{% asset_img number.png [200] [400] %}\n\n    \n> 对于这个如果有兴趣细扣就[点这里](http://www.cnblogs.com/kingwolfofsky/archive/2011/07/21/2112299.html)，[还有这里](https://www.w3.org/html/ig/zh/wiki/ES5/types#Number_.E7.B1.BB.E5.9E.8B)\n\n## 整数\n\n整数可以被表示成十进制（基数为10）、十六进制（基数为16）以及八进制（基数为8）。\n\n* 十进制：十进制整数字组成的数字序列，不带前导0（零）。\n* 八进制：八进制整数只能包括数字0-7，通过在八进制整数前面加前导`0`（零）或者或`0o`的数值来表示八进制整数。八进制整数只包含 0 到 7 的数字。<span style=\"color:red;\">具有前导`0`并包含数字“8”和/或“9”的数字将被解释为十进制数字</span>，具有前导`0o`并包含数字“8”和/或“9”的数字将会报错。\n* 十六进制：通过在整数前面加前导“0x”（零和 x|X）来表示十六进制（“hex”）整数。字母 A 到 F 以单个数字的形式表示以 10 为基数的 10 到 15。字母 A 到 F 用于以单个数字的形式表示以 10 为基数的 10 到 15。即，0xF 相当于 15，0x10 相当于 16。\n* 二进制：有前缀`0b`或`0B`的数值。\n\n在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值，还有严格模式下禁止使用八进制。\n    \n    {% codeblock lang:javascript%}\n    //默认情况下，JavaScript内部会自动将八进制、十六进制、二进制转为十进制。    \n    0xff   // 255\n    -0xF1A7// -61863\n    0o377  // 255\n    015    // 13\n    019    // 19\n    0b11   // 3\n    \n    //如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。\n    0xzz // 报错\n    0o88 // 报错\n    0b22 // 报错\n    {% endcodeblock %}\n\n<span style=\"color:#555;\">IEBUG：从 Internet Explorer 9 标准模式、Internet Explorer 10 标准模式、Internet Explorer 11 标准模式和 Windows 应用商店应用 开始，parseInt 函数不将前缀为“0”的字符串视为八进制。但在不使用 parseInt 函数时，前缀为“0”的字符串仍可被解释为八进制。</span>\n\n## 浮点值\n\n* 一个十进制整数，它可以带符号（即前面的“+”或“ - ”号），\n* 一个小数点（“.”），\n* 一个小数部分（由一串十进制数表示），\n* 一个指数部分\n指数部分是以“e”或“E”开头后面跟着一个整数，可以有正负号（即前面写“+”或“-”）。一个浮点数字面值必须至少有一位数字，后接小数点或者“e”（大写“E”也可）组成。一些浮点数字面值的例子，如3.1415，-3.1E13，.1e12以及2E-12。\n简言之，其语法是：\n\n        [digits][.digits][(E|e)[(+|-)]digits]\n        //实例:\n        3.14\n        2345.789\n        .3333333333333333333 // 0 可以省略\n\n以下两种情况，JavaScript会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。\n\n* 小数点前的数字多于21位\n    {% codeblock lang:javascript%}\n    console.log(1234567890123456789012)    // 1.2345678901234568e+21\n    {% endcodeblock %}\n* 小数点后的零多于5个\n    {% codeblock lang:javascript%}\n    console.log(0.0000003) //3e-7\n    {% endcodeblock %}\n\n## NaN\n    NaN 用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。由上面的表中可以看出，对于单精度浮点数，NaN 表示为指数为 emax + 1 = 128（指数域全为 1），且尾数域不等于零的浮点数。IEEE 标准没有要求具体的尾数域，所以 <span style=\"red;\">NaN 实际上不是一个，而是一族</span>。\n    \n## +0 和 -0\n\n先看一道题： 假如 A === B 并且 1/A < 1/B; 请问 A 等于 几？\n\n### 产生原因\n数字需要被编码才能进行数字化存储.举个例子,假如我们要将一个整数编码为4位的二进制数,使用原码(sign-and-magnitude)方法,则最高位是符号位(0代表正,1代表负),剩下的三位表示大小(具体的值).因此,−2和+2会编码成为下面这样:\n\n    1010 // +2\n    0010 // -2\n    这就意味着将会有两个零:\n    1000 // -0\n    0000 // +0\n在JavaScript中,所有的数字都是浮点数,都是根据IEEE-754标准中的浮点数算法以双精度格式被编码。这个标准中正负号的处理方式类似于原码(sign-and-magnitude)方法中整数的编码方式,所以也有正负零。\n\n### 参与运算\n    +0 === -0 //true 虽然有正0和负0但是他们两个是相等\n    -0 < +0   //false  \n    +0 < -0   //false\n    \n    -0 + -0  // -0\n    -0 + +0  // +0\n    +0 X -5  // -0\n    -0 X -5  // +0\n     1 / +0  // Infinity\n     1 / -0  // -Infinity\n    +0 / -0  // NaN\n\n### 参与Math对象的方法\n\n* Math.pow(x,y)方法可返回从  之间的角度。\n    \n    {% codeblock lang:JavaScript %}\n        Math.pow(+0, -1) // Infinity\n        Math.pow(-0, -1) // -Infinity\n    {% endcodeblock %}\n    \n* Math.atan2(x,y)方法可返回从 x<sup>y</sup> 的值。\n\n        x = 0 , y <= -0     // π(3.141592653589793)\n        Math.atan2(+0, -0)  // π(3.141592653589793)\n        \n        x = 0 , y >= 0      // 0\n        Math.atan2(+0, +0)  // 0\n        \n        x = -0 , y >= +0    // -0\n        Math.atan2(-0, +0)  // -0\n        \n        x = -0 , y <= -0    // -π(-3.141592653589793)\n        Math.atan2(-0, -0)  // -π(-3.141592653589793)\n    \n    \n* Math.round()是另外一个参数不为零却产生-0结果的操作:\n\n        Math.round(-0.1) // -0\n\n### 区分这两个零\n\n方法1: 判断一个零是正还是负的标准解法是用它除1,然后看计算的结果是-Infinity还是+Infinity\n    \n        function isNegativeZero(x) {\n            return x === 0 && (1/x < 0);\n        }\n\n方法2: 除了上面讲的几种解法.还有一个解法来自Allen Wirfs-Brock(译者注:TC39编辑,ES标准就是他写出来的。):\n        \n        {% codeblock lang:JavaScript %}\n        function isNegativeZero(x) {\n            if (x !== 0) return false;\n            var obj = {};\n            Object.defineProperty(obj, 'z', { value: -0, configurable: false });\n            try {\n                // 如果x的值和z属性的当前值不相等的话,就会抛出异常.\n                Object.defineProperty(obj, 'z', { value: x });\n            } catch (e) {\n                return false\n            };\n            return true;\n        }\n        {% endcodeblock %}\n        \n解释: 通常情况下,你不能重新定义一个不可配置的对象属性，否则会抛出异常:`TypeError: Cannot redefine property: z`可是，如果你重新定义属性时指定的属性特性的值与该特性当前的值相等，则JavaScript会忽略掉这个重定义，不会抛出异常。其中在判断两个值是否相等时使用的运算不是===，是一个称之为SameValue的内部算法，该算法可以区分开 -0 和 +0 。可以从Wirfs-Brock的原文中了解更多细。(冻结一个对象会让该对象的所有属性变的不可配置)。\n\n> 在执行一些特殊方法的时候，比如alert或innerHTML等方法，它将由脚本解析器自动调用toString()方法。\n\n看完上面这些，那么这节开头的题目的结果自然而然就知道喽。\n\n引用：\n> [紫云飞](http://www.cnblogs.com/ziyunfei/archive/2012/12/10/2777099.html)\n> [阮一峰](http://javascript.ruanyifeng.com/grammar/number.html)","slug":"好好学学number","published":1,"updated":"2016-01-29T05:35:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijzdrhxq000cn83vucqgojzv"},{"title":"严格模式","date":"2016-01-21T05:55:51.000Z","comments":1,"_content":"# 概述\nECMAScript 5 的严格模式是JavaScript中的一种限制性更强的变种方式。严格模式不是一个子集：它在语义上与正常代码有着明显的差异。不支持严格模式的浏览器与同支持严格模式的浏览器行为上也不一样， 所以不要在未经严格模式特性测试情况下使用严格模式。严格模式可以与非严格模式共存，所以脚本可以逐渐的选择性加入严格模式。\n严格模式在语义上与正常的JavaScript有一些不同。\n* 首先，严格模式会将JavaScript陷阱直接变成明显的错误。\n* 其次，严格模式修正了一些引擎难以优化的错误：同样的代码有些时候严格模式会比非严格模式下更快。\n* 第三，严格模式禁用了一些有可能在未来版本中定义的语法。\n<!--more-->\n# 开启严格模式\n严格模式可以应用到整个script标签或某个别函数中。不要在封闭大括弧（ {} ）内这样做，在这样的上下文中这么做是没有效果的。\n## 为某个script标签开启严格模式\n为整个script标签开启严格模式, 需要在所有语句之前放一个特定语句 `\"use strict\";` （或 `'use strict';`）。\n      // 整个语句都开启严格模式的语法\n      \"use strict\";\n      var v = \"Hi!  I'm a strict mode script!\";\n这种语法存在陷阱，在代码上线前会进行压缩，如果用这种语法，一个js文件是严格模式的脚本另一个是非严格模式的脚本，压缩后合二为一，合并后的脚本代码可能会失去严格模式以正常模式展现。\n>将`\"use strict\"`放在脚本文件的第一行，则整个脚本都将以\"严格模式\"运行。如果这行语句不在第一行，则无效，整个脚本以\"正常模式\"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。\n>\n      ;//有这个分号 就是正常模式，没有这个分号就是严格模式\n      \"use strict\";\n      eval(\"var x; delete x;\"); // !!! 语法错误\n\n## 为某个函数开启严格模式\n      function strict() {\n        // 函数级别严格模式语法\n        'use strict';\n        function nested() {\n          return \"And so am I!\";\n        }\n        return \"Hi!  I'm a strict mode function!  \" + nested();\n      }\n# 严格模式有哪些不同？\n* 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;(将问题直接转化为错误,如语法错误或运行时错误)。\n* 提高编译器效率，增加运行速度。\n* 消除代码运行的一些不安全之处，保证代码运行的安全。\n* 为未来新版本的Javascript做好铺垫。\n\n# 代码在严格模式下受到的限制\n## 全局变量显式声明\n在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n\n      \"use strict\";\n      mistypedVaraible = 17; // 报错，mistypedVaraible未声明\n## 静态绑定\nJavascript语言的一个特点，就是允许\"动态绑定\"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。\n具体来说，涉及以下几个方面。\n### 禁止使用with语句\n因为with语句无法在编译时就确定，属性到底归属哪个对象。\n\n    \"use strict\";\n    var x = 17;\n    with (obj) // !!! 语法错误\n    {\n      // 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？\n      // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\n      x;\n    }\n### 创设eval作用域\n正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。\n严格模式创设了第三种作用域：eval作用域。\n正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。\n严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。\n\n    \"use strict\";\n    eval(\"var testvar = 10\");\n    console.log(testvar);//在严格模式下报错，在非严格模式下 打印 10\n## 禁止删除变量\n严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。\n\n    \"use strict\";\n    var x;\n    delete x; // 语法错误\n\n    eval(\"var x; delete x;\"); // !!! 语法错误\n\n    var o = Object.create(null, {'x': {\n        value: 1,\n        configurable: true\n    }});\n    delete o.x; // 删除成功\n## 增强的安全措施\n### 禁止this关键字指向全局对象，默认值undefined\n\n    function f(){\n    　　return !this;\n    }\n    // 返回false，因为\"this\"指向全局对象，\"!this\"就是false\n    function f(){\n    　　\"use strict\";\n    　　return !this;\n    }\n    // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\n### 禁止在函数内部遍历调用栈\n    function f1() {　　　　\n        \"use strict\";　　　　\n        f1.caller; // 报错 正常模式下f1.caller是最后一个调用f1的函数\n        f1.arguments; // 报错\n        　　\n    }　　\n    f1();\n### 显式报错\nNaN 是一个不可写的全局变量. 在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常\n\n    \"use strict\";\n    NaN = 2;//报错\n正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.defineProperty(o, \"v\", {\n        value: 1,\n        writable: false\n    });　　\n    o.v = 2; // 报错\n严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。\n\n    \"use strict\";\n    　\n    var o = {\n        　get v() {return 1; }　　\n    };　　\n    o.v = 2; // 报错\n严格模式下，对禁止扩展的对象添加新属性，会报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.preventExtensions(o);　　\n    o.v = 1; // 报错\n严格模式下，删除一个不可删除的属性，会报错。\n\n    \"use strict\";　　\n    delete Object.prototype; // 报错\n## 重名错误\n### 对象不能有重名的属性\n正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    var o = {　　　　\n        p: 1,\n        　　　　p: 2　　\n    }; // 语法错误\n### 函数不能有重名的参数\n正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    function f(a, a, b) { // 语法错误\n        　　　　\n        return;　　\n    }\n## 禁止八进制表示法\n正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。\n\n    \"use strict\";　　\n    var n = 0100; // 语法错误\n## eval和arguments对象的限制\n### 赋值和绑定\n首先, 名称 eval 和 arguments 不能通过程序语法被绑定(be bound)或赋值，以下这些尝试都将报错：\n\n    \"use strict\";\n    eval = 17;\n    arguments++;\n    ++eval;\n    var obj = { set p(arguments) { } };\n    var eval;\n    try { } catch (arguments) { }\n    function x(eval) { }\n    function arguments() { }\n    var y = function eval() { };\n    var f = new Function(\"arguments\", \"'use strict'; return 17;\");\n### arguments不再追踪参数的变化\n\n    function f(a) {　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 正常模式为[2,2]\n    　　\n    function f(a) {　　　　\n        \"use strict\";　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 严格模式为[2,1]\n### 禁止使用arguments.callee\n这意味着，你无法在匿名函数内部调用自身了，可以用命名函数表达式解决这个问题。\n\n    \"use strict\";　　\n    var f = function() {\n        return arguments.callee;\n    };　　\n    f(); // 报错\n## 函数必须声明在顶层\n将来Javascript的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n\n    \"use strict\";　　\n    if (true) {　　　　\n        function f() {} // 语法错误\n            　　\n    }　　\n    for (var i = 0; i < 5; i++) {　　　　\n        function f2() {} // 语法错误\n            　　\n    }\n\n## 保留字\n为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n使用这些词作为变量名将会报错。此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。\n\n# 向严格模式过度\n## 逐步过渡\n严格模式被仔细设计过，因此可以逐渐地进行迁移。你可以分别改变各个文件，甚至以函数级的粒度迁移至严格模式。\n## 过程\n如果代码中使用\"use strict\"开启了严格模式,则下面的情况都会在脚本运行之前抛出`SyntaxError`异常:\n### 语法错误\n\n* 八进制语法:var n = 023和var s = \"\\047\"\n* with语句\n* 使用delete删除一个变量名(而不是属性名):delete myVariable\n* 使用eval或arguments作为变量名或函数名\n* 使用未来保留字(也许会在ECMAScript 6中使用):implements, interface, let, package, private, protected, public, static,和yield作为变量名或函数名\n* 在语句块中使用函数声明:if(a<b){ function f(){} }\n* 其他错误:\n* * 对象子面量中使用两个相同的属性名:{a: 1, b: 3, a: 7}\n* * 函数形参中使用两个相同的参数名:function f(a, b, b){}\n\n这些错误是有利的，因为可以揭示简陋的错误和坏的实践，这些错误会在代码运行前被抛出。\n\n### 运行时错误\nJavaScript曾经会在一些上下文的某些情况中静默的失败，严格模式会在这些情况下抛出错误。如果你的代码包含这样的场景，请务必测试以确保没有代码受到影响。再说一次，严格模式是可以设置在代码粒度下的。\n\n1. 给一个未声明的变量赋值\n2. 改变一个全局对象的值可能会造成不可预期的后果。如果你真的想设置一个全局对象的值，把他作为一个参数并且明确的把它作为一个属性。\n          var global = this; // in the top-level context, \"this\" always refers the global object\n          function f() {\n              \"use strict\";\n              var a = 12;\n              global.b = a + x * 35;\n          }\n          f();\n\n3. 尝试删除一个不可配置的属性。\n          \"use strict\";\n          delete Object.prototype; // error!\n   在非严格模式中,这样的代码只会静默失败,这样可能会导致用户误以为删除操作成功了.\n\n4. `arguments`对象和函数属性\n\n在严格模式下,访问`arguments.callee`, `arguments.caller`, `anyFunction.caller`以及`anyFunction.arguments`都会抛出异常.唯一合法的使用应该是在其中命名一个函数并且重用之\n\n### 语义差异\n1. 函数调用中的this\n在普通的函数调用f()中，this的值会指向全局对象。在严格模式中，this的值会指向undefined。当函数通过call和apply调用时，如果传入的thisvalue参数是一个null和undefined除外的原始值(字符串，数字，布尔值)，则this的值会成为那个原始值对应的包装对象，如果thisvalue参数的值是undefined或null，则this的值会指向全局对象。在严格模式中，this的值就是thisvalue参数的值，没有任何类型转换。\n2. arguments对象属性不与对应的形参变量同步更新\n在非严格模式中，修改arguments对象中某个索引属性的值，和这个属性对应的形参变量的值也会同时变化，反之亦然.这会让JavaScript的代码混淆引擎让代码变得更难读和理解。在严格模式中arguments 对象会以形参变量的拷贝的形式被创建和初始化，因此 arguments 对象的改变不会影响形参。\n3. eval相关的区别\n在严格模式中，eval不会在当前的作用域内创建新的变量。另外，传入eval的字符串参数也会按照严格模式来解析。你需要全面测试来确保没有代码收到影响。另外，如果你并不是为了解决一个非常实际的解决方案中，尽量不要使用eval。\n\n## 严格中立的代码\n迁移严格代码至严格模式的一个潜在消极面是，在遗留的老版本浏览器上，由于没有实现严格模式，javascript语义可能会有所不同。在一些罕见的机会下（比如差劲的关联关系或者代码最小化），你的代码可能不能按照你书写或者测试里的模式那样运行。这里有一些让你的代码保持中立的规范：\n1. 按照严格模式书写你的代码，并且确保你的代码不会发生仅仅在严格模式下发生的错误（比如上文所说的运行时错误）。\n2. 原理语义的歧义：\n * eval: 仅仅在你知道你在干什么的情况下使用它\n * arguments: 总是通过他们的名字访问函数的参数，或者作为参数对象的拷贝来使用: `var args = Array.prototype.slice.call(arguments)`，并且这样的代码应该在你的函数第一行\n * this: 只在它指向你之前创建的对象的情况下使用 this  \n\n>摘自：[MDN-严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)\n>摘自：[MDN-向严格模式过渡](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode)\n","source":"_posts/严格模式-2016-01-21.md","raw":"title: 严格模式\ndate: 2016-01-21 13:55:51\ntags:\n- jQuery\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n# 概述\nECMAScript 5 的严格模式是JavaScript中的一种限制性更强的变种方式。严格模式不是一个子集：它在语义上与正常代码有着明显的差异。不支持严格模式的浏览器与同支持严格模式的浏览器行为上也不一样， 所以不要在未经严格模式特性测试情况下使用严格模式。严格模式可以与非严格模式共存，所以脚本可以逐渐的选择性加入严格模式。\n严格模式在语义上与正常的JavaScript有一些不同。\n* 首先，严格模式会将JavaScript陷阱直接变成明显的错误。\n* 其次，严格模式修正了一些引擎难以优化的错误：同样的代码有些时候严格模式会比非严格模式下更快。\n* 第三，严格模式禁用了一些有可能在未来版本中定义的语法。\n<!--more-->\n# 开启严格模式\n严格模式可以应用到整个script标签或某个别函数中。不要在封闭大括弧（ {} ）内这样做，在这样的上下文中这么做是没有效果的。\n## 为某个script标签开启严格模式\n为整个script标签开启严格模式, 需要在所有语句之前放一个特定语句 `\"use strict\";` （或 `'use strict';`）。\n      // 整个语句都开启严格模式的语法\n      \"use strict\";\n      var v = \"Hi!  I'm a strict mode script!\";\n这种语法存在陷阱，在代码上线前会进行压缩，如果用这种语法，一个js文件是严格模式的脚本另一个是非严格模式的脚本，压缩后合二为一，合并后的脚本代码可能会失去严格模式以正常模式展现。\n>将`\"use strict\"`放在脚本文件的第一行，则整个脚本都将以\"严格模式\"运行。如果这行语句不在第一行，则无效，整个脚本以\"正常模式\"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。\n>\n      ;//有这个分号 就是正常模式，没有这个分号就是严格模式\n      \"use strict\";\n      eval(\"var x; delete x;\"); // !!! 语法错误\n\n## 为某个函数开启严格模式\n      function strict() {\n        // 函数级别严格模式语法\n        'use strict';\n        function nested() {\n          return \"And so am I!\";\n        }\n        return \"Hi!  I'm a strict mode function!  \" + nested();\n      }\n# 严格模式有哪些不同？\n* 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;(将问题直接转化为错误,如语法错误或运行时错误)。\n* 提高编译器效率，增加运行速度。\n* 消除代码运行的一些不安全之处，保证代码运行的安全。\n* 为未来新版本的Javascript做好铺垫。\n\n# 代码在严格模式下受到的限制\n## 全局变量显式声明\n在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n\n      \"use strict\";\n      mistypedVaraible = 17; // 报错，mistypedVaraible未声明\n## 静态绑定\nJavascript语言的一个特点，就是允许\"动态绑定\"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。\n具体来说，涉及以下几个方面。\n### 禁止使用with语句\n因为with语句无法在编译时就确定，属性到底归属哪个对象。\n\n    \"use strict\";\n    var x = 17;\n    with (obj) // !!! 语法错误\n    {\n      // 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？\n      // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\n      x;\n    }\n### 创设eval作用域\n正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。\n严格模式创设了第三种作用域：eval作用域。\n正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。\n严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。\n\n    \"use strict\";\n    eval(\"var testvar = 10\");\n    console.log(testvar);//在严格模式下报错，在非严格模式下 打印 10\n## 禁止删除变量\n严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。\n\n    \"use strict\";\n    var x;\n    delete x; // 语法错误\n\n    eval(\"var x; delete x;\"); // !!! 语法错误\n\n    var o = Object.create(null, {'x': {\n        value: 1,\n        configurable: true\n    }});\n    delete o.x; // 删除成功\n## 增强的安全措施\n### 禁止this关键字指向全局对象，默认值undefined\n\n    function f(){\n    　　return !this;\n    }\n    // 返回false，因为\"this\"指向全局对象，\"!this\"就是false\n    function f(){\n    　　\"use strict\";\n    　　return !this;\n    }\n    // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\n### 禁止在函数内部遍历调用栈\n    function f1() {　　　　\n        \"use strict\";　　　　\n        f1.caller; // 报错 正常模式下f1.caller是最后一个调用f1的函数\n        f1.arguments; // 报错\n        　　\n    }　　\n    f1();\n### 显式报错\nNaN 是一个不可写的全局变量. 在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常\n\n    \"use strict\";\n    NaN = 2;//报错\n正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.defineProperty(o, \"v\", {\n        value: 1,\n        writable: false\n    });　　\n    o.v = 2; // 报错\n严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。\n\n    \"use strict\";\n    　\n    var o = {\n        　get v() {return 1; }　　\n    };　　\n    o.v = 2; // 报错\n严格模式下，对禁止扩展的对象添加新属性，会报错。\n\n    \"use strict\";　　\n    var o = {};　　\n    Object.preventExtensions(o);　　\n    o.v = 1; // 报错\n严格模式下，删除一个不可删除的属性，会报错。\n\n    \"use strict\";　　\n    delete Object.prototype; // 报错\n## 重名错误\n### 对象不能有重名的属性\n正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    var o = {　　　　\n        p: 1,\n        　　　　p: 2　　\n    }; // 语法错误\n### 函数不能有重名的参数\n正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。\n\n    \"use strict\";　　\n    function f(a, a, b) { // 语法错误\n        　　　　\n        return;　　\n    }\n## 禁止八进制表示法\n正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。\n\n    \"use strict\";　　\n    var n = 0100; // 语法错误\n## eval和arguments对象的限制\n### 赋值和绑定\n首先, 名称 eval 和 arguments 不能通过程序语法被绑定(be bound)或赋值，以下这些尝试都将报错：\n\n    \"use strict\";\n    eval = 17;\n    arguments++;\n    ++eval;\n    var obj = { set p(arguments) { } };\n    var eval;\n    try { } catch (arguments) { }\n    function x(eval) { }\n    function arguments() { }\n    var y = function eval() { };\n    var f = new Function(\"arguments\", \"'use strict'; return 17;\");\n### arguments不再追踪参数的变化\n\n    function f(a) {　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 正常模式为[2,2]\n    　　\n    function f(a) {　　　　\n        \"use strict\";　　　　\n        a = 2;　　　　\n        return [a, arguments[0]];　　\n    }　　\n    f(1); // 严格模式为[2,1]\n### 禁止使用arguments.callee\n这意味着，你无法在匿名函数内部调用自身了，可以用命名函数表达式解决这个问题。\n\n    \"use strict\";　　\n    var f = function() {\n        return arguments.callee;\n    };　　\n    f(); // 报错\n## 函数必须声明在顶层\n将来Javascript的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n\n    \"use strict\";　　\n    if (true) {　　　　\n        function f() {} // 语法错误\n            　　\n    }　　\n    for (var i = 0; i < 5; i++) {　　　　\n        function f2() {} // 语法错误\n            　　\n    }\n\n## 保留字\n为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n使用这些词作为变量名将会报错。此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。\n\n# 向严格模式过度\n## 逐步过渡\n严格模式被仔细设计过，因此可以逐渐地进行迁移。你可以分别改变各个文件，甚至以函数级的粒度迁移至严格模式。\n## 过程\n如果代码中使用\"use strict\"开启了严格模式,则下面的情况都会在脚本运行之前抛出`SyntaxError`异常:\n### 语法错误\n\n* 八进制语法:var n = 023和var s = \"\\047\"\n* with语句\n* 使用delete删除一个变量名(而不是属性名):delete myVariable\n* 使用eval或arguments作为变量名或函数名\n* 使用未来保留字(也许会在ECMAScript 6中使用):implements, interface, let, package, private, protected, public, static,和yield作为变量名或函数名\n* 在语句块中使用函数声明:if(a<b){ function f(){} }\n* 其他错误:\n* * 对象子面量中使用两个相同的属性名:{a: 1, b: 3, a: 7}\n* * 函数形参中使用两个相同的参数名:function f(a, b, b){}\n\n这些错误是有利的，因为可以揭示简陋的错误和坏的实践，这些错误会在代码运行前被抛出。\n\n### 运行时错误\nJavaScript曾经会在一些上下文的某些情况中静默的失败，严格模式会在这些情况下抛出错误。如果你的代码包含这样的场景，请务必测试以确保没有代码受到影响。再说一次，严格模式是可以设置在代码粒度下的。\n\n1. 给一个未声明的变量赋值\n2. 改变一个全局对象的值可能会造成不可预期的后果。如果你真的想设置一个全局对象的值，把他作为一个参数并且明确的把它作为一个属性。\n          var global = this; // in the top-level context, \"this\" always refers the global object\n          function f() {\n              \"use strict\";\n              var a = 12;\n              global.b = a + x * 35;\n          }\n          f();\n\n3. 尝试删除一个不可配置的属性。\n          \"use strict\";\n          delete Object.prototype; // error!\n   在非严格模式中,这样的代码只会静默失败,这样可能会导致用户误以为删除操作成功了.\n\n4. `arguments`对象和函数属性\n\n在严格模式下,访问`arguments.callee`, `arguments.caller`, `anyFunction.caller`以及`anyFunction.arguments`都会抛出异常.唯一合法的使用应该是在其中命名一个函数并且重用之\n\n### 语义差异\n1. 函数调用中的this\n在普通的函数调用f()中，this的值会指向全局对象。在严格模式中，this的值会指向undefined。当函数通过call和apply调用时，如果传入的thisvalue参数是一个null和undefined除外的原始值(字符串，数字，布尔值)，则this的值会成为那个原始值对应的包装对象，如果thisvalue参数的值是undefined或null，则this的值会指向全局对象。在严格模式中，this的值就是thisvalue参数的值，没有任何类型转换。\n2. arguments对象属性不与对应的形参变量同步更新\n在非严格模式中，修改arguments对象中某个索引属性的值，和这个属性对应的形参变量的值也会同时变化，反之亦然.这会让JavaScript的代码混淆引擎让代码变得更难读和理解。在严格模式中arguments 对象会以形参变量的拷贝的形式被创建和初始化，因此 arguments 对象的改变不会影响形参。\n3. eval相关的区别\n在严格模式中，eval不会在当前的作用域内创建新的变量。另外，传入eval的字符串参数也会按照严格模式来解析。你需要全面测试来确保没有代码收到影响。另外，如果你并不是为了解决一个非常实际的解决方案中，尽量不要使用eval。\n\n## 严格中立的代码\n迁移严格代码至严格模式的一个潜在消极面是，在遗留的老版本浏览器上，由于没有实现严格模式，javascript语义可能会有所不同。在一些罕见的机会下（比如差劲的关联关系或者代码最小化），你的代码可能不能按照你书写或者测试里的模式那样运行。这里有一些让你的代码保持中立的规范：\n1. 按照严格模式书写你的代码，并且确保你的代码不会发生仅仅在严格模式下发生的错误（比如上文所说的运行时错误）。\n2. 原理语义的歧义：\n * eval: 仅仅在你知道你在干什么的情况下使用它\n * arguments: 总是通过他们的名字访问函数的参数，或者作为参数对象的拷贝来使用: `var args = Array.prototype.slice.call(arguments)`，并且这样的代码应该在你的函数第一行\n * this: 只在它指向你之前创建的对象的情况下使用 this  \n\n>摘自：[MDN-严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)\n>摘自：[MDN-向严格模式过渡](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode)\n","slug":"严格模式","published":1,"updated":"2016-01-21T10:34:24.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhxz000dn83vvrp0l943"},{"title":"webkit的预加载扫描器","date":"2016-01-19T12:33:09.000Z","comments":1,"_content":"在WebKit中，预加载扫描器指的是一个副解析器，当HTML主解析器被一个同步的script标签阻塞时，预加载扫描器就会启动.然后，它会马上找出接下来即将需要获取的资源(比如样式表，脚本，图片等资源)的URL，然后尽可能早的发起网络请求，而不用等到主解析器恢复运行，从而提高了整体的加载时间。那么，除了HTML文件中的依赖资源，还有样式表中的呢?幸运的是，WebKit已经有了一个叫CSS预加载扫描器的东西了。\n<!--more-->\n在WebKit实现符合HTML5标准的解析器的时候，预加载扫描器被分成了两部分。其中大部分代码分出来成为了HTML预加载扫描器，剩下的一小部分成为了独立的CSS预加载扫描器。CSS预加载扫描器的任务是扫描并尽早加载样式表(且只能是style标签中内联的样式表)中的外部资源。目前，它只能扫描到@import规则中用到的外部资源。\n\n让我们看看下面这个示例，在这个代码片段中(只为演示使用，代码并不符合最佳实践)，有一个script标签和一个style标签:\n\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <script>\n    setTimeout(function () {\n        document.title = document.title\n    }， 1000);\n    </script>\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <style>\n    @import url(\"another-style.css\");\n    body {\n        background-color: white\n    }\n    </style>\n\n当执行到那个同步的script标签时，WebKit解析器会就会启动CSS预加载扫描器.预加载扫描器会快速的找到@import后面的URL，然后下载这个another-style.css文件。\n\nCSS预加载扫描器是非常简单的，因为它不需要解析所有的CSS语法，其中还有一个专门的代码优化，就是如果发现没有@import，扫描器会尽快跳出这个样式表，这样就能在CSS文件很大的时候节约对CPU的消耗。\n\n很多人不推荐使用@import(比如Steve Souder的不要使用@import一文)。随着现在以及未来对浏览器引擎的不断改进，这条最佳实践应该时不时的被重新考量了。当然，我并不推荐在你的网站上到处乱用@import.使用一些调试工具来分析页面的网络性能，然后你就能得出一个明智的决定。\n\n**注:**特别感谢Google的Ilya Grigorik帮我审查这篇文章。\n\n引自：[紫云飞](http://www.cnblogs.com/ziyunfei/archive/2013/04/11/3014430.html?utm_source=tuicool&utm_medium=referral)\n","source":"_posts/webkit的预加载扫描器-2016-01-19.md","raw":"title: webkit的预加载扫描器\ndate: 2016-01-19 20:33:09\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n在WebKit中，预加载扫描器指的是一个副解析器，当HTML主解析器被一个同步的script标签阻塞时，预加载扫描器就会启动.然后，它会马上找出接下来即将需要获取的资源(比如样式表，脚本，图片等资源)的URL，然后尽可能早的发起网络请求，而不用等到主解析器恢复运行，从而提高了整体的加载时间。那么，除了HTML文件中的依赖资源，还有样式表中的呢?幸运的是，WebKit已经有了一个叫CSS预加载扫描器的东西了。\n<!--more-->\n在WebKit实现符合HTML5标准的解析器的时候，预加载扫描器被分成了两部分。其中大部分代码分出来成为了HTML预加载扫描器，剩下的一小部分成为了独立的CSS预加载扫描器。CSS预加载扫描器的任务是扫描并尽早加载样式表(且只能是style标签中内联的样式表)中的外部资源。目前，它只能扫描到@import规则中用到的外部资源。\n\n让我们看看下面这个示例，在这个代码片段中(只为演示使用，代码并不符合最佳实践)，有一个script标签和一个style标签:\n\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <script>\n    setTimeout(function () {\n        document.title = document.title\n    }， 1000);\n    </script>\n    <p>The quick brown fox jumps over the lazy dog.</p>\n    <style>\n    @import url(\"another-style.css\");\n    body {\n        background-color: white\n    }\n    </style>\n\n当执行到那个同步的script标签时，WebKit解析器会就会启动CSS预加载扫描器.预加载扫描器会快速的找到@import后面的URL，然后下载这个another-style.css文件。\n\nCSS预加载扫描器是非常简单的，因为它不需要解析所有的CSS语法，其中还有一个专门的代码优化，就是如果发现没有@import，扫描器会尽快跳出这个样式表，这样就能在CSS文件很大的时候节约对CPU的消耗。\n\n很多人不推荐使用@import(比如Steve Souder的不要使用@import一文)。随着现在以及未来对浏览器引擎的不断改进，这条最佳实践应该时不时的被重新考量了。当然，我并不推荐在你的网站上到处乱用@import.使用一些调试工具来分析页面的网络性能，然后你就能得出一个明智的决定。\n\n**注:**特别感谢Google的Ilya Grigorik帮我审查这篇文章。\n\n引自：[紫云飞](http://www.cnblogs.com/ziyunfei/archive/2013/04/11/3014430.html?utm_source=tuicool&utm_medium=referral)\n","slug":"webkit的预加载扫描器","published":1,"updated":"2016-01-19T13:00:03.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhy3000hn83v5khk0odp"},{"title":"javascript:void(0);到底是什么鬼?","date":"2016-01-29T07:03:57.000Z","comments":1,"_content":"## 疑问？\n我们经常看见`<a href=\"javascript:void(0);\">超链接</a>`的`href`里填写`javascript:void(0);`，取消点击跳转，可是为啥这么搞？\n<!--more-->\n## 规范是这么说的\n> The void Operator\n> \n> The production UnaryExpression : void UnaryExpression is evaluated as follows:\n \n> * Let expr be the result of evaluating UnaryExpression.\n> * Call GetValue(expr).\n> * Return undefined.\n> NOTE: GetValue must be called even though its value is not used because it may have observable side-effects\n\n搬译一下：\n\n> void操作符\n\n> 产生式 UnaryExpression : void UnaryExpression 按如下流程解释:\n\n> * 令 expr 为解释执行UnaryExpression的结果。\n> * 调用 GetValue(expr).\n> * 返回 undefined.\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n重点在于：无论void后的表达式是什么，void操作符都会返回undefined。\n\n## 用处\n### 替换`undefined`\n\n因为undefined在javascript中不是保留字。换言之，你可以写出：\n\n    {% codeblock lang:javascript %}\n    function joke() {\n        var undefined = \"hello world\";\n        console.log(undefined); //会输出\"hello world\"\n    }\n    joke()\n    {% endcodeblock %}\n对的，你可以在一个函数上下文内以undefined做为变量名，于是在这个上下文写的代码便只能通过从全局作用域来取到undefined，如：\n    \n    {% codeblock lang:javascript %}\n    window.undefined //浏览器环境\n    GLOBAL.undefined //Node环境\n    {% endcodeblock %}\n    \n但要注意的是，即便window, GLOBAL仍然可以在函数上下文被定义，故从window/GLOBAL上取undefined并不是100%可靠的做法。如：\n\n    {% codeblock lang:javascript %}\n    function x() {\n       var undefined = 'hello world',\n           f = {},\n           window = {\n               'undefined': 'joke'\n           };\n       console.log(undefined);// hello world\n       console.log(window.undefined); //joke\n       console.log(f.a === undefined); //false\n       console.log(f.a === void 0); //true\n    }\n    x();\n    {% endcodeblock %}\n\n于是，采用void方式获取undefined便成了通用准则。如underscore.js里的isUndefined便是这么写的：\n\n    {% codeblock lang:javascript %}\n    _.isUndefined = function(obj) {\n        return obj === void 0;\n    }\n    {% endcodeblock %}\n    \n除了采用void能保证取到undefined值以外，还有其它方法吗？有的，还有一种方式是通过函数调用。如AngularJS的源码里就用这样的方式：\n    \n    {% codeblock lang:javascript %}\n    (function(window, document, undefined) {\n        //.....\n    })(window, document);\n    {% endcodeblock %}\n\n通过不传参数，确保了undefined参数的值是一个undefined。\n\n### 填充a标签href、image标签的src\n\n* `<a href=\"javascript:void(0)\">test</a>`\n* `<image src=\"javascript:void(0)\">` \n\n## GetValue 是什么鬼？\n\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n(关于js中void，既然返回永远是undefined，那么GetValue有啥用？)[https://www.zhihu.com/question/22210634]\n\n    {% codeblock lang:javascript %}\n    var happiness = 10;\n    var girl = {\n        get whenMarry() {\n            happiness--;\n            return 1/0; //Infinity\n        },\n        get happiness() {\n            return happiness;\n        }\n    };\n    \n    console.log(girl.whenMarry); //调用了whenMarry的get方法\n    console.log(girl.happiness); // 9\n    \n    void girl.whenMarry; //调用了whenMarry的get方法\n    console.log(girl.happiness); // 8\n    \n    delete girl.whenMarry; //没有调用whenMarry的get方法\n    console.log(girl.happiness); //还是8\n    {% endcodeblock %}\n    \n上述代码定义了一个大龄文艺女青年，每被问到什么时候结婚呀(whenMarry)，happiness都会减1。从执行情况可以看出，无论是普通访问girl.whenMarry，还是void girl.whenMarry都会使她的happiness--。而如果把void换成delete操作符写成delete girl.whenMarry，她的happiness就不会减了，因为delete操作符不会对girl.whenMarry求值。\n\n## 总结\nvoid(0) 有如下作用：\n\n* 通过采用void 0取undefined比采用字面上的undefined更靠谱更安全，应该优先采用void 0这种方式。\n* 填充<a>的href确保点击时不会产生页面跳转; 填充<image>的src，确保不会向服务器发出垃圾请求。\n\n转自：[谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)","source":"_posts/void-0-2016-01-29.md","raw":"title: javascript:void(0);到底是什么鬼?\ndate: 2016-01-29 15:03:57\ntags:\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n## 疑问？\n我们经常看见`<a href=\"javascript:void(0);\">超链接</a>`的`href`里填写`javascript:void(0);`，取消点击跳转，可是为啥这么搞？\n<!--more-->\n## 规范是这么说的\n> The void Operator\n> \n> The production UnaryExpression : void UnaryExpression is evaluated as follows:\n \n> * Let expr be the result of evaluating UnaryExpression.\n> * Call GetValue(expr).\n> * Return undefined.\n> NOTE: GetValue must be called even though its value is not used because it may have observable side-effects\n\n搬译一下：\n\n> void操作符\n\n> 产生式 UnaryExpression : void UnaryExpression 按如下流程解释:\n\n> * 令 expr 为解释执行UnaryExpression的结果。\n> * 调用 GetValue(expr).\n> * 返回 undefined.\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n重点在于：无论void后的表达式是什么，void操作符都会返回undefined。\n\n## 用处\n### 替换`undefined`\n\n因为undefined在javascript中不是保留字。换言之，你可以写出：\n\n    {% codeblock lang:javascript %}\n    function joke() {\n        var undefined = \"hello world\";\n        console.log(undefined); //会输出\"hello world\"\n    }\n    joke()\n    {% endcodeblock %}\n对的，你可以在一个函数上下文内以undefined做为变量名，于是在这个上下文写的代码便只能通过从全局作用域来取到undefined，如：\n    \n    {% codeblock lang:javascript %}\n    window.undefined //浏览器环境\n    GLOBAL.undefined //Node环境\n    {% endcodeblock %}\n    \n但要注意的是，即便window, GLOBAL仍然可以在函数上下文被定义，故从window/GLOBAL上取undefined并不是100%可靠的做法。如：\n\n    {% codeblock lang:javascript %}\n    function x() {\n       var undefined = 'hello world',\n           f = {},\n           window = {\n               'undefined': 'joke'\n           };\n       console.log(undefined);// hello world\n       console.log(window.undefined); //joke\n       console.log(f.a === undefined); //false\n       console.log(f.a === void 0); //true\n    }\n    x();\n    {% endcodeblock %}\n\n于是，采用void方式获取undefined便成了通用准则。如underscore.js里的isUndefined便是这么写的：\n\n    {% codeblock lang:javascript %}\n    _.isUndefined = function(obj) {\n        return obj === void 0;\n    }\n    {% endcodeblock %}\n    \n除了采用void能保证取到undefined值以外，还有其它方法吗？有的，还有一种方式是通过函数调用。如AngularJS的源码里就用这样的方式：\n    \n    {% codeblock lang:javascript %}\n    (function(window, document, undefined) {\n        //.....\n    })(window, document);\n    {% endcodeblock %}\n\n通过不传参数，确保了undefined参数的值是一个undefined。\n\n### 填充a标签href、image标签的src\n\n* `<a href=\"javascript:void(0)\">test</a>`\n* `<image src=\"javascript:void(0)\">` \n\n## GetValue 是什么鬼？\n\n> 注意：GetValue一定要调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。\n\n(关于js中void，既然返回永远是undefined，那么GetValue有啥用？)[https://www.zhihu.com/question/22210634]\n\n    {% codeblock lang:javascript %}\n    var happiness = 10;\n    var girl = {\n        get whenMarry() {\n            happiness--;\n            return 1/0; //Infinity\n        },\n        get happiness() {\n            return happiness;\n        }\n    };\n    \n    console.log(girl.whenMarry); //调用了whenMarry的get方法\n    console.log(girl.happiness); // 9\n    \n    void girl.whenMarry; //调用了whenMarry的get方法\n    console.log(girl.happiness); // 8\n    \n    delete girl.whenMarry; //没有调用whenMarry的get方法\n    console.log(girl.happiness); //还是8\n    {% endcodeblock %}\n    \n上述代码定义了一个大龄文艺女青年，每被问到什么时候结婚呀(whenMarry)，happiness都会减1。从执行情况可以看出，无论是普通访问girl.whenMarry，还是void girl.whenMarry都会使她的happiness--。而如果把void换成delete操作符写成delete girl.whenMarry，她的happiness就不会减了，因为delete操作符不会对girl.whenMarry求值。\n\n## 总结\nvoid(0) 有如下作用：\n\n* 通过采用void 0取undefined比采用字面上的undefined更靠谱更安全，应该优先采用void 0这种方式。\n* 填充<a>的href确保点击时不会产生页面跳转; 填充<image>的src，确保不会向服务器发出垃圾请求。\n\n转自：[谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)","slug":"void-0","published":1,"updated":"2016-01-29T07:40:34.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhy7000kn83vvnq6v9fm"},{"title":"Hello World","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"title: Hello World\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2016-01-05T05:52:44.000Z","updated":"2016-01-05T05:52:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijzdrhya000nn83veo0dmoiw"},{"title":"ECMAScrip中的对象存取器:getter和setter","date":"2016-01-21T09:34:17.000Z","comments":1,"_content":"显然这是一个无关IE（高级IE除外）的话题，尽管如此，有兴趣的同学还是一起来认识一下ECMAScript5标准中getter和setter的实现。在一个对象中，操作其中的属性或方法，通常运用最多的就是读（引用）和写了，譬如说o.get，这就是一个读的操作，而o.set = 1则是一个写的操作。事实上在除ie外最新主流浏览器的实现中，任何一个对象的键值都可以被getter和setter方法所取代，这被称之为“存取器属性”。\n<!--more-->\n毫无疑问，getter负责查询值，它不带任何参数，setter则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的return都是无效的。和普通属性不同的是，存储器属性在只声明了get或set时，对于读和写是两者不可兼得的，当它只拥有了getter方法，那么它仅仅只读，同样的，当它只有setter方法，那么您读到的永远都是undefined。如何声明对象存储器属性呢？ 最快捷的途径就是利用对象字面量的语法来写了，请看下述一段代码：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            return 'man';\n        }\n    };\n    //显然这是不允许的，因为贤心并不希望外界去改变他是男性的事实，所以对于sex只设置了只读功能\n    oo.sex = 'woman';//在严格模式下报错。\n    console.log(oo.sex); //结果依然是man\n有意思的是，这颠覆了我们以往的理解，就是在方法定义时并未用function关键字。事实上这里的get或set，你可以理解为两种不同状态下的function：包容的一面（写），安全的一面（读），当一种整体被肢解为不同的形态，意味着我们可能不再需要在表现形式上遵循传统，所以我们并没有使用冒号将键和值分开。那么，继续上面的例子。你将如何在存储器属性的基础上变得读写兼备呢，也许下面的一段会给你带来答案：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            if(this.sexx){\n                return this.sexx;\n            }else{\n                return 'man';\n            }\n        }, set sex(val){\n            this.sexx = val;\n        }\n    };\n    //噢，他如此包容，乃至于人们改变他的性别，他也接受\n    oo.sex = 'woman';\n    console.log(oo.sex); //结果woman\n\n或许你会觉得这是多此一举的，因为我们完全可以忽视get和set，直接让sex方法具备两种权限。 但之所以我们将get和set单独拿出来，是为了更加清晰地理解ECMAScript5对javascript对象键值操作中，一个更为严谨的诠释。 当然，在IE污染的中国，新型的主流技术总是显得格格不入，在实际的项目开发中，也许你永远不会用到get和set，但谁又能保证以后不会呢……\n\n摘自：[贤心博客](http://sentsin.com/web/20.html)\n","source":"_posts/ECMAScrip中的对象存取器-getter和setter-2016-01-21.md","raw":"title: 'ECMAScrip中的对象存取器:getter和setter'\ndate: 2016-01-21 17:34:17\ntags:\n- JavaScript\ncomments: true\n---\n显然这是一个无关IE（高级IE除外）的话题，尽管如此，有兴趣的同学还是一起来认识一下ECMAScript5标准中getter和setter的实现。在一个对象中，操作其中的属性或方法，通常运用最多的就是读（引用）和写了，譬如说o.get，这就是一个读的操作，而o.set = 1则是一个写的操作。事实上在除ie外最新主流浏览器的实现中，任何一个对象的键值都可以被getter和setter方法所取代，这被称之为“存取器属性”。\n<!--more-->\n毫无疑问，getter负责查询值，它不带任何参数，setter则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的return都是无效的。和普通属性不同的是，存储器属性在只声明了get或set时，对于读和写是两者不可兼得的，当它只拥有了getter方法，那么它仅仅只读，同样的，当它只有setter方法，那么您读到的永远都是undefined。如何声明对象存储器属性呢？ 最快捷的途径就是利用对象字面量的语法来写了，请看下述一段代码：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            return 'man';\n        }\n    };\n    //显然这是不允许的，因为贤心并不希望外界去改变他是男性的事实，所以对于sex只设置了只读功能\n    oo.sex = 'woman';//在严格模式下报错。\n    console.log(oo.sex); //结果依然是man\n有意思的是，这颠覆了我们以往的理解，就是在方法定义时并未用function关键字。事实上这里的get或set，你可以理解为两种不同状态下的function：包容的一面（写），安全的一面（读），当一种整体被肢解为不同的形态，意味着我们可能不再需要在表现形式上遵循传统，所以我们并没有使用冒号将键和值分开。那么，继续上面的例子。你将如何在存储器属性的基础上变得读写兼备呢，也许下面的一段会给你带来答案：\n\n    var oo = {\n        name : '贤心',\n        get sex(){\n            if(this.sexx){\n                return this.sexx;\n            }else{\n                return 'man';\n            }\n        }, set sex(val){\n            this.sexx = val;\n        }\n    };\n    //噢，他如此包容，乃至于人们改变他的性别，他也接受\n    oo.sex = 'woman';\n    console.log(oo.sex); //结果woman\n\n或许你会觉得这是多此一举的，因为我们完全可以忽视get和set，直接让sex方法具备两种权限。 但之所以我们将get和set单独拿出来，是为了更加清晰地理解ECMAScript5对javascript对象键值操作中，一个更为严谨的诠释。 当然，在IE污染的中国，新型的主流技术总是显得格格不入，在实际的项目开发中，也许你永远不会用到get和set，但谁又能保证以后不会呢……\n\n摘自：[贤心博客](http://sentsin.com/web/20.html)\n","slug":"ECMAScrip中的对象存取器-getter和setter","published":1,"updated":"2016-01-21T09:37:50.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhyc000on83v1hlgdbor"},{"title":"onload vs DOMContentLoaded","date":"2016-01-08T02:27:11.000Z","comments":1,"_content":"* `$(document).ready(function () { });`\n* `$(function () { });`\n\n以上两行代码的目的和效果都一样———待DOM加载完成之后，执行传入的function函数。\n\n这是我们在页面初始化时经常使用的监听方案，那么他的实际的执行关系时什么样的呢？\n在原生js中是什么样的一种表现？\n<!--more-->\n## 定义\n+ onload:\n当onload事件触发的时候，页面上的所有dom，样式表，脚本，图片，flash，iframe都已经加载完成了。\n+ DOMContentLoaded:\n当DOMContentLoaded事件触发时，仅当dom加载完成，不包括样式表，图片，flash，iframe\n\n光看定义，一目了然，哪个比较适合作为我们判断的标准：图片啊什么的，我们完全可以不用等。\n\n在某些Gecko和Webkit引擎版本的浏览器里面，包括IE8在内，会同时发起多个http的请求并行加载样式表和脚步，但是脚本会等样式表加载完成之后才会被执行，甚至样式表加载之前页面都不会渲染。opera不会，样式表未加载好就可以执行js。\n\n{% asset_img onLoadVSDomContentLoaded.png %}\n\n### 兼容方案\n#### ie8及以下兼容处理方案\nie的一般处理方案 --- `onreadystatechange` 事件。\nhtml加载过程中会有一个document.readyState状态\n五种状态：\n+ 0（未初始化）：还没有send\n+ 1 loading（载入）：正在发送请求\n+ 2 loaded（载入完成）：执行完成，已经接收到全部响应内容\n+ 3 interactive（交互）： 正在解析响应内容\n+ 4 complete（完成）： 响应内容解析完成，客户端可以用了。\n*complete事件和window.onload事件是同时的。*\n\n这就是要监听页面的readystatechange事件，当事件为interactive或者complete时就可以开始做js的事情了。\ndocument.readyState 状态\n如果我们注册 ready 函数的时间点太晚了，页面已经加载完成之后，我们才注册自己的 ready 函数，那就用不着上面的层层检查了，直接看看当前页面的 readyState 就可以了，如果已经是 complete ，那就可以直接执行我们准备注册的 ready 函数了。不过 ChrisS 报告了一个很特别的错误情况，我们需要延迟一下执行。\n>\nsetTimeout 经常被用来做网页上的定时器，允许为它指定一个毫秒数作为间隔执行的时间。当被启动的程序需要在非常短的时间内运行，我们就会给它指定一个很小的时间数，或者需要马上执行的话，我们甚至把这个毫秒数设置为0，但事实上，setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的毫秒数设置为0，被调用的程序也没有马上启动。这个最小的时间间隔是多少呢？这和浏览器及操作系统有关。在John Resig的新书《Javascript忍者的秘密》一书中提到。\n>>Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。\n\n既然规范都是这样写的，那看来使用setTimeout是没办法再把这个最小时间间隔缩短了。这样，通过设置为 1, 我们可以让程序在浏览器支持的最小时间间隔之后执行了。\n\n    if (document.readyState === \"complete\") {\n        // 延迟 1 毫秒之后，执行 ready 函数\n        setTimeout(jQuery.ready, 1);\n    }\n\n#### doScroll 检测法\n但是当页面中带有iframe时，这个readyState状态会挂起一直等待，等待页面的iframe也加载完毕之后再处理，这个过程是我们不想要得，那就有另外一种处理方案。\n>\nMSDN 关于 JScript 的一个方法有段不起眼的话，当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了！\nDiego Perini 在 2007 年的时候，报告了一种检测 IE 是否加载完成的方式，使用 doScroll 方法调用。详细的说明见这里。\n原理是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在本例中每间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。\n\n    (function doScrollCheck() {\n        if (!jQuery.isReady) {  \n            try {\n                // Use the trick by Diego Perini\n                // http://javascript.nwbox.com/IEContentLoaded/\n                top.doScroll(\"left\");\n            } catch (e) {\n                return setTimeout(doScrollCheck, 50);\n            }   \n            // and execute any waiting functions\n            jQuery.ready();\n        }\n    })();\n\n#### jQuery的实现  \n    //全局方法\n    DOMContentLoaded = function() {\n        if ( document.addEventListener ) {\n            document.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n            jQuery.ready();\n        } else if ( document.readyState === \"complete\" ) {\n            // we're here because readyState === \"complete\" in oldIE\n            // which is good enough for us to call the dom ready!\n            document.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n            jQuery.ready();\n        }\n    }\n\n    //入口 jquery实例调用\n    ready: function( fn ) {\n        // Add the callback\n        jQuery.ready.promise().done( fn );\n\n        return this;\n    }\n\n    jQuery.ready.promise = function( obj ) {\n    if ( !readyList ) {\n\n        readyList = jQuery.Deferred();\n\n        // Catch cases where $(document).ready() is called after the browser event has already occurred.\n        // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n        // 当页面加载完了，直接调用ready方法\n        if ( document.readyState === \"complete\" ) {\n            // Handle it asynchronously to allow scripts the opportunity to delay ready\n            setTimeout( jQuery.ready, 1 );\n\n        // Standards-based browsers support DOMContentLoaded\n        } else if ( document.addEventListener ) {\n            // Use the handy event callback\n            document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\n            // A fallback to window.onload, that will always work\n            window.addEventListener( \"load\", jQuery.ready, false );\n\n        // If IE event model is used\n        } else {\n            // Ensure firing before onload, maybe late but safe also for iframes\n            document.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n\n            // A fallback to window.onload, that will always work\n            window.attachEvent( \"onload\", jQuery.ready );\n\n            // If IE and not a frame\n            // continually check to see if the document is ready\n            var top = false;\n\n            try {\n                top = window.frameElement == null && document.documentElement;\n            } catch(e) {}\n\n            if ( top && top.doScroll ) {\n                (function doScrollCheck() {\n                    if ( !jQuery.isReady ) {\n\n                        try {\n                            // Use the trick by Diego Perini\n                            // http://javascript.nwbox.com/IEContentLoaded/\n                            top.doScroll(\"left\");\n                        } catch(e) {\n                            return setTimeout( doScrollCheck, 50 );\n                        }\n\n                        // and execute any waiting functions\n                        jQuery.ready();\n                    }\n                })();\n            }\n        }\n    }\n    return readyList.promise( obj );\n    };\n\n    jQuery.extend({\n        // Is the DOM ready to be used? Set to true once it occurs.\n        isReady: false,\n\n        // A counter to track how many items to wait for before\n        // the ready event fires. See #6781\n        // ready方法执行前需要等待的次数\n        readyWait: 1,\n\n        // Handle when the DOM is ready\n        // 当DOM加载完毕时开始执行ready\n        ready: function( wait ) {\n            // Abort if there are pending holds or we're already ready\n            // 判断页面是否加载完成并且ready方法已经执行\n            // 若传入的参数为true，则--readyWait；否则判断isReady，即ready是否正在执行\n            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n                return;\n            }\n\n            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n            if ( !document.body ) {\n                return setTimeout( jQuery.ready, 1 );\n            }\n\n            // Remember that the DOM is ready\n            jQuery.isReady = true; //指示ready 方法已经被执行\n\n            // If a normal DOM Ready event fired, decrement, and wait if need be\n            // 若readyWait-1后还是大于0，则返回，不执行ready。\n            if ( wait !== true && --jQuery.readyWait > 0 ) {\n                return;\n            }\n\n            // If there are functions bound, to execute\n            readyList.resolveWith( document, [ jQuery ] );\n\n            // Trigger any bound ready events\n            if ( jQuery.fn.trigger ) {\n                // 触发ready方法，然后解除绑定的ready方法。\n                jQuery( document ).trigger(\"ready\").off(\"ready\");\n            }\n        }\n    });\n根据以上代码可见，最终DOMContented事件执行的，其实是jQUery.ready()这个工具函数。\n（注意，jquery.ready()和jquery(document).raedy()不一样！！，前者是工具函数，后者是实例函数。）\n这里是通过定义一个DOMContentLoaded函数作为桥梁来执行jquery.ready()函数的，这样做的目的就是为了及时的remove掉document的DOMContentLoaded事件的引用。\n{% asset_img zongjie.png %}\n推荐好文:  [何控制jquery的ready事件](http://www.xiabingbao.com/jquery/2015/06/27/jquery-holdready/)\n","source":"_posts/DOMContentLoaded-2016-01-08.md","raw":"title: onload vs DOMContentLoaded\ndate: 2016-01-08 10:27:11\ntags:\n- jQuery\n- JavaScript\ncomments: true\ncategories:\n- JavaScript\n---\n* `$(document).ready(function () { });`\n* `$(function () { });`\n\n以上两行代码的目的和效果都一样———待DOM加载完成之后，执行传入的function函数。\n\n这是我们在页面初始化时经常使用的监听方案，那么他的实际的执行关系时什么样的呢？\n在原生js中是什么样的一种表现？\n<!--more-->\n## 定义\n+ onload:\n当onload事件触发的时候，页面上的所有dom，样式表，脚本，图片，flash，iframe都已经加载完成了。\n+ DOMContentLoaded:\n当DOMContentLoaded事件触发时，仅当dom加载完成，不包括样式表，图片，flash，iframe\n\n光看定义，一目了然，哪个比较适合作为我们判断的标准：图片啊什么的，我们完全可以不用等。\n\n在某些Gecko和Webkit引擎版本的浏览器里面，包括IE8在内，会同时发起多个http的请求并行加载样式表和脚步，但是脚本会等样式表加载完成之后才会被执行，甚至样式表加载之前页面都不会渲染。opera不会，样式表未加载好就可以执行js。\n\n{% asset_img onLoadVSDomContentLoaded.png %}\n\n### 兼容方案\n#### ie8及以下兼容处理方案\nie的一般处理方案 --- `onreadystatechange` 事件。\nhtml加载过程中会有一个document.readyState状态\n五种状态：\n+ 0（未初始化）：还没有send\n+ 1 loading（载入）：正在发送请求\n+ 2 loaded（载入完成）：执行完成，已经接收到全部响应内容\n+ 3 interactive（交互）： 正在解析响应内容\n+ 4 complete（完成）： 响应内容解析完成，客户端可以用了。\n*complete事件和window.onload事件是同时的。*\n\n这就是要监听页面的readystatechange事件，当事件为interactive或者complete时就可以开始做js的事情了。\ndocument.readyState 状态\n如果我们注册 ready 函数的时间点太晚了，页面已经加载完成之后，我们才注册自己的 ready 函数，那就用不着上面的层层检查了，直接看看当前页面的 readyState 就可以了，如果已经是 complete ，那就可以直接执行我们准备注册的 ready 函数了。不过 ChrisS 报告了一个很特别的错误情况，我们需要延迟一下执行。\n>\nsetTimeout 经常被用来做网页上的定时器，允许为它指定一个毫秒数作为间隔执行的时间。当被启动的程序需要在非常短的时间内运行，我们就会给它指定一个很小的时间数，或者需要马上执行的话，我们甚至把这个毫秒数设置为0，但事实上，setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的毫秒数设置为0，被调用的程序也没有马上启动。这个最小的时间间隔是多少呢？这和浏览器及操作系统有关。在John Resig的新书《Javascript忍者的秘密》一书中提到。\n>>Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。\n\n既然规范都是这样写的，那看来使用setTimeout是没办法再把这个最小时间间隔缩短了。这样，通过设置为 1, 我们可以让程序在浏览器支持的最小时间间隔之后执行了。\n\n    if (document.readyState === \"complete\") {\n        // 延迟 1 毫秒之后，执行 ready 函数\n        setTimeout(jQuery.ready, 1);\n    }\n\n#### doScroll 检测法\n但是当页面中带有iframe时，这个readyState状态会挂起一直等待，等待页面的iframe也加载完毕之后再处理，这个过程是我们不想要得，那就有另外一种处理方案。\n>\nMSDN 关于 JScript 的一个方法有段不起眼的话，当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了！\nDiego Perini 在 2007 年的时候，报告了一种检测 IE 是否加载完成的方式，使用 doScroll 方法调用。详细的说明见这里。\n原理是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在本例中每间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。\n\n    (function doScrollCheck() {\n        if (!jQuery.isReady) {  \n            try {\n                // Use the trick by Diego Perini\n                // http://javascript.nwbox.com/IEContentLoaded/\n                top.doScroll(\"left\");\n            } catch (e) {\n                return setTimeout(doScrollCheck, 50);\n            }   \n            // and execute any waiting functions\n            jQuery.ready();\n        }\n    })();\n\n#### jQuery的实现  \n    //全局方法\n    DOMContentLoaded = function() {\n        if ( document.addEventListener ) {\n            document.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n            jQuery.ready();\n        } else if ( document.readyState === \"complete\" ) {\n            // we're here because readyState === \"complete\" in oldIE\n            // which is good enough for us to call the dom ready!\n            document.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n            jQuery.ready();\n        }\n    }\n\n    //入口 jquery实例调用\n    ready: function( fn ) {\n        // Add the callback\n        jQuery.ready.promise().done( fn );\n\n        return this;\n    }\n\n    jQuery.ready.promise = function( obj ) {\n    if ( !readyList ) {\n\n        readyList = jQuery.Deferred();\n\n        // Catch cases where $(document).ready() is called after the browser event has already occurred.\n        // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n        // 当页面加载完了，直接调用ready方法\n        if ( document.readyState === \"complete\" ) {\n            // Handle it asynchronously to allow scripts the opportunity to delay ready\n            setTimeout( jQuery.ready, 1 );\n\n        // Standards-based browsers support DOMContentLoaded\n        } else if ( document.addEventListener ) {\n            // Use the handy event callback\n            document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\n            // A fallback to window.onload, that will always work\n            window.addEventListener( \"load\", jQuery.ready, false );\n\n        // If IE event model is used\n        } else {\n            // Ensure firing before onload, maybe late but safe also for iframes\n            document.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n\n            // A fallback to window.onload, that will always work\n            window.attachEvent( \"onload\", jQuery.ready );\n\n            // If IE and not a frame\n            // continually check to see if the document is ready\n            var top = false;\n\n            try {\n                top = window.frameElement == null && document.documentElement;\n            } catch(e) {}\n\n            if ( top && top.doScroll ) {\n                (function doScrollCheck() {\n                    if ( !jQuery.isReady ) {\n\n                        try {\n                            // Use the trick by Diego Perini\n                            // http://javascript.nwbox.com/IEContentLoaded/\n                            top.doScroll(\"left\");\n                        } catch(e) {\n                            return setTimeout( doScrollCheck, 50 );\n                        }\n\n                        // and execute any waiting functions\n                        jQuery.ready();\n                    }\n                })();\n            }\n        }\n    }\n    return readyList.promise( obj );\n    };\n\n    jQuery.extend({\n        // Is the DOM ready to be used? Set to true once it occurs.\n        isReady: false,\n\n        // A counter to track how many items to wait for before\n        // the ready event fires. See #6781\n        // ready方法执行前需要等待的次数\n        readyWait: 1,\n\n        // Handle when the DOM is ready\n        // 当DOM加载完毕时开始执行ready\n        ready: function( wait ) {\n            // Abort if there are pending holds or we're already ready\n            // 判断页面是否加载完成并且ready方法已经执行\n            // 若传入的参数为true，则--readyWait；否则判断isReady，即ready是否正在执行\n            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n                return;\n            }\n\n            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n            if ( !document.body ) {\n                return setTimeout( jQuery.ready, 1 );\n            }\n\n            // Remember that the DOM is ready\n            jQuery.isReady = true; //指示ready 方法已经被执行\n\n            // If a normal DOM Ready event fired, decrement, and wait if need be\n            // 若readyWait-1后还是大于0，则返回，不执行ready。\n            if ( wait !== true && --jQuery.readyWait > 0 ) {\n                return;\n            }\n\n            // If there are functions bound, to execute\n            readyList.resolveWith( document, [ jQuery ] );\n\n            // Trigger any bound ready events\n            if ( jQuery.fn.trigger ) {\n                // 触发ready方法，然后解除绑定的ready方法。\n                jQuery( document ).trigger(\"ready\").off(\"ready\");\n            }\n        }\n    });\n根据以上代码可见，最终DOMContented事件执行的，其实是jQUery.ready()这个工具函数。\n（注意，jquery.ready()和jquery(document).raedy()不一样！！，前者是工具函数，后者是实例函数。）\n这里是通过定义一个DOMContentLoaded函数作为桥梁来执行jquery.ready()函数的，这样做的目的就是为了及时的remove掉document的DOMContentLoaded事件的引用。\n{% asset_img zongjie.png %}\n推荐好文:  [何控制jquery的ready事件](http://www.xiabingbao.com/jquery/2015/06/27/jquery-holdready/)\n","slug":"DOMContentLoaded","published":1,"updated":"2016-01-19T12:59:56.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhyg000qn83v4d42m54t"},{"title":"第三章 基本概念","date":"2016-01-20T01:38:23.000Z","comments":1,"_content":"# 语法\n## 区分大小写\nECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n<!--more-->\n## 标示符\n所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。\n规则：\n* 第一个字符必须是一个字母、下划线`_`或一个美元符号`$`\n* 其他字符可以是字母、下划线、美元符号或数字。标识符中的字母包含扩展的ASCll或Unicode字母字符(如À和Æ);\n\n## 严格模式 `\"use strict;\"`\n\n[严格模式](http://www.yangshengdonghome.com/2016/01/21/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/)\n\n\n## 语句\n\n* 一个语句由一个或多个表达式、关键字或运算符（符号）组成。通常，在一个行上书写一个语句，但可在两个行或多个行上书写一个语句。此外，在同一个行上书写两个或多个语句，用分号分隔。通常，每个新行都开始一个新语句。最好是显式终止您的语句。可使用分号 (;) 做到这一点，分号是 JavaScript 语句的终止字符。\n* 由括号 ({}) 包围的一组 JavaScript 语句称为一个块。组织在一个块中的语句通常可以视为一个语句，比如`var a = function (){};`和对象字面量(`a = {};`)，这两个结尾的也需要加分号，其他的大括号情况(for循环、ifelse判断)，可以不加分号。\n\n         abc={}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n         abc=function(){}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n         if(a==1){}bbc=function(){}// 正常\n         for(var a = 1;a<10;a++){}bbc=function(){}//正常\n\n# 关键字和保留字\n按照规则，关键字也是语言保留的，不能用作标识符。\n\n* 关键字：真正意义上的保留字。\n\n    if分支语句：if, else\n    switch分支语句：switch, case, default, break\n    循环语句：do, while, for, continue\n    异常处理语句：try, catch, finally, throw\n    获取类型：typeof, instanceof\n    布尔值：true, false, null\n    函数相关：var, void, function, return\n    其他：in, this, with, new, delete\n\n* 保留字：结合java、C++等面向对象语言的思路，将来有可能新加入的关键字。\n\n    基本数据类型：byte, char, boolean, int, short, long, float, double, <span style=\"color:green;\">enum</span>\n    继承：<span style=\"color:red;\">implements</span>, <span style=\"color:green;\">extends</span>, <span style=\"color:green;\">super</span>\n    类与接口：<span style=\"color:green;\">class</span>, <span style=\"color:red;\">interface</span>\n    用来修饰函数的关键字：abstract, native, <span style=\"color:red;\">static</span>, final, <span style=\"color:green;\">const</span>, volatile, synchronized\n    导入导出：<span style=\"color:green;\">export</span>, <span style=\"color:green;\">import</span>\n    访问权限：<span style=\"color:red;\">private</span>, <span style=\"color:red;\">protected</span>, <span style=\"color:red;\">public</span>\n    其他：goto, <span style=\"color:red;\">package</span>, throws, transient, debugger, <span style=\"color:red;\">let</span>,  <span style=\"color:red;\">yield</span>,  <span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>\n    <span style=\"color:#ddd;\">注意：红色字体为第5版严格模式下做的限制，<span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>这两个在严格模式下不能做标识符或属性名。</span>\n    <span style=\"color:#ddd;\">注意：第5版把在非严格模式下运行时的保留字减少到绿色字体这几个，但是为了最大的兼容性还是都不要使用了吧。</span>\n\n> **顺便整理下javascript语言中提供的有用的常用的变量和函数**\n> \n数据类型：Number, Boolean, String, undefined, Object, Array, Function, Date, Math, RegExp, Error\n错误类型：EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError\n编码：decodeURI, decodeURIComponent, encodeURI\n转义：escape, unescape\n类型转换：parentInt, parentFloat\n特殊值及判断：isFinite, isNaN, NaN, Infinity\n其他：arguments, eval\n<span style=\"red;\">这些都不是ECMAScript的关键字，undefined不是关键字但是null确实关键字。</span>\n最后注意：我们常用的函数alert()不属于上面的三类。\n\n# 变量\n\n## 声明变量\n\n1. 使用关键词 var，这个语法可以同时用来声明局部(function内部)和全局变量。\n2. 在非严格模式下，无论是在全局范围内还是函数内，使用直接给变量赋值`count = 3`这种语法，会产生一个全部变量count(隐式全局变量)，这种方式不推荐。\n3. <span style=\"color:red;\">无法用var声明块级局部变量</span>。\n\n        // A single declaration.\n        var count;  \n        // Multiple declarations with a single var keyword.\n        var count, amount, level;    \n        // Variable declaration and initialization in one statement.\n        var count = 0, amount = 100;\n        count = 3;//无论实在全局范围内还是函数内，使用这种语法直接给变量赋值，会产生一个全部变量\n如果未在 var 语句中初始化您的变量，它将自动采用 undefined 值，试图访问一个未初始化的变量会导致一个 ReferenceError 异常被抛出\n\n> 隐式全局变量和明确定义的全局变量间有些小的差异，就是通过delete操作符让变量未定义的能力。\n>\n* 通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。\n* 无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。\n> 这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过delete操作符删除的，而变量是不能的：\n>\n        // 定义三个全局变量\n        var global_var = 1;\n        global_novar = 2; // 反面教材\n        (function () {\n           global_fromfunc = 3; // 反面教材\n        }());\n>\n        // 试图删除\n        delete global_var; // false\n        delete global_novar; // true\n        delete global_fromfunc; // true\n>        \n        // 测试该删除\n        typeof global_var; // \"number\"\n        typeof global_novar; // \"undefined\"\n        typeof global_fromfunc; // \"undefined\"\n---\n了解另外两种变量的声明方式：\n>\n    * let：声明块范围局部变量，可选初始化值。\n    * const：声明一个只读命名常量。\n\n## 数据类型\n\nECMAScript是变量松散类型语言(动态数据类型语言)，即每个变量只是一个占位符，其类型并不固定，可以随时变化，这意味着你定义变量时不必指定变量类型，而且变量类型会在脚本执行需要时自动转换。但是，<span style=\"color: red;\">数据本身和各种运算是有类型的</span>。\nECMAScript 中有5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。\n\n### undefined类型\n[好好学学undefined！](http://www.yangshengdonghome.com/2016/01/21/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/)\n\n### null类型\n\nnull类型也只有一个值：null , 表示一个变量中没有包含有效数据，null表示\"没有对象\"。`字面值null`在这里意为`空值`、`空对象`的意思，更确切的说，一个被赋值为null的变量没有保存有效的对象等，可以通过给一个变量赋值为null来清空变量中的内容(不删除变量)。\n\n主要用处：\n\n* 作为函数的参数传递，表示该函数的参数不是对象。\n* 作为对象原型链的终点。\n\n    Object.getPrototypeOf(Object.prototype) // null\n\n产生null的原因只有一个，即对一个变量显式的赋值为null 。\n\n\n\n    var p = null;\n    console.log(p); //null\n    typeof p; // \"object\"\n    typeof null; // \"object\"\n另外，需要注意的是，typeof null 应该返回\"null\"，但实际上返回的是\"object\"，这是一个历史遗留问题，并没有其他原因，不要想太多，曾经有提案 typeof null === 'null'但提案被拒绝。\n> 《javascript高级程序设计3》是这么解释的:从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用typeof 操作符检测null 值时会返回\"object\"的原因。\n\n    判断null值，这个时候就不能用typeOf了，直接用if(xxx === null){}\n    console.log(typeof null) //\"Object\"\n    console.log(null instanceof Object) // false\n    var a = null,b;\n    console.log(a === null) //true\n    console.log(b === null) //false 因为 undefined !== null  三个等号为false\n    console.log(b == null) // true 两个等号为true\n    \n>undefined == null //true [为什么相等？](https://www.w3.org/html/ig/zh/wiki/ES5/expressions#.E7.AD.89.E5.80.BC.E8.BF.90.E7.AE.97.E7.AC.A6)\n\n### Boolean类型\n\nboolean类型只有两个字面值：`true`和`false` 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()。其中转换结果为false的值有(false, \"\", +0, -0, NaN, null, undefined)，其他值(包括空对象、空数组)均将转换为true。\n\n    typeof true; // \"boolean\"\n    \n    typeof false; // \"boolean\"\n    \n    Boolean(new Object()); //true\n    \n    Boolean(undefined); //false\n    \n    Boolean(null); //false\n    \n    Boolean(''); //false\n    \n    Boolean(0); //false\n    \n    Boolean(100); // true\n    \n    Boolean([]) // true\n     \n    Boolean({}) // true\n    \nif判断语句中自动调用Boolean()。\n\n    if (x = y + z){} //将值 y + z 赋给变量 x，然后检查整个表达式的结果（x 的值）是否为 0。\n\n### Number类型\n\n","source":"_posts/3-第三章基本概念-2016-01-20.md","raw":"title: 第三章 基本概念\ndate: 2016-01-20 09:38:23\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n# 语法\n## 区分大小写\nECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n<!--more-->\n## 标示符\n所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。\n规则：\n* 第一个字符必须是一个字母、下划线`_`或一个美元符号`$`\n* 其他字符可以是字母、下划线、美元符号或数字。标识符中的字母包含扩展的ASCll或Unicode字母字符(如À和Æ);\n\n## 严格模式 `\"use strict;\"`\n\n[严格模式](http://www.yangshengdonghome.com/2016/01/21/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/)\n\n\n## 语句\n\n* 一个语句由一个或多个表达式、关键字或运算符（符号）组成。通常，在一个行上书写一个语句，但可在两个行或多个行上书写一个语句。此外，在同一个行上书写两个或多个语句，用分号分隔。通常，每个新行都开始一个新语句。最好是显式终止您的语句。可使用分号 (;) 做到这一点，分号是 JavaScript 语句的终止字符。\n* 由括号 ({}) 包围的一组 JavaScript 语句称为一个块。组织在一个块中的语句通常可以视为一个语句，比如`var a = function (){};`和对象字面量(`a = {};`)，这两个结尾的也需要加分号，其他的大括号情况(for循环、ifelse判断)，可以不加分号。\n\n         abc={}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n         abc=function(){}bbc=function(){}//报错 Uncaught SyntaxError: Unexpected identifier\n         if(a==1){}bbc=function(){}// 正常\n         for(var a = 1;a<10;a++){}bbc=function(){}//正常\n\n# 关键字和保留字\n按照规则，关键字也是语言保留的，不能用作标识符。\n\n* 关键字：真正意义上的保留字。\n\n    if分支语句：if, else\n    switch分支语句：switch, case, default, break\n    循环语句：do, while, for, continue\n    异常处理语句：try, catch, finally, throw\n    获取类型：typeof, instanceof\n    布尔值：true, false, null\n    函数相关：var, void, function, return\n    其他：in, this, with, new, delete\n\n* 保留字：结合java、C++等面向对象语言的思路，将来有可能新加入的关键字。\n\n    基本数据类型：byte, char, boolean, int, short, long, float, double, <span style=\"color:green;\">enum</span>\n    继承：<span style=\"color:red;\">implements</span>, <span style=\"color:green;\">extends</span>, <span style=\"color:green;\">super</span>\n    类与接口：<span style=\"color:green;\">class</span>, <span style=\"color:red;\">interface</span>\n    用来修饰函数的关键字：abstract, native, <span style=\"color:red;\">static</span>, final, <span style=\"color:green;\">const</span>, volatile, synchronized\n    导入导出：<span style=\"color:green;\">export</span>, <span style=\"color:green;\">import</span>\n    访问权限：<span style=\"color:red;\">private</span>, <span style=\"color:red;\">protected</span>, <span style=\"color:red;\">public</span>\n    其他：goto, <span style=\"color:red;\">package</span>, throws, transient, debugger, <span style=\"color:red;\">let</span>,  <span style=\"color:red;\">yield</span>,  <span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>\n    <span style=\"color:#ddd;\">注意：红色字体为第5版严格模式下做的限制，<span style=\"color:red;\">arguments</span>,  <span style=\"color:red;\">eval</span>这两个在严格模式下不能做标识符或属性名。</span>\n    <span style=\"color:#ddd;\">注意：第5版把在非严格模式下运行时的保留字减少到绿色字体这几个，但是为了最大的兼容性还是都不要使用了吧。</span>\n\n> **顺便整理下javascript语言中提供的有用的常用的变量和函数**\n> \n数据类型：Number, Boolean, String, undefined, Object, Array, Function, Date, Math, RegExp, Error\n错误类型：EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError\n编码：decodeURI, decodeURIComponent, encodeURI\n转义：escape, unescape\n类型转换：parentInt, parentFloat\n特殊值及判断：isFinite, isNaN, NaN, Infinity\n其他：arguments, eval\n<span style=\"red;\">这些都不是ECMAScript的关键字，undefined不是关键字但是null确实关键字。</span>\n最后注意：我们常用的函数alert()不属于上面的三类。\n\n# 变量\n\n## 声明变量\n\n1. 使用关键词 var，这个语法可以同时用来声明局部(function内部)和全局变量。\n2. 在非严格模式下，无论是在全局范围内还是函数内，使用直接给变量赋值`count = 3`这种语法，会产生一个全部变量count(隐式全局变量)，这种方式不推荐。\n3. <span style=\"color:red;\">无法用var声明块级局部变量</span>。\n\n        // A single declaration.\n        var count;  \n        // Multiple declarations with a single var keyword.\n        var count, amount, level;    \n        // Variable declaration and initialization in one statement.\n        var count = 0, amount = 100;\n        count = 3;//无论实在全局范围内还是函数内，使用这种语法直接给变量赋值，会产生一个全部变量\n如果未在 var 语句中初始化您的变量，它将自动采用 undefined 值，试图访问一个未初始化的变量会导致一个 ReferenceError 异常被抛出\n\n> 隐式全局变量和明确定义的全局变量间有些小的差异，就是通过delete操作符让变量未定义的能力。\n>\n* 通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。\n* 无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。\n> 这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过delete操作符删除的，而变量是不能的：\n>\n        // 定义三个全局变量\n        var global_var = 1;\n        global_novar = 2; // 反面教材\n        (function () {\n           global_fromfunc = 3; // 反面教材\n        }());\n>\n        // 试图删除\n        delete global_var; // false\n        delete global_novar; // true\n        delete global_fromfunc; // true\n>        \n        // 测试该删除\n        typeof global_var; // \"number\"\n        typeof global_novar; // \"undefined\"\n        typeof global_fromfunc; // \"undefined\"\n---\n了解另外两种变量的声明方式：\n>\n    * let：声明块范围局部变量，可选初始化值。\n    * const：声明一个只读命名常量。\n\n## 数据类型\n\nECMAScript是变量松散类型语言(动态数据类型语言)，即每个变量只是一个占位符，其类型并不固定，可以随时变化，这意味着你定义变量时不必指定变量类型，而且变量类型会在脚本执行需要时自动转换。但是，<span style=\"color: red;\">数据本身和各种运算是有类型的</span>。\nECMAScript 中有5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。\n\n### undefined类型\n[好好学学undefined！](http://www.yangshengdonghome.com/2016/01/21/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/)\n\n### null类型\n\nnull类型也只有一个值：null , 表示一个变量中没有包含有效数据，null表示\"没有对象\"。`字面值null`在这里意为`空值`、`空对象`的意思，更确切的说，一个被赋值为null的变量没有保存有效的对象等，可以通过给一个变量赋值为null来清空变量中的内容(不删除变量)。\n\n主要用处：\n\n* 作为函数的参数传递，表示该函数的参数不是对象。\n* 作为对象原型链的终点。\n\n    Object.getPrototypeOf(Object.prototype) // null\n\n产生null的原因只有一个，即对一个变量显式的赋值为null 。\n\n\n\n    var p = null;\n    console.log(p); //null\n    typeof p; // \"object\"\n    typeof null; // \"object\"\n另外，需要注意的是，typeof null 应该返回\"null\"，但实际上返回的是\"object\"，这是一个历史遗留问题，并没有其他原因，不要想太多，曾经有提案 typeof null === 'null'但提案被拒绝。\n> 《javascript高级程序设计3》是这么解释的:从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用typeof 操作符检测null 值时会返回\"object\"的原因。\n\n    判断null值，这个时候就不能用typeOf了，直接用if(xxx === null){}\n    console.log(typeof null) //\"Object\"\n    console.log(null instanceof Object) // false\n    var a = null,b;\n    console.log(a === null) //true\n    console.log(b === null) //false 因为 undefined !== null  三个等号为false\n    console.log(b == null) // true 两个等号为true\n    \n>undefined == null //true [为什么相等？](https://www.w3.org/html/ig/zh/wiki/ES5/expressions#.E7.AD.89.E5.80.BC.E8.BF.90.E7.AE.97.E7.AC.A6)\n\n### Boolean类型\n\nboolean类型只有两个字面值：`true`和`false` 。 但在Javascript中，所有类型的值都可以转化为与boolean等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()。其中转换结果为false的值有(false, \"\", +0, -0, NaN, null, undefined)，其他值(包括空对象、空数组)均将转换为true。\n\n    typeof true; // \"boolean\"\n    \n    typeof false; // \"boolean\"\n    \n    Boolean(new Object()); //true\n    \n    Boolean(undefined); //false\n    \n    Boolean(null); //false\n    \n    Boolean(''); //false\n    \n    Boolean(0); //false\n    \n    Boolean(100); // true\n    \n    Boolean([]) // true\n     \n    Boolean({}) // true\n    \nif判断语句中自动调用Boolean()。\n\n    if (x = y + z){} //将值 y + z 赋给变量 x，然后检查整个表达式的结果（x 的值）是否为 0。\n\n### Number类型\n\n","slug":"3-第三章基本概念","published":1,"updated":"2016-01-29T01:58:59.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhys000un83v2lbt3abe"},{"title":"第二章 在HTML中使用JavaScrpt","date":"2016-01-05T06:25:13.000Z","comments":1,"_content":"## script元素\n\n`<script src=\"demo.js\"></script>`尽管`<script>` 标签内没有内容，结束的 `</script>` 标签也是必需的。外部文件一般扩展名为.js，但这不是强制的，不写.js扩展名一样可以运行。\n<!--more-->\n* type 这个属性不是必须的，默认值是 “text /javascript”，表示的是编写代码使用的脚本语言的内容类型（也称为MIME 类型）。服务器在传送js文件时使用的MIME类型，通常是application/x-javascript，但在type中设置这个值可能会导致脚本被忽略，考虑到约定俗成和最大浏览器兼容性，目前type属性的值依旧还是text/javascript。\n*  async  只适用外部引入脚本。\n*  defer 只适用外部引入脚本。\n*  language 已废弃。\n*  src\n\n>1. 如果通过&lt;script&gt;&lt;/script&gt;向页面写入一段可以执行的js代码？。\n>\n        <script>\n            document.write('&lt;script&gt;alert(0)&lt;/script&gt;');//alert(0); 不执行\n            document.write('<script>alert(4)</scr'+'ipt>'); //正常弹窗\n            document.write('<script>alert(2)<\\/script>'); //正常弹窗\n            document.write('<script>alert(3)</script>'); //报错\n        </script>\n\n>2. 执行顺序：\n>无论如何包含代码，只要不存在defer 和async 属性，浏览器都会按照`<script>`元素在页面中出现的先后顺序对它们依次进行解析。换句话说，在第一个`<script>`元素包含的代码解析完成后，第二个`<script>`包含的代码才会被解析，然后才是第三个、第四个……\n\n## 标签的位置\n\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <title>Example HTML Page</title>\n        </head>\n        <body>\n            <!-- 这里放内容 -->\n            <script type=\"text/javascript\" src=\"example1.js\"></script>\n            <script type=\"text/javascript\" src=\"example2.js\"></script>\n        </body>\n    </html>\n## 延迟脚本 defer\n\ndefer这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕(`/HTML`)后再运行。因此，在`<script>`元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\nIE4、Firefox 3.5、Safari 5 和Chrome ，其他浏览器会忽略这个属性。为此，把延迟脚本放在页面底部仍然是最佳选择。\n>**defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载**\n## 异步脚本 async\n\nHTML5 为`<script>`元素定义了async 属性。指定async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\n- Firefox 3.6、Safari 5 和Chrome。\n- ie系列，async没有任何效果\n- 在chrome下，只有外联脚本，且是在body中引用的，才能生效.\n- **异步执行的表现是，在DOMContentLoaded事件之后，window.loaded事件之前，所以，这个属性处理阻塞的问题是可行的**\n\n## Defer和async的区别\n\n先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：\n`<script src=\"script.js\"></script>`\n没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。\n`<script async src=\"script.js\"></script>`\n有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n`<script defer src=\"myscript.js\"></script>`\n有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。\n\n然后从实用角度来说呢，首先把所有脚本都丢到 `</body>` 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。\n接着，我们来看一张图咯：\n\n{% asset_img deferAsync.png %}\n\n**此图告诉我们以下几个要点：**\ndefer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。\n\n### Defer async常规表现（一些高级浏览器）\n\n* herder\nheader中行内脚本执行顺序不受defer async影响，顺序执行，会阻塞DOMContentLoaded。\nheader中行内脚本中ajax请求不会对页面加载带来任何阻塞。\nheader中引用外部脚本，添加defer async后，浏览器表现情况不统一，async的可能先执行，所以引用外部脚本并不适合加在header中，也不适合添加defer async标示。\n* body\nbody中图片加载会阻塞window.loaded,不会阻塞DOMContentLoaded。\nbody中行内脚本执行顺序不受defer async影响，顺序执行，阻塞DOMContentLoaded。\nbody中行内脚本ajax请求不会阻塞页面加载。\nbody中引用外部脚本，defer async表现正常，外部脚本应该加在body中，body结束标签上面。\n* ajax\n无论是header还是body中，行内脚本执行的ajax还是外部脚本执行的ajax，都对页面加载没有影响。\n* 总结\n1. defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载。\n2. async脚本都会在loaded之前执行，它会阻塞window.loaded。\n3. DOMContentLoaded在window.loaded之前执行，阻塞DOMContentLoaded也就会阻塞window.loaded\n4. document ready在DOMContentLoaded之前执行，说明document ready是监听DOMContentLoaded完成的\n### IE\n\n1. IE支持defer属性,不支持async属性，从IE9及以上支持onload,支持DOMContentLoaded。\n2. IE6，7支持行内脚本defer属性， 从表现上来看IE6,7,8,9都支持行内脚本的defer，所以我们在ie6,7,8,9中观察到的现象是，行内的先执行async,再执行没加defer async标记的，defer的延迟执行了。\n3. 同时我们又发现IE6,7脚本中ajax影响了页面加载，影响document ready,IE8及以上版本不受影响。\n4. 到了IE8以上，表现和webkit内核浏览器基本相似了。\n\n**不是动态添加的脚本，都会阻塞页DOMContentLoaded，动态添加的脚本应该在document ready后加载，但是也会阻塞loaded**\n>不懂DOMContentLoaded的点[这里](http://www.yangshengdonghome.com/2016/01/08/DOMContentLoaded/)。\n\n## 嵌入代码与外部文件\n\n* 推荐通过`<script>`标签引入外部js文件。\n* 浏览器能够根据具体的设置缓存链接的所有外部JavaScript 文件。也就是说，如果有两个\n页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的\n速度。\n\n## 文档模式 `<!DOCTYPE *>`\n\nE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。\n1. 混杂模式（quirks mode）\n2. 标准模式（standards mode）\n3. 准标准模式（almost standards mode）\n\n如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。\n>现在所有的HTML文档都推荐使用HTML5规定的`<!DOCTYPE html>`\n\n## noscript\n\n包含在`<noscript></noscript>`元素中的内容只有在下列情况下才会显示出来：\n* 浏览器不支持脚本；\n* 浏览器支持脚本，但脚本被禁用。\n","source":"_posts/2-在HTML中使用JavaScrpt-2016-01-05.md","raw":"title: 第二章 在HTML中使用JavaScrpt\ndate: 2016-01-05 14:25:13\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n## script元素\n\n`<script src=\"demo.js\"></script>`尽管`<script>` 标签内没有内容，结束的 `</script>` 标签也是必需的。外部文件一般扩展名为.js，但这不是强制的，不写.js扩展名一样可以运行。\n<!--more-->\n* type 这个属性不是必须的，默认值是 “text /javascript”，表示的是编写代码使用的脚本语言的内容类型（也称为MIME 类型）。服务器在传送js文件时使用的MIME类型，通常是application/x-javascript，但在type中设置这个值可能会导致脚本被忽略，考虑到约定俗成和最大浏览器兼容性，目前type属性的值依旧还是text/javascript。\n*  async  只适用外部引入脚本。\n*  defer 只适用外部引入脚本。\n*  language 已废弃。\n*  src\n\n>1. 如果通过&lt;script&gt;&lt;/script&gt;向页面写入一段可以执行的js代码？。\n>\n        <script>\n            document.write('&lt;script&gt;alert(0)&lt;/script&gt;');//alert(0); 不执行\n            document.write('<script>alert(4)</scr'+'ipt>'); //正常弹窗\n            document.write('<script>alert(2)<\\/script>'); //正常弹窗\n            document.write('<script>alert(3)</script>'); //报错\n        </script>\n\n>2. 执行顺序：\n>无论如何包含代码，只要不存在defer 和async 属性，浏览器都会按照`<script>`元素在页面中出现的先后顺序对它们依次进行解析。换句话说，在第一个`<script>`元素包含的代码解析完成后，第二个`<script>`包含的代码才会被解析，然后才是第三个、第四个……\n\n## 标签的位置\n\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <title>Example HTML Page</title>\n        </head>\n        <body>\n            <!-- 这里放内容 -->\n            <script type=\"text/javascript\" src=\"example1.js\"></script>\n            <script type=\"text/javascript\" src=\"example2.js\"></script>\n        </body>\n    </html>\n## 延迟脚本 defer\n\ndefer这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕(`/HTML`)后再运行。因此，在`<script>`元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\nIE4、Firefox 3.5、Safari 5 和Chrome ，其他浏览器会忽略这个属性。为此，把延迟脚本放在页面底部仍然是最佳选择。\n>**defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载**\n## 异步脚本 async\n\nHTML5 为`<script>`元素定义了async 属性。指定async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。\n>**注意：**\n>多个延迟脚本并不一定会按照顺序执行，因此最好只包含一个延迟脚本。\n>**浏览器支持情况：**\n- Firefox 3.6、Safari 5 和Chrome。\n- ie系列，async没有任何效果\n- 在chrome下，只有外联脚本，且是在body中引用的，才能生效.\n- **异步执行的表现是，在DOMContentLoaded事件之后，window.loaded事件之前，所以，这个属性处理阻塞的问题是可行的**\n\n## Defer和async的区别\n\n先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：\n`<script src=\"script.js\"></script>`\n没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。\n`<script async src=\"script.js\"></script>`\n有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n`<script defer src=\"myscript.js\"></script>`\n有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。\n\n然后从实用角度来说呢，首先把所有脚本都丢到 `</body>` 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。\n接着，我们来看一张图咯：\n\n{% asset_img deferAsync.png %}\n\n**此图告诉我们以下几个要点：**\ndefer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。\n\n### Defer async常规表现（一些高级浏览器）\n\n* herder\nheader中行内脚本执行顺序不受defer async影响，顺序执行，会阻塞DOMContentLoaded。\nheader中行内脚本中ajax请求不会对页面加载带来任何阻塞。\nheader中引用外部脚本，添加defer async后，浏览器表现情况不统一，async的可能先执行，所以引用外部脚本并不适合加在header中，也不适合添加defer async标示。\n* body\nbody中图片加载会阻塞window.loaded,不会阻塞DOMContentLoaded。\nbody中行内脚本执行顺序不受defer async影响，顺序执行，阻塞DOMContentLoaded。\nbody中行内脚本ajax请求不会阻塞页面加载。\nbody中引用外部脚本，defer async表现正常，外部脚本应该加在body中，body结束标签上面。\n* ajax\n无论是header还是body中，行内脚本执行的ajax还是外部脚本执行的ajax，都对页面加载没有影响。\n* 总结\n1. defer执行的脚本都会在DOMContentLoaded之前就执行，defer会阻塞页面加载。\n2. async脚本都会在loaded之前执行，它会阻塞window.loaded。\n3. DOMContentLoaded在window.loaded之前执行，阻塞DOMContentLoaded也就会阻塞window.loaded\n4. document ready在DOMContentLoaded之前执行，说明document ready是监听DOMContentLoaded完成的\n### IE\n\n1. IE支持defer属性,不支持async属性，从IE9及以上支持onload,支持DOMContentLoaded。\n2. IE6，7支持行内脚本defer属性， 从表现上来看IE6,7,8,9都支持行内脚本的defer，所以我们在ie6,7,8,9中观察到的现象是，行内的先执行async,再执行没加defer async标记的，defer的延迟执行了。\n3. 同时我们又发现IE6,7脚本中ajax影响了页面加载，影响document ready,IE8及以上版本不受影响。\n4. 到了IE8以上，表现和webkit内核浏览器基本相似了。\n\n**不是动态添加的脚本，都会阻塞页DOMContentLoaded，动态添加的脚本应该在document ready后加载，但是也会阻塞loaded**\n>不懂DOMContentLoaded的点[这里](http://www.yangshengdonghome.com/2016/01/08/DOMContentLoaded/)。\n\n## 嵌入代码与外部文件\n\n* 推荐通过`<script>`标签引入外部js文件。\n* 浏览器能够根据具体的设置缓存链接的所有外部JavaScript 文件。也就是说，如果有两个\n页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的\n速度。\n\n## 文档模式 `<!DOCTYPE *>`\n\nE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。\n1. 混杂模式（quirks mode）\n2. 标准模式（standards mode）\n3. 准标准模式（almost standards mode）\n\n如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。\n>现在所有的HTML文档都推荐使用HTML5规定的`<!DOCTYPE html>`\n\n## noscript\n\n包含在`<noscript></noscript>`元素中的内容只有在下列情况下才会显示出来：\n* 浏览器不支持脚本；\n* 浏览器支持脚本，但脚本被禁用。\n","slug":"2-在HTML中使用JavaScrpt","published":1,"updated":"2016-01-20T01:33:33.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhyx000yn83v6s0mnvnp"},{"title":"第一章 JavaScrpt简介","date":"2016-01-05T06:24:40.000Z","comments":1,"_content":"先简要说一下和JavaScript相关的一些背景术语，就不详细讨论JavaScript的历史了，想了解的朋友可以参考原书。\n<!--more-->\n+ ECMA：\n欧洲计算机制造商协会（Standard ECMA-262European Computer Manufacturers Association）\n+ TC39：\nECMA第39号技术委员会（Technical Committee#39），由来自一些关注脚本语言发展的公司的程序员组成，负责制定一种通用、跨平台、供应商中立的脚本语言。\n+ ECMAScript：\n由ECMA制定，在ECMA-262中定义的脚本语言标准。ECMAScript只是一个脚本语言标准，你尽可以在自己的环境中取实现它，这个环境，就称为ECMAScript的宿主环境，Web浏览器可以说是ECMAScript目前最重要的宿主环境了，而不同的Web浏览器，对ECMAScript标准的支持也不尽相同。除Web浏览器，Adobe ActionScript也实现了ECMAScript。一般的宿主环境，除了实现ECMAScript标准，也会有各自的扩展，以便与环境更好的交互。\n+ ES3、ES5、ES6：是指ECMAScript 的三个版本，最新版是ES6，已经有部分特性被浏览器支持。[查看各个版本被各大浏览器的支持情况](http://kangax.github.io/compat-table/es5/)。\n+ DOM\n>+  **DOM1级：**\n> DOM1 级由两个模块组成：DOM核心（DOM Core）和DOM HTML。其中，DOM 核心规定的是如何映射基于XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在DOM 核心的基础上加以扩展，添加了针对HTML 的对象和方法。\n>+  **DOM2级：**\n>DOM2 级在原来DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1 级中的DOM核心模块也经过扩展开始支持XML 命名空间。\n>+  **DOM3级：**\n>1. 引入了以统一方式加载和保存文档的方法\n>2. 新增了验证文档的方法\n>3. DOM3 级也对DOM 核心进行了扩展，开始支持XML 1.0 规范，涉及XML Infoset、XPath和XML Base。\n\n* **BOM ：**\n从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的JavaScript 扩展算作BOM的一部分。下面就是一些这样的扩展：\n>1. 弹出新浏览器窗口的功能；\n>2. 移动、缩放和关闭浏览器窗口的功能；\n>3. 提供浏览器详细信息的navigator 对象；\n>4. 提供浏览器所加载页面的详细信息的location 对象；\n>5. 提供用户显示器分辨率详细信息的screen 对象；\n>6. 对cookies 的支持；\n>7. 像XMLHttpRequest 和IE 的ActiveXObject 这样的自定义对象。\n\n\n+ LiveScript、JavaScript、JScript：\nLiveScript是JavaScript的前身，而JScript则是微软为了防止版权冲突而给自己的脚本语言起的名称。他们除了实现了ECMAScript外，还会包括针对浏览器的扩展（BOM：浏览器对象模型）和针对XML/HTML API的扩展（DOM：文档对象模型）。\n>JavaScript 是一种专为网页交互设计的脚本语言，由下列三个不同的部分组成：\n>>ECMAScript：规定了以下这些内容：语法、类型、语句、关键字、保留字、操作符、对象\n>\n>>DOM：文档对象模型（Document Object Model）\n>\n>>BOM：浏览器对象模型（Browser Object Model）","source":"_posts/1-JavaScrpt简介-2016-01-05.md","raw":"title: 第一章 JavaScrpt简介\ndate: 2016-01-05 14:24:40\ntags:\n- JavaScript\ncomments: true\ncategories:\n- 《JS高程3-笔记》\n---\n先简要说一下和JavaScript相关的一些背景术语，就不详细讨论JavaScript的历史了，想了解的朋友可以参考原书。\n<!--more-->\n+ ECMA：\n欧洲计算机制造商协会（Standard ECMA-262European Computer Manufacturers Association）\n+ TC39：\nECMA第39号技术委员会（Technical Committee#39），由来自一些关注脚本语言发展的公司的程序员组成，负责制定一种通用、跨平台、供应商中立的脚本语言。\n+ ECMAScript：\n由ECMA制定，在ECMA-262中定义的脚本语言标准。ECMAScript只是一个脚本语言标准，你尽可以在自己的环境中取实现它，这个环境，就称为ECMAScript的宿主环境，Web浏览器可以说是ECMAScript目前最重要的宿主环境了，而不同的Web浏览器，对ECMAScript标准的支持也不尽相同。除Web浏览器，Adobe ActionScript也实现了ECMAScript。一般的宿主环境，除了实现ECMAScript标准，也会有各自的扩展，以便与环境更好的交互。\n+ ES3、ES5、ES6：是指ECMAScript 的三个版本，最新版是ES6，已经有部分特性被浏览器支持。[查看各个版本被各大浏览器的支持情况](http://kangax.github.io/compat-table/es5/)。\n+ DOM\n>+  **DOM1级：**\n> DOM1 级由两个模块组成：DOM核心（DOM Core）和DOM HTML。其中，DOM 核心规定的是如何映射基于XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在DOM 核心的基础上加以扩展，添加了针对HTML 的对象和方法。\n>+  **DOM2级：**\n>DOM2 级在原来DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1 级中的DOM核心模块也经过扩展开始支持XML 命名空间。\n>+  **DOM3级：**\n>1. 引入了以统一方式加载和保存文档的方法\n>2. 新增了验证文档的方法\n>3. DOM3 级也对DOM 核心进行了扩展，开始支持XML 1.0 规范，涉及XML Infoset、XPath和XML Base。\n\n* **BOM ：**\n从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的JavaScript 扩展算作BOM的一部分。下面就是一些这样的扩展：\n>1. 弹出新浏览器窗口的功能；\n>2. 移动、缩放和关闭浏览器窗口的功能；\n>3. 提供浏览器详细信息的navigator 对象；\n>4. 提供浏览器所加载页面的详细信息的location 对象；\n>5. 提供用户显示器分辨率详细信息的screen 对象；\n>6. 对cookies 的支持；\n>7. 像XMLHttpRequest 和IE 的ActiveXObject 这样的自定义对象。\n\n\n+ LiveScript、JavaScript、JScript：\nLiveScript是JavaScript的前身，而JScript则是微软为了防止版权冲突而给自己的脚本语言起的名称。他们除了实现了ECMAScript外，还会包括针对浏览器的扩展（BOM：浏览器对象模型）和针对XML/HTML API的扩展（DOM：文档对象模型）。\n>JavaScript 是一种专为网页交互设计的脚本语言，由下列三个不同的部分组成：\n>>ECMAScript：规定了以下这些内容：语法、类型、语句、关键字、保留字、操作符、对象\n>\n>>DOM：文档对象模型（Document Object Model）\n>\n>>BOM：浏览器对象模型（Browser Object Model）","slug":"1-JavaScrpt简介","published":1,"updated":"2016-01-22T05:57:44.000Z","layout":"post","photos":[],"link":"","_id":"cijzdrhzb0011n83vked4sy7q"}],"PostAsset":[{"_id":"source/_posts/好好学学number-2016-01-29/number.png","post":"cijzdrhxq000cn83vucqgojzv","slug":"number.png","modified":1},{"_id":"source/_posts/好好学学number-2016-01-29/number2.png","post":"cijzdrhxq000cn83vucqgojzv","slug":"number2.png","modified":1},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/onLoadVSDomContentLoaded.png","post":"cijzdrhyg000qn83v4d42m54t","slug":"onLoadVSDomContentLoaded.png","modified":1},{"_id":"source/_posts/DOMContentLoaded-2016-01-08/zongjie.png","post":"cijzdrhyg000qn83v4d42m54t","slug":"zongjie.png","modified":1},{"_id":"source/_posts/2-在HTML中使用JavaScrpt-2016-01-05/deferAsync.png","post":"cijzdrhyx000yn83v6s0mnvnp","slug":"deferAsync.png","modified":1}],"PostCategory":[{"post_id":"cijzdrhxc0002n83vgfezhbge","category_id":"cijzdrhxg0003n83vsrqmkobk","_id":"cijzdrhxj0006n83vjqwc3e6y"},{"post_id":"cijzdrhxl0007n83vnni0mvzg","category_id":"cijzdrhxg0003n83vsrqmkobk","_id":"cijzdrhxm0008n83v86vsnegh"},{"post_id":"cijzdrhxz000dn83vvrp0l943","category_id":"cijzdrhxg0003n83vsrqmkobk","_id":"cijzdrhy0000en83vo9pj3oqb"},{"post_id":"cijzdrhy3000hn83v5khk0odp","category_id":"cijzdrhxg0003n83vsrqmkobk","_id":"cijzdrhy4000in83vscflcuk5"},{"post_id":"cijzdrhy7000kn83vvnq6v9fm","category_id":"cijzdrhxg0003n83vsrqmkobk","_id":"cijzdrhy7000ln83vqederfau"},{"post_id":"cijzdrhyg000qn83v4d42m54t","category_id":"cijzdrhxg0003n83vsrqmkobk","_id":"cijzdrhyi000rn83vi6k2bmcx"},{"post_id":"cijzdrhys000un83v2lbt3abe","category_id":"cijzdrhyt000vn83vixvj8dbl","_id":"cijzdrhyv000xn83v6clwkws6"},{"post_id":"cijzdrhyx000yn83v6s0mnvnp","category_id":"cijzdrhyt000vn83vixvj8dbl","_id":"cijzdrhyy000zn83vtduncluw"},{"post_id":"cijzdrhzb0011n83vked4sy7q","category_id":"cijzdrhyt000vn83vixvj8dbl","_id":"cijzdrhzd0012n83vpc75m3k6"}],"PostTag":[{"post_id":"cijzdrhxc0002n83vgfezhbge","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhxi0005n83v3dm1yz79"},{"post_id":"cijzdrhxl0007n83vnni0mvzg","tag_id":"cijzdrhxn0009n83vj1zbr86s","_id":"cijzdrhxn000an83voa602nif"},{"post_id":"cijzdrhxl0007n83vnni0mvzg","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhxo000bn83vcl3xblg2"},{"post_id":"cijzdrhxz000dn83vvrp0l943","tag_id":"cijzdrhxn0009n83vj1zbr86s","_id":"cijzdrhy1000fn83v8h4402bf"},{"post_id":"cijzdrhxz000dn83vvrp0l943","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhy1000gn83veqe48y80"},{"post_id":"cijzdrhy3000hn83v5khk0odp","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhy4000jn83vg7nvhys5"},{"post_id":"cijzdrhy7000kn83vvnq6v9fm","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhy8000mn83vyv976g3s"},{"post_id":"cijzdrhyc000on83v1hlgdbor","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhyd000pn83v2r1tgb64"},{"post_id":"cijzdrhyg000qn83v4d42m54t","tag_id":"cijzdrhxn0009n83vj1zbr86s","_id":"cijzdrhyi000sn83vunxhpelh"},{"post_id":"cijzdrhyg000qn83v4d42m54t","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhyj000tn83vfn3tbe92"},{"post_id":"cijzdrhys000un83v2lbt3abe","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhyu000wn83vvzrf0kqm"},{"post_id":"cijzdrhyx000yn83v6s0mnvnp","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhyz0010n83vcvk326fk"},{"post_id":"cijzdrhzb0011n83vked4sy7q","tag_id":"cijzdrhxh0004n83vebrd5c6v","_id":"cijzdrhzd0013n83v0gyprvzn"}],"Tag":[{"name":"JavaScript","_id":"cijzdrhxh0004n83vebrd5c6v"},{"name":"jQuery","_id":"cijzdrhxn0009n83vj1zbr86s"}]}}